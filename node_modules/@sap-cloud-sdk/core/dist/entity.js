"use strict";
/* Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved. */
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
var entity_builder_1 = require("./entity-builder");
var selectable_1 = require("./selectable");
var util_1 = require("./util");
var name_converter_1 = require("./util/name-converter");
/**
 * Super class for all representations of OData entity types.
 */
var Entity = /** @class */ (function () {
    function Entity() {
        util_1.nonEnumerable(this, '_customFields');
        this._customFields = {};
    }
    Entity.entityBuilder = function (entityConstructor) {
        var builder = new entity_builder_1.EntityBuilder(entityConstructor);
        entityConstructor._allFields.forEach(function (field) {
            var fieldName = "" + name_converter_1.toPropertyFormat(field._fieldName);
            builder[fieldName] = function (value) {
                this.entity[fieldName] = value;
                return this;
            };
        });
        return builder;
    };
    Entity.customFieldSelector = function (fieldName, entityConstructor) {
        return new selectable_1.CustomField(fieldName, entityConstructor);
    };
    Object.defineProperty(Entity.prototype, "versionIdentifier", {
        /**
         * ETag version identifier accessor.
         *
         * @returns The ETag version identifier of the retrieved entity, returns undefined if not retrieved
         */
        get: function () {
            return this._versionIdentifier;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Returns a map that contains all entity custom fields.
     *
     * @returns A map of all defined custom fields in the entity
     */
    Entity.prototype.getCustomFields = function () {
        return this._customFields;
    };
    /**
     * Custom field value getter.
     *
     * @param fieldName - The name of the custom field
     * @returns The value of the corresponding custom field
     */
    Entity.prototype.getCustomField = function (fieldName) {
        return this._customFields[fieldName];
    };
    /**
     * Sets a new custom field in the entity or updates it.
     * Throws an error, if the provided custom field name is already defined by an original field in entity.
     *
     * @param fieldName - The name of the custom field to update
     * @param value - The value of the field
     * @returns The entity itself, to facilitate method chaining
     */
    Entity.prototype.setCustomField = function (fieldName, value) {
        if (this.isConflictingCustomField(fieldName)) {
            throw new Error("The field name \"" + fieldName + "\" is already defined in the entity and cannot be set as custom field.");
        }
        this._customFields[fieldName] = value;
        return this;
    };
    /**
     * Validates whether a custom field exists in the entity.
     *
     * @param fieldName - The name of the custom field to update
     * @returns A boolean value, that indicates whether a custom field is defined in entity
     */
    Entity.prototype.hasCustomField = function (fieldName) {
        return this._customFields[fieldName] !== undefined;
    };
    /**
     * Sets all retrieved custom fields in entity.
     *
     * @param customFields - Extracted custom fields from a retrieved entity
     * @returns A boolean value, that indicates the existence of the field in entity
     */
    Entity.prototype.initializeCustomFields = function (customFields) {
        var _this = this;
        Object.entries(customFields).forEach(function (cf) {
            _this.setCustomField(cf[0], cf[1]);
        });
        return this;
    };
    /**
     * Set the ETag version identifier of the retrieved entity.
     *
     * @param etag - The returned ETag version of the entity
     * @returns The entity itself, to facilitate method chaining
     */
    Entity.prototype.setVersionIdentifier = function (etag) {
        if (etag && typeof etag === 'string') {
            util_1.nonEnumerable(this, '_versionIdentifier');
            this._versionIdentifier = etag;
        }
        return this;
    };
    /**
     * Initializes or sets the remoteState of the entity.
     * This function is called on all read, create and update requests.
     * This function should be called after [[initializeCustomFields]], if custom fields are defined.
     *
     * @deprecated Since 1.12.0. Will be removed in version 2.0.
     * @param state - State to be set as remote state
     * @returns The entity itself, to facilitate method chaining
     */
    Entity.prototype.setOrInitializeRemoteState = function (state) {
        var _this = this;
        if (!this.remoteState) {
            util_1.nonEnumerable(this, 'remoteState');
            this.remoteState = {};
        }
        if (state) {
            Object.entries(state).forEach(function (_a) {
                var fieldName = _a[0], value = _a[1];
                if (_this[name_converter_1.toPropertyFormat(fieldName)]) {
                    _this.remoteState[name_converter_1.toPropertyFormat(fieldName)] = value;
                }
                else {
                    // We store the custom field with its original name in the remote state
                    _this.remoteState[fieldName] = value;
                }
            });
        }
        else {
            this.remoteState = this.getCurrentMapKeys();
        }
        return this;
    };
    /**
     * Returns all updated custom field properties compared to the last known remote state.
     *
     * @returns A map containing all updated custom properties, with their new values
     */
    Entity.prototype.getUpdatedCustomFields = function () {
        var _this = this;
        if (this.remoteState === undefined) {
            return this._customFields;
        }
        return Object.entries(this.getCustomFields())
            .filter(function (_a) {
            var fieldName = _a[0], value = _a[1];
            return _this.remoteState[fieldName] !== value;
        })
            .reduce(function (updatedCustomFields, _a) {
            var _b;
            var fieldName = _a[0], value = _a[1];
            return (__assign(__assign({}, updatedCustomFields), (_b = {}, _b[fieldName] = value, _b)));
        }, {});
    };
    /**
     * Returns all changed properties compared to the last known remote state.
     * The returned properties does not include custom fields. Use [[getUpdatedCustomFields]], if updated custom fields are needed.
     *
     * @returns Entity with all properties that changed
     */
    Entity.prototype.getUpdatedProperties = function () {
        var _this = this;
        var current = this.getCurrentMapKeys();
        if (this.remoteState === undefined) {
            return current;
        }
        var patch = {};
        Object.keys(current)
            .filter(function (key) { return _this.propertyIsEnumerable(key); })
            .filter(function (key) { return !_this.hasCustomField(key); })
            .forEach(function (key) {
            if (_this.remoteState[key] !== current[key]) {
                patch[key] = current[key];
            }
        });
        return patch;
    };
    /**
     * Returns a map of all defined fields in entity to their current values.
     *
     * @returns Entity with all defined entity fields
     */
    Entity.prototype.getCurrentMapKeys = function () {
        var _this = this;
        return Object.keys(this)
            .filter(function (key) { return _this.propertyIsEnumerable(key); })
            .reduce(function (accumulatedMap, key) {
            var _a;
            return (__assign(__assign({}, accumulatedMap), (_a = {}, _a[key] = _this[key], _a)));
        }, this.getCustomFields());
    };
    /**
     * Validates whether a field name does not conflict with an original field name and thus can be defined as custom fields.
     *
     * @param customFieldName - Field name to check
     * @returns Boolean value that describes whether a field name can be defined as custom field
     */
    Entity.prototype.isConflictingCustomField = function (customFieldName) {
        return this[name_converter_1.toPropertyFormat(customFieldName)] !== undefined;
    };
    return Entity;
}());
exports.Entity = Entity;
/* eslint-disable valid-jsdoc */
/**
 * @hidden
 */
function isSelectedProperty(json, selectable) {
    return json.hasOwnProperty(selectable._fieldName);
}
exports.isSelectedProperty = isSelectedProperty;
/**
 * @hidden
 */
function isExistentProperty(json, link) {
    return isSelectedProperty(json, link) && json[link._fieldName] !== null;
}
exports.isExistentProperty = isExistentProperty;
/**
 * @hidden
 */
function isExpandedProperty(json, link) {
    return isExistentProperty(json, link) && !json[link._fieldName].hasOwnProperty('__deferred');
}
exports.isExpandedProperty = isExpandedProperty;
//# sourceMappingURL=entity.js.map