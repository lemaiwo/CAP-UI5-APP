"use strict";
/* Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved. */
var __extends = (this && this.__extends) || (function () {
    var extendStatics = function (d, b) {
        extendStatics = Object.setPrototypeOf ||
            ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
            function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };
        return extendStatics(d, b);
    };
    return function (d, b) {
        extendStatics(d, b);
        function __() { this.constructor = d; }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    };
})();
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [op[0] & 2, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
var util_1 = require("@sap-cloud-sdk/util");
var rambda_1 = require("rambda");
var uuid_1 = require("uuid");
var entity_deserializer_1 = require("./entity-deserializer");
var odata_batch_change_set_1 = require("./odata-batch-change-set");
var odata_batch_retrieve_request_1 = require("./odata-batch-retrieve-request");
var odate_batch_consts_1 = require("./odate-batch-consts");
var request_builder_1 = require("./request-builder");
var odata_batch_config_1 = require("./request-builder/request/odata-batch-config");
var scp_cf_1 = require("./scp-cf");
var changesetIdPrefix = 'Content-Type: multipart/mixed; boundary=';
/**
 * The OData batch request builder to build a batch, which consists of an ordered retrieve requests or change sets.
 *
 */
var ODataBatchRequestBuilder = /** @class */ (function (_super) {
    __extends(ODataBatchRequestBuilder, _super);
    /**
     * Creates an instance of ODataBatchRequestBuilder.
     *
     * @param defaultServicePath - Service path
     * @param requests - An array of retrieve requests or change sets
     * @param entityToConstructorMap - A map that holds the entity type to constructor mapping
     */
    function ODataBatchRequestBuilder(defaultServicePath, requests, entityToConstructorMap) {
        var _this = _super.call(this, new odata_batch_config_1.ODataBatchConfig(defaultServicePath, uuid_1.v4())) || this;
        _this.defaultServicePath = defaultServicePath;
        _this.requests = requests;
        _this.entityToConstructorMap = entityToConstructorMap;
        _this.requestConfig.payload = getPayload(requests, _this.requestConfig);
        return _this;
    }
    /**
     * Execute the given request and return the according promise. Please notice: The sub-requests may fail even the main request is successful.
     *
     * @param destination - Targeted destination on which the request is performed.
     * @param options - Options to employ when fetching destinations.
     * @returns Promise resolving to the requested data.
     */
    ODataBatchRequestBuilder.prototype.execute = function (destination, options) {
        return __awaiter(this, void 0, void 0, function () {
            var _this = this;
            return __generator(this, function (_a) {
                return [2 /*return*/, this.build(destination, options)
                        .then(function (request) { return request.execute(); })
                        .then(function (response) {
                        return buildResponses(partitionBatchResponse(response.data, _this.detectLineBreak(response)), _this.entityToConstructorMap, _this.detectLineBreak(response));
                    })
                        .catch(function (error) {
                        return Promise.reject(util_1.errorWithCause("The batch request failed! The destination provided: " + scp_cf_1.toDestinationNameUrl(destination) + " and the options: " + options + ".", error));
                    })];
            });
        });
    };
    ODataBatchRequestBuilder.prototype.detectLineBreak = function (response) {
        var body = response.data;
        if (body.split('\r\n').length > 1) {
            return '\r\n';
        }
        else if (body.split('\n').length > 1) {
            return '\n';
        }
        else {
            throw new Error("Cannot detect the line break of the response body: " + body + ".");
        }
    };
    return ODataBatchRequestBuilder;
}(request_builder_1.MethodRequestBuilderBase));
exports.ODataBatchRequestBuilder = ODataBatchRequestBuilder;
/**
 * Convert the given requests to the payload of the batch.
 *
 * @param requests - Requests of the batch.
 * @param requestConfig - The batch request configuration.
 * @returns The generated payload.
 */
function getPayload(requests, requestConfig) {
    var payloads = requests.map(toRequestBody).filter(function (b) { return !!b; });
    if (payloads.length > 0) {
        return (payloads.map(function (part) { return getBatchRequestStartWithLineBreak(requestConfig.batchId) + part; }).join('\n') +
            '\n' +
            getEndBatchWithLineBreak(requestConfig.batchId));
    }
    else {
        return '';
    }
}
function toRequestBody(request) {
    if (request instanceof request_builder_1.GetAllRequestBuilder || request instanceof request_builder_1.GetByKeyRequestBuilder) {
        return odata_batch_retrieve_request_1.toBatchRetrieveBody(request);
    }
    else if (request instanceof odata_batch_change_set_1.ODataBatchChangeSet) {
        return odata_batch_change_set_1.toBatchChangeSet(request);
    }
    else {
        throw Error("The request: " + JSON.stringify(request) + " is not a valid retrieve request or change set.");
    }
}
function buildResponses(responses, entityToConstructorMap, lineBreak) {
    return responses.map(function (r) { return buildResponse(r, entityToConstructorMap, lineBreak); });
}
function buildResponse(response, entityToConstructorMap, lineBreak) {
    if (isChangeSet(response)) {
        return buildWriteResponses(response, entityToConstructorMap, lineBreak);
    }
    else if (isRetrieveRequestOrError(response)) {
        return buildRetrieveOrErrorResponse(response, entityToConstructorMap, lineBreak);
    }
    else {
        throw Error("The response: " + JSON.stringify(response) + " is not a valid retrieve request or change set, because it does not contain the proper Content-Type.");
    }
}
var asReadResponse = function (body) { return function (constructor) {
    if (body.error) {
        return new Error(body.error);
    }
    else if (body.d.__metadata) {
        return [entity_deserializer_1.deserializeEntity(body.d, constructor)];
    }
    else {
        return body.d.results.map(function (r) { return entity_deserializer_1.deserializeEntity(r, constructor); });
    }
}; };
var asWriteResponse = function (body) { return function (constructor) {
    if (!body.d.__metadata) {
        throw Error('The metadata of the response body is undefined.');
    }
    return entity_deserializer_1.deserializeEntity(body.d, constructor);
}; };
/*
E.g. response:
--batch_1234
part 1
--batch_1234
part 2
--batch_1234--
 */
function partitionBatchResponse(response, lineBreak) {
    response = response.trim();
    if (!response) {
        return [];
    }
    // E.g., --batch_1234
    var partSeparator = rambda_1.head(response.split(lineBreak, 1));
    if (!partSeparator) {
        throw Error("Failed to get part separator of the response: " + response);
    }
    // E.g., ['', part 1, part 2, '--']
    var parts = response.split(partSeparator).map(function (line) { return line.trim(); });
    // According to the example above, the min. length to be valid is 3, where the 1st and last elements should be removed.
    return parts.length >= 3 ? parts.slice(1, parts.length - 1) : [];
}
function partitionChangeSetResponse(responseOfSingleRetrieveRequest, lineBreak) {
    var firstLine = rambda_1.head(responseOfSingleRetrieveRequest.split(lineBreak, 1));
    if (!firstLine) {
        throw Error("Failed to get the first line of " + responseOfSingleRetrieveRequest + ".");
    }
    var changeSetId = rambda_1.last(firstLine.split(changesetIdPrefix));
    var parts = responseOfSingleRetrieveRequest.split("--" + changeSetId).map(function (line) { return line.trim(); });
    return parts.length >= 3 ? parts.slice(1, parts.length - 1) : [];
}
/*
Response example:
Content-Type: application/http
Content-Length: 2833
content-transfer-encoding: binary

HTTP/1.1 200 OK
Content-Type: application/json; charset=utf-8
Content-Length: 2626
sap-metadata-last-modified: Wed, 04 Sep 2019 14:52:57 GMT
cache-control: no-store, no-cache
dataserviceversion: 2.0

{"d":{"results":["something"]}}
--454DB24613455B1D7FBA89D16B5D9D610
 */
function trimRetrieveHeaders(retrieveResponse, lineBreak) {
    var lines = retrieveResponse.split(lineBreak);
    // A valid response should contain at least the line with the data and the line with the part id.
    if (lines.length <= 2) {
        throw Error("The retrieve response is " + retrieveResponse + ", which is not valid.");
    }
    // Then the line with the data is returned.
    return lines[lines.length - 1];
}
function toConstructableFromChangeSetResponse(responseBody, entityToConstructorMap) {
    return entityToConstructorMap[getEntityNameFromMetadata(responseBody.d.__metadata)];
}
function toConstructableFromRetrieveResponse(responseBody, entityToConstructorMap) {
    var entityJson;
    var data = responseBody.d;
    if (data.results && data.results.length) {
        // GetAll
        entityJson = data.results[0];
    }
    else if (data.results && !data.results.length) {
        // GetByKey C4C (!)
        entityJson = data.results;
    }
    else {
        // GetByKey
        entityJson = data;
    }
    return entityToConstructorMap[getEntityNameFromMetadata(entityJson.__metadata)];
}
function getEntityNameFromMetadata(metadata) {
    var entityUri = metadata.uri;
    var pathBeforeQuery = entityUri.split('?')[0];
    var pathBeforeKeys = pathBeforeQuery.split('(')[0];
    var uriParts = pathBeforeKeys.split('/');
    // Remove another part in case of a trailing slash
    var entityName = uriParts.pop() || uriParts.pop();
    if (!entityName) {
        throw Error("The uri of the response metadata cannot be parsed. URI: " + metadata.uri);
    }
    return entityName;
}
function getBatchRequestStartWithLineBreak(batchId) {
    return "--batch_" + batchId + "\n";
}
function getEndBatchWithLineBreak(batchId) {
    return "--batch_" + batchId + "--\n";
}
function getMethod(requestBuilder) {
    return requestBuilder.requestConfig.method;
}
function getUrl(requestBuilder) {
    return "/" + requestBuilder.relativeUrl();
}
function isChangeSet(response) {
    return !!response.match(/Content-Type: multipart\/mixed;/);
}
function isRetrieveRequestOrError(response) {
    return !!response.match(/Content-Type: application\/http/);
}
function isNoContent(response) {
    return !!response.match(/HTTP\/\d\.\d 204 No Content/);
}
function isCreated(response) {
    return !!response.match(/HTTP\/\d\.\d 201 Created/);
}
function toHttpCode(response) {
    var group = response.match(/HTTP\/\d\.\d (\d{3}).*?/);
    if (!group) {
        throw new Error("The response: " + response + " is not valid, because the http code cannot be retrieved.");
    }
    return parseInt(group[1].toString());
}
function toWriteResponseArray(response, lineBreak, entityToConstructorMap) {
    return partitionChangeSetResponse(response, lineBreak).map(function (r) {
        if (isNoContent(r)) {
            return { httpCode: 204 };
        }
        else if (isCreated(response)) {
            var parsedBody = JSON.parse(trimRetrieveHeaders(r, lineBreak));
            var entityType = toConstructableFromChangeSetResponse(parsedBody, entityToConstructorMap);
            if (!entityType) {
                throw Error("Cannot find the type from the parsedBody: " + parsedBody);
            }
            return {
                httpCode: 201,
                body: parsedBody,
                type: entityType,
                as: asWriteResponse(parsedBody)
            };
        }
        else {
            throw new Error("The request failed because http code of the response: " + r + " is not 201/204.");
        }
    });
}
function buildWriteResponses(response, entityToConstructorMap, lineBreak) {
    var writeResponses = toWriteResponseArray(response, lineBreak, entityToConstructorMap);
    return { responses: writeResponses, isSuccess: function () { return true; } };
}
function buildRetrieveOrErrorResponse(response, entityToConstructorMap, lineBreak) {
    var parsedBody = JSON.parse(trimRetrieveHeaders(response, lineBreak));
    var httpCode = toHttpCode(response);
    if (httpCode === 200) {
        return {
            httpCode: 200,
            body: parsedBody,
            type: toConstructableFromRetrieveResponse(parsedBody, entityToConstructorMap),
            as: asReadResponse(parsedBody),
            isSuccess: function () { return true; }
        };
    }
    else {
        return { httpCode: httpCode, body: parsedBody, isSuccess: function () { return false; } };
    }
}
/**
 * Generate the request line, containing method, url and http version from the request builder, e.g.:
 * GET /sap/opu/odata/sap/API_BUSINESS_PARTNER/A_BusinessPartnerAddress?$format=json&$top=1 HTTP/1.1
 * @param requestBuilder - Reqeust builder holds the request information.
 * @returns the generated request line.
 */
function getRequestLine(requestBuilder) {
    return getMethod(requestBuilder).toUpperCase() + " " + getUrl(requestBuilder) + " " + odate_batch_consts_1.http_version;
}
exports.getRequestLine = getRequestLine;
//# sourceMappingURL=odata-batch-request-builder.js.map