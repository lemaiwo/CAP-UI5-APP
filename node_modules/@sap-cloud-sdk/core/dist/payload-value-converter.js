"use strict";
/* Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved. */
/* eslint-disable valid-jsdoc */
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var moment_1 = __importDefault(require("moment"));
var rambda_1 = require("rambda");
/**
 * @hidden
 */
function edmToTs(value, edmType) {
    if (value === null || typeof value === 'undefined') {
        return value;
    }
    if (deserializers[edmType]) {
        return deserializers[edmType](value);
    }
    return value;
}
exports.edmToTs = edmToTs;
/**
 * @hidden
 */
function tsToEdm(value, edmType) {
    if (value === null) {
        return 'null';
    }
    if (serializers[edmType]) {
        return serializers[edmType](value);
    }
    return value;
}
exports.tsToEdm = tsToEdm;
var toNumber = function (value) { return Number(value); };
var toBigNumber = function (value) { return new bignumber_js_1.default(value); };
var toGuid = function (value) {
    var guids = /[A-Fa-f0-9]{8}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{4}-[A-Fa-f0-9]{12}/.exec(value);
    if (!guids || guids.length <= 0) {
        throw new Error("Failed to parse the value: " + value + " to guid.");
    }
    return guids[0];
};
var toTime = function (value) {
    var timeComponents = /PT(\d{1,2})H(\d{1,2})M(\d{1,2})S/.exec(value);
    if (!timeComponents) {
        throw new Error("Failed to parse the value: " + value + " to time.");
    }
    return {
        hours: parseInt(timeComponents[1], 10),
        minutes: parseInt(timeComponents[2], 10),
        seconds: parseInt(timeComponents[3], 10)
    };
};
var fromBigNumber = function (value) { return value.toString(); };
var fromTime = function (value) { return 'PT' + leftpad(value.hours, 2) + 'H' + leftpad(value.minutes, 2) + 'M' + leftpad(value.seconds, 2) + 'S'; };
/**
 * @hidden
 * This function can be used for both Edm.DateTime and and Edm.DateTimeOffset.
 */
function edmDateTimeToMoment(edmDateTime) {
    var dateTimeOffsetComponents = /.*\((-?\d+)(?:([\+-])(\d{4})\))?/.exec(edmDateTime);
    if (!dateTimeOffsetComponents) {
        throw new Error("Failed to parse edmDateTime: " + edmDateTime + " to moment.");
    }
    var timestamp = moment_1.default(parseInt(dateTimeOffsetComponents[1]));
    if (dateTimeOffsetComponents[2] && dateTimeOffsetComponents[3]) {
        var offsetMultiplier = dateTimeOffsetComponents[2] === '+' ? 1 : -1;
        var offsetInMinutes = parseInt(dateTimeOffsetComponents[3]);
        return timestamp.utc().utcOffset(offsetMultiplier * offsetInMinutes);
    }
    return timestamp;
}
exports.edmDateTimeToMoment = edmDateTimeToMoment;
/**
 * @hidden
 * This function can be used for both Edm.DateTime and and Edm.DateTimeOffset.
 */
function momentToEdmDateTime(momentInstance) {
    var timestamp = momentInstance.unix() * 1000;
    // For some reason isUtc() returns wrong values here, so we use the internal flag directly
    if (momentInstance['_isUTC']) {
        var offset = Math.abs(momentInstance.utcOffset());
        var operator = momentInstance.utcOffset() >= 0 ? '+' : '-';
        return "/Date(" + timestamp + operator + leftpad(offset, 4) + ")/";
    }
    return "/Date(" + timestamp + ")/";
}
exports.momentToEdmDateTime = momentToEdmDateTime;
/**
 * @hidden
 */
function parseNumber(value) {
    if (typeof value === 'number') {
        return value;
    }
    if (value.toLowerCase() === 'inf') {
        return Number.POSITIVE_INFINITY;
    }
    if (value.toLowerCase() === '-inf') {
        return Number.NEGATIVE_INFINITY;
    }
    if (value.toLowerCase() === 'nan') {
        return Number.NaN;
    }
    var num = Number(value);
    if (Number.isNaN(num)) {
        throw new Error("Cannot create number from input \"" + value + "\"");
    }
    return num;
}
exports.parseNumber = parseNumber;
function leftpad(value, targetLength) {
    var str = value.toString();
    if (str.length >= targetLength) {
        return str;
    }
    else {
        return '0'.repeat(targetLength - str.length) + str;
    }
}
var deserializers = {
    'Edm.Binary': rambda_1.identity,
    'Edm.Boolean': rambda_1.identity,
    'Edm.Byte': toNumber,
    'Edm.DateTime': edmDateTimeToMoment,
    'Edm.DateTimeOffset': edmDateTimeToMoment,
    'Edm.Decimal': toBigNumber,
    'Edm.Double': parseNumber,
    'Edm.Float': parseNumber,
    'Edm.Guid': toGuid,
    'Edm.Int16': toNumber,
    'Edm.Int32': toNumber,
    'Edm.Int64': toBigNumber,
    'Edm.SByte': toNumber,
    'Edm.Single': parseNumber,
    'Edm.String': rambda_1.identity,
    'Edm.Time': toTime
};
var serializers = {
    'Edm.Binary': rambda_1.identity,
    'Edm.Boolean': rambda_1.identity,
    'Edm.Byte': toNumber,
    'Edm.DateTime': momentToEdmDateTime,
    'Edm.DateTimeOffset': momentToEdmDateTime,
    'Edm.Decimal': fromBigNumber,
    'Edm.Double': parseNumber,
    'Edm.Float': parseNumber,
    'Edm.Guid': rambda_1.identity,
    'Edm.Int16': toNumber,
    'Edm.Int32': toNumber,
    'Edm.Int64': toBigNumber,
    'Edm.SByte': toNumber,
    'Edm.Single': parseNumber,
    'Edm.String': rambda_1.identity,
    'Edm.Time': fromTime
};
//# sourceMappingURL=payload-value-converter.js.map