"use strict";
var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
Object.defineProperty(exports, "__esModule", { value: true });
/* Copyright (c) 2020 SAP SE or an SAP affiliate company. All rights reserved. */
var HttpProxyAgent = require("http-proxy-agent");
var HttpsProxyAgent = require("https-proxy-agent");
var util_1 = require("@sap-cloud-sdk/util");
var rambda_1 = require("rambda");
var request_builder_1 = require("../request-builder");
var logger = util_1.createLogger({
    package: 'core',
    messageContext: 'proxy-util'
});
/**
 * Determines the proxy strategy. If noProxy is set the ProxyConfiguration in the destination is omitted.
 * For onPremProxy or internetProxy the connectivy service or enviroment varialbes are checked to fill the [[ProxyConfiguration]].
 * @param destination - from which the proxy strategy is derived.
 * @returns ProxyStrategy possible values are noProxy, internetProxy or onPremProxy.
 */
function proxyStrategy(destination) {
    if (destination.proxyType === 'OnPremise') {
        logger.info('OnPrem destination proxy settings from connectivity service will be used.');
        return ProxyStrategy.ON_PREMISE_PROXY;
    }
    var destinationProtocol = request_builder_1.getProtocolOrDefault(destination);
    if (!getProxyEnvValue(destinationProtocol)) {
        logger.info("No Proxy settings for " + destinationProtocol + " are found in environment variables - no proxy used");
        return ProxyStrategy.NO_PROXY;
    }
    if (getNoProxyEnvValue().includes(destination.url)) {
        logger.info("Destination URL " + destination.url + " is in no_proxy list: " + getNoProxyEnvValue() + " - no proxy used");
        return ProxyStrategy.NO_PROXY;
    }
    if (getProxyEnvValue(destinationProtocol)) {
        logger.info("Proxy settings for " + destinationProtocol + " are found in environment variables.");
        return ProxyStrategy.INTERNET_PROXY;
    }
    return ProxyStrategy.NO_PROXY;
}
exports.proxyStrategy = proxyStrategy;
function getProxyEnvValue(protocol) {
    var proxyEnvKey = protocol + '_proxy';
    var proxyEnvValue = process.env[proxyEnvKey.toLowerCase()] || process.env[proxyEnvKey.toUpperCase()];
    logger.info("Try to fetch " + proxyEnvKey.toLowerCase() + " or " + proxyEnvKey.toUpperCase() + " from the process env. Found value is " + proxyEnvValue);
    if (!proxyEnvValue) {
        return undefined;
    }
    return proxyEnvValue;
}
function getNoProxyEnvValue() {
    var noProxyEnv = process.env.no_proxy || process.env.NO_PROXY;
    if (!noProxyEnv) {
        return [];
    }
    var split = noProxyEnv.split(',').map(function (s) { return s.trim(); });
    if (split.find(function (s) { return s.includes('*'); })) {
        logger.warn("The no_proxy env contains a wildcard " + noProxyEnv + ", which is currently not supported");
    }
    return split;
}
var addProtocol = function (groups) { return function (proxyConfiguration) {
    if (!proxyConfiguration) {
        return;
    }
    var copy = __assign({}, proxyConfiguration);
    if (!groups.protocol) {
        copy.protocol = request_builder_1.Protocol.HTTP;
        logger.info('Protocol not specified in proxy environment value. Http used as fallback.');
        return copy;
    }
    copy.protocol = request_builder_1.Protocol.of(groups.protocol);
    if (!copy.protocol) {
        logger.warn("Unsupported protocol requested in environment variable: " + groups.protocol + ". Supported values are http and https - no proxy used.");
        return undefined;
    }
    if (copy.protocol === request_builder_1.Protocol.HTTPS) {
        logger.info("You are using https to connect to a proxy\" " + proxyConfiguration + " - this is unusual but possible.");
    }
    return copy;
}; };
var addPort = function (groups) { return function (proxyConfiguration) {
    if (!proxyConfiguration) {
        return;
    }
    var copy = __assign({}, proxyConfiguration);
    if (groups.port) {
        if (groups.port.match(/[\D]/)) {
            logger.warn('Given port in proxy env variable is not an integer - no proxy used.');
            return undefined;
        }
        copy.port = parseInt(groups.port);
        return copy;
    }
    var fallBackPort = proxyConfiguration.protocol === request_builder_1.Protocol.HTTPS ? 443 : 80;
    copy.port = fallBackPort;
    logger.info("Port not specified in proxy environment value. " + fallBackPort + " used as fallback.");
    return copy;
}; };
var addAuthHeaders = function (groups) { return function (proxyConfiguration) {
    if (!proxyConfiguration) {
        return;
    }
    var copy = __assign({}, proxyConfiguration);
    if (!groups.user || !groups.pwd) {
        logger.debug('No user and password given in proxy environment value. Nothing added to header.');
        return copy;
    }
    if (groups.user.match(/[^\w%]/) || groups.pwd.match(/[^\w%]/)) {
        logger.warn('Username:Password in proxy environment variable contains special characters like [@/:]. Use percent-encoding to mask them - no Proxy used');
        return undefined;
    }
    var userDecoded = decodeURIComponent(groups.user);
    var pwdDecoded = decodeURIComponent(groups.pwd);
    copy.headers = { 'Proxy-Authorization': request_builder_1.basicHeader(userDecoded, pwdDecoded) };
    logger.info('Username and password added to authorization of the proxy configuration.');
    return copy;
}; };
var addHost = function (groups) { return function (proxyConfiguration) {
    if (groups.host) {
        proxyConfiguration.host = groups.host;
        return proxyConfiguration;
    }
    logger.warn('Could not extract host from proxy env. - no proxy used');
    return;
}; };
/**
 * Parses the environment variable for the web proxy and extracts the values considering defaults like http for the protocol and 80 or 443 for the port.
 * The general pattern to be parsed is protocol://user:password@host:port, where everything besides the host is optional.
 * Special characters in the user and password need to be percent encoded.
 * @param proxyEnvValue - Environment variable which is parsed
 * @returns Configuration with default values or undefined if the parsing failed.
 */
function parseProxyEnv(proxyEnvValue) {
    var _a;
    var regex = /(?<protocolWithDelimiter>(?<protocol>^.+)\:\/\/)?(?<userPwdWithDelimeter>(?<user>.+)\:(?<pwd>.+)\@)?(?<hostAndPort>(?<host>[\w.]+):?(?<port>.+)?)/;
    var parsed = regex.exec(proxyEnvValue);
    if ((_a = parsed) === null || _a === void 0 ? void 0 : _a.groups) {
        var groups = parsed.groups;
        logger.debug("Start to extract protocol, host and port from proxy env: " + proxyEnvValue);
        var proxyConfiguration = rambda_1.pipe(addHost(groups), addProtocol(groups), addPort(groups), addAuthHeaders(groups))({});
        if (proxyConfiguration) {
            logger.debug("Used Proxy Configuration:\n     host:" + proxyConfiguration.host + "\n     protocol:" + proxyConfiguration.protocol + "\n     port:" + proxyConfiguration.port + "\n     headers: " + (proxyConfiguration.headers ? 'Authorization header present - Not logged for security reasons.' : 'No header present.') + ".");
        }
        return proxyConfiguration;
    }
    logger.warn("Unable to extract proxy config from " + proxyEnvValue + ".");
}
exports.parseProxyEnv = parseProxyEnv;
/**
 * Adds the proxy configuration to a destination based on web proxies defined in environment variables. See [[ProxyConfiguration]] and [[proxyStrategy]] for details.
 * @param destination - to which the proxy configuration is added.
 * @returns Destination containing the configuration for web proxy.
 */
function addProxyConfigurationInternet(destination) {
    var proxyEnvValue = getProxyEnvValue(request_builder_1.getProtocolOrDefault(destination));
    if (proxyEnvValue) {
        var proxyConfiguration = parseProxyEnv(proxyEnvValue);
        if (proxyConfiguration) {
            return __assign(__assign({}, destination), { proxyConfiguration: proxyConfiguration });
        }
        return __assign({}, destination);
    }
    logger.warn('Attempt to get proxy config from environment variables failed. At this point this should not happen - no proxy used.');
    return __assign({}, destination);
}
exports.addProxyConfigurationInternet = addProxyConfigurationInternet;
/**
 * Builds the http(s)-agent config. Note that the proxy agent type like http or https is determined by the destination RUL protocol.
 * The protocol from the proxy is unrelated to this and in most cases http.
 *
 * @param destination - Destination containing the proxy configurations
 * @returns The http(s)-agent containing the proxy configuration
 */
function proxyAgent(destination) {
    var targetProtocol = request_builder_1.getProtocolOrDefault(destination);
    var proxyConfig = destination.proxyConfiguration;
    if (!proxyConfig) {
        throw new Error('Proxy config must not be undefined.');
    }
    switch (targetProtocol) {
        case request_builder_1.Protocol.HTTP:
            return { httpAgent: new HttpProxyAgent(proxyConfig.protocol + "://" + proxyConfig.host + ":" + proxyConfig.port) };
        case request_builder_1.Protocol.HTTPS:
            return { httpsAgent: new HttpsProxyAgent(proxyConfig.protocol + "://" + proxyConfig.host + ":" + proxyConfig.port) };
    }
}
exports.proxyAgent = proxyAgent;
/**
 * Enum representing the different strategies for proxying request. Possible situations are "NO_PROXY", use the connectivity service proxy for On-Premise connection or a usual web proxy.
 * See also [[ProxyConfiguration]] for more details.
 */
var ProxyStrategy;
(function (ProxyStrategy) {
    ProxyStrategy[ProxyStrategy["NO_PROXY"] = 0] = "NO_PROXY";
    ProxyStrategy[ProxyStrategy["ON_PREMISE_PROXY"] = 1] = "ON_PREMISE_PROXY";
    ProxyStrategy[ProxyStrategy["INTERNET_PROXY"] = 2] = "INTERNET_PROXY";
})(ProxyStrategy = exports.ProxyStrategy || (exports.ProxyStrategy = {}));
//# sourceMappingURL=proxy-util.js.map