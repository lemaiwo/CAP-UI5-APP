#!/usr/bin/env node

// command line interface to the cds api resp. cds compiler
// Usage: cdsc [options] <file> ...
// Call cdsc --help for a detailed description
// Exit codes are:
//   0   for success
//   1   compilation error
//   2   command line usage error

// For recursive *.cds expansion, use
//   cdsc $(find . -name '*.cds' -type f)

'use strict';

/* eslint no-console:off */

const compiler = require('../lib/main');
const { compactModel } = require('../lib/json/to-csn');
const { toOdataWithCsn, toHanaWithCsn, toSqlWithCsn } = require('../lib/backends');
var util = require('util');
var fs = require('fs');
var path = require('path');
var reveal = require('../lib/model/revealInternalProperties');
const enrichCsn = require('../lib/model/enrichCsn');
const { optionProcessor } = require('../lib/optionProcessor');
const { translatePathLocations } = require('../lib/base/messages')
const { translateAssocsToJoins } = require('../lib/transform/translateAssocsToJoins');
const term = require('../lib/utils/term');

// Note: Instead of throwing ProcessExitError, we would rather just call process.exit(exitCode),
// but that might truncate the output of stdout and stderr, both of which are async (or rather,
// may possibly be async, depending on OS and whether I/O goes to TTY, socket, file, ... sigh)
class ProcessExitError extends Error {
  constructor(exitCode,...args) {
    super(...args);
    this.exitCode = exitCode;
  }
}

// Parse the command line and translate it into options
try {
  let cmdLine = optionProcessor.processCmdLine(process.argv);
  // Deal with '--version' explicitly
  if (cmdLine.options.version) {
    process.stdout.write(compiler.version() + '\n');
    throw new ProcessExitError(0);
  }
  // Deal with '--help' explicitly
  if (cmdLine.command) {
    // Command specific help
    if (cmdLine.options.help || cmdLine.options[cmdLine.command] && cmdLine.options[cmdLine.command].help) {
      displayUsage(null, optionProcessor.commands[cmdLine.command].helpText, 0);
    }
  } else if (cmdLine.options.help) {
    // General help
    displayUsage(null, optionProcessor.helpText, 0);
  }

  if (cmdLine.unknownOptions.length > 0) {
    // Print an INFO message about unknown options but
    // continue with defaults and do not abort execution.
    cmdLine.unknownOptions.forEach(msg => process.stderr.write(`cdsc: INFO: ${msg}\n`));
  }

  // Report complaints if any
  if (cmdLine.cmdErrors.length > 0) {
    // Command specific errors
    displayUsage(cmdLine.cmdErrors, optionProcessor.commands[cmdLine.command].helpText, 2);
  } else if (cmdLine.errors.length > 0) {
    // General errors
    displayUsage(cmdLine.errors, optionProcessor.helpText, 2);
  }

  // Default warning level is 2 (info)
  // FIXME: Is that not set anywhere in the API?
  if (!cmdLine.options.warning) {
    cmdLine.options.warning = 2;
  }
  // Default output goes to stdout
  if (!cmdLine.options.out) {
    cmdLine.options.out = '-';
  }
  // Default color mode is 'auto'
  term.useColor(cmdLine.options.color || 'auto');

  // Internally, parseCdl is an option so we map the command to it.
  if (cmdLine.command === 'parseCdl') {
    cmdLine.command = 'toCsn';
    cmdLine.options.parseCdl = true;
    if (cmdLine.args.files.length > 1) {
      const err = `'parseCdl' expects exactly one file! ${cmdLine.args.files.length} provided.`;
      displayUsage(err, optionProcessor.commands['parseCdl'].helpText, 2);
    }
  }

  if (cmdLine.options.beta) {
    const features = cmdLine.options.beta.split(',');
    cmdLine.options.beta = {};
    features.forEach((val) => cmdLine.options.beta[val] = true);
  }

  // Do the work for the selected command (default 'toCsn')
  executeCommandLine(cmdLine.command || 'toCsn', cmdLine.options, cmdLine.args);
} catch (err) {
  // This whole try/catch is only here because process.exit does not work in combination with
  // stdout/err - see comment at ProcessExitError
  if (err instanceof ProcessExitError) {
    process.exitCode = err.exitCode;
  } else {
    throw err;
  }
}

// Display help text 'helpText' and 'error' (if any), then exit with exit code <code>
function displayUsage(error, helpText, code) {
  // Display non-error output (like help) to stdout
  let out = (code == 0 && !error) ? process.stdout : process.stderr;
  // Display help text first, error at the end (more readable, no scrolling)
  out.write(`${helpText}\n`);
  if (error) {
    if (error instanceof Array) {
      out.write(error.map(error => `cdsc: ERROR: ${error}`).join('\n') + '\n');
    } else {
      out.write(`cdsc: ERROR: ${error}\n`);
    }
  }
  throw new ProcessExitError(code);
}

// Executes a command line that has been translated to 'command' (what to do), 'options' (how) and 'args' (which files)
function executeCommandLine(command, options, args) {
  const normalizeFilename = options.testMode && process.platform === 'win32';
  const messageLevels = { Error: 0, Warning: 1, Info: 2, None: 3 };
  // All messages are put into the message array, even those which should not
  // been displayed (severity 'None')

  // Create output directory if necessary
  if (options.out && options.out !== '-' && !fs.existsSync(options.out)) {
    fs.mkdirSync(options.out);
  }

  // Add implementation functions corresponding to commands here
  const commands = {
    toCdl,
    toCsn,
    toHana,
    toOdata,
    toRename,
    toSql,
    toSwagger,
  }

  if (!commands[command]) {
    throw new Error(`Missing implementation for command ${command}`);
  }

  const fileCache = Object.create(null)
  compiler.compile( args.files, undefined, options, fileCache )
        .then( commands[command] )
        .then( displayMessages, displayErrors )
        .catch( catchErrors );

  // Execute the command line option '--to-cdl' and display the results.
  // Return the original model (for chaining)
  function toCdl( model ) {
    let cdlResult = compiler.toCdl(model);
    for (let name in cdlResult) {
      writeToFileOrDisplay(options.out, name + '.cds', cdlResult[name]);
    }
    return model;
  }

  // Execute the command line option '--to-csn' and display the results.
  // Return the original model (for chaining)
  function toCsn( model ) {
    // Result already provided by caller
    displayNamedXsn(model, 'csn', options);
    return model;
  }

  // Execute the command line option '--to-hana' and display the results.
  // Return the original model (for chaining)
  function toHana( model ) {
    let hanaResult;
    if(options.oldTransformers) {
      hanaResult = compiler.toHana(model);
    } else {
      let csn = compactModel(model, options);
      csn.messages = model.messages; // pass messages as compactModel misses that
      hanaResult = toHanaWithCsn(csn, options)
    }
    for (let name in hanaResult.hdbcds) {
      writeToFileOrDisplay(options.out, name + '.hdbcds', hanaResult.hdbcds[name]);
    }
    displayNamedXsnOrCsn(hanaResult._augmentedCsn, hanaResult.csn, 'hana_csn', options);
    return model;
  }

  // Execute the command line option '--to-odata' and display the results.
  // Return the original model (for chaining)
  function toOdata( model ) {
    let odataResult;
    if(options.oldTransformers) {
      odataResult = compiler.toOdata(model)
    } else {
      let csn = compactModel(model, options);
      csn.messages = model.messages; // pass messages as compactModel misses that
      odataResult = toOdataWithCsn(csn, options);
    }
    translatePathLocations(model.messages, model);
    for (let serviceName in odataResult.services) {
      // <service>_metadata.xml (metadata)
      if (odataResult.services[serviceName].metadata) {
        writeToFileOrDisplay(options.out, serviceName + '_metadata.xml', odataResult.services[serviceName].metadata);
      }
      // <service>_annotations.xml (annotations)
      if (odataResult.services[serviceName].annotations) {
        writeToFileOrDisplay(options.out, serviceName + '_annotations.xml', odataResult.services[serviceName].annotations);
      }
      // <service>.xml (combined)
      if (odataResult.services[serviceName].combined) {
        writeToFileOrDisplay(options.out, serviceName + '.xml', odataResult.services[serviceName].combined);
      }
      // <service>.json (metadata_json)
      if (odataResult.services[serviceName].metadata_json) {
        writeToFileOrDisplay(options.out, serviceName + '.json', odataResult.services[serviceName].metadata_json);
      }
    }
    displayNamedXsnOrCsn(odataResult._augmentedCsn, odataResult.csn, 'odata_csn', options);
    return model;
  }

  // Execute the command line option '--to-rename' and display the results.
  // Return the original model (for chaining)
  //
  /// THIS MUST SURVIVE IF WE REMOVE THE OLD API
  /// DO NOT DELETE THIS TORENAME FUNCTIONALITY!!
  function toRename( model ) {
    let renameResult = compiler.toRename(model);
    let storedProcedure = 'PROCEDURE RENAME_' + model.options.toRename.names.toUpperCase() + '_TO_PLAIN LANGUAGE SQLSCRIPT AS BEGIN\n';
    for (let name in renameResult.rename) {
      storedProcedure += '  --\n  -- ' + name + '\n  --\n';
      storedProcedure += renameResult.rename[name];
    }
    storedProcedure += "END;\n";
    writeToFileOrDisplay(options.out, 'storedProcedure_' + model.options.toRename.names + '_to_plain.sql', storedProcedure, true);
    return model;
  }

  // Execute the command line option '--to-sql' and display the results.
  // Return the original model (for chaining)
  function toSql( model ) {
    let sqlResult = options.oldTransformers ? compiler.toSql(model) : toSqlWithCsn(compactModel(model, options), options);

    ['hdbtabletype', 'hdbtable', 'hdbindex', 'hdbfulltextindex', 'hdbview', 'sql'].forEach(pluginName => {
      for(let name in sqlResult[pluginName]) {
        writeToFileOrDisplay(options.out, name + '.' + pluginName, sqlResult[pluginName][name] + '\n', true);
      }
    });
    displayNamedXsnOrCsn(sqlResult._augmentedCsn, sqlResult.csn, 'sql_csn', options);
    model.messages = sqlResult.messages;
    return model;
  }

  // Execute the command line option '--to-swagger' and display the results.
  // Return the original model (for chaining)
  function toSwagger( model ) {
    let swaggerResult = compiler.toSwagger(model);
    for (let serviceName in swaggerResult.services || {}) {
      writeToFileOrDisplay(options.out, `${serviceName}_swagger.json`, swaggerResult.services[serviceName], false);
    }
    if (swaggerResult._augmentedCsn) {
      displayNamedXsn(swaggerResult._augmentedCsn, 'swagger_csn', options);
    }
    return model;
  }

  // Display error messages in `err` resulting from a compilation.  Also set
  // process.exitCode - process.exit() will force the process to exit as quickly
  // as possible = is problematic, since console.error() might be asynchronous
  function displayErrors (err) {
    if (err instanceof compiler.CompilationError) {
      if (options.rawOutput)
        console.error( util.inspect( reveal( err.model, options.rawOutput ), false, null ));
      else
        displayMessages( err.model, err.errors );
      process.exitCode = 1;
    }
    else if (err instanceof compiler.InvocationError) {
      console.error( '' );
      for (let sub of err.errors)
        console.error( sub.message );
      console.error( '' );
      process.exitCode = 2;
    }
    else
      throw err;

    err.hasBeenReported = true;
    throw err;
  }

  function displayMessages( model, messages = model.messages ) {
    if (messages instanceof Array)
    {
      for (let msg of messages) {
        if (options.internalMsg) {
          console.error( util.inspect( msg, { depth: null, maxArrayLength: null} ) );
        } else if (messageLevels[ msg.severity ] <= options.warning) {
          if (options.noMessageContext) {
            console.error(compiler.messageString(msg, normalizeFilename, !options.showMessageId));

          } else {
            console.error(compiler.messageStringMultiline(msg, normalizeFilename, !options.showMessageId));
            const fullfilepath = (msg.location && msg.location.filename )? path.resolve('', msg.location.filename) : undefined;
            const sourceLines = fileCache[fullfilepath] ? fileCache[fullfilepath].split('\n') : fileCache;
            console.error(compiler.messageContext(sourceLines, msg));
          }
        }
      }
    }
    return model;
  }

  function displayNamedXsnOrCsn(xsn, csn, name, options) {
    if(xsn && options.rawOutput) {
      displayNamedXsn(xsn, name, options);
    } else if (csn) {
      displayNamedCsn(csn, name, options);
    }
  }

  // Write the model 'model' to file '<name>.{json|raw.txt}' in directory 'options.out',
  // or display it to stdout if 'options.out' is '-'.
  // Depending on 'options.rawOutput', the model is either compacted to 'name.json' or
  // written in raw form to '<name>_raw.txt'.
  function displayNamedXsn(xsn, name, options) {
    if (options.rawOutput) {
      if(options.toCsn && options.toCsn.associations === "joins"){
        options.forHana = {};
        options.forHana.associations = options.toCsn.associations;
        writeToFileOrDisplay(options.out, name + '_raw.txt', util.inspect(reveal(translateAssocsToJoins(xsn), options.rawOutput), false, null), true);
      } else {
        writeToFileOrDisplay(options.out, name + '_raw.txt', util.inspect(reveal(xsn, options.rawOutput), false, null), true);
      }
    }
    else if (options.internalMsg) {
      writeToFileOrDisplay(options.out, name + '_raw.txt', util.inspect(reveal(xsn).messages, { depth: null, maxArrayLength: null}), true);
    }
    else if (!options.lintMode) {
      let csn = compiler.toCsn(xsn, options);
      if (options.enrichCsn)
        enrichCsn( csn, options );
      writeToFileOrDisplay(options.out, name + '.json', csn, true);
    }
  }

  function displayNamedCsn(csn, name, options) {
    if (options.internalMsg) {
      writeToFileOrDisplay(options.out, name + '_raw.txt', csn.messages, true);
    }
    else if (!options.lintMode && !options.internalMsg) {
      writeToFileOrDisplay(options.out, name + '.json', csn, true);
    }
  }

  // Write the result 'content' to a file 'filename' in directory 'dir', except if 'dir' is '-'.
  // In that case, display 'content' to stdout.
  // If 'content' is not a string, JSON-stringify it
  // If displaying to stdout, prepend a headline containing 'filename', unless 'omitHeadline' is set.
  // For filenames, illegal characters (slash, backslash, colon) are replaced by '_'.
  function writeToFileOrDisplay(dir, filename, content, omitHeadline = false) {
    if (options.lintMode && !options.rawOutput || options.internalMsg)
      return;
    filename = filename.replace(/[:/\\]/g, '_');
    if (!(content instanceof String || typeof content === 'string')) {
      content = JSON.stringify(content, null, 2);
    }
    if (dir === '-') {
      if (!omitHeadline) {
        process.stdout.write(`// ------------------- ${filename} -------------------\n`);
      }
      process.stdout.write(`${content}\n`);
      if (!omitHeadline) {
        process.stdout.write(`\n`);
      }
    } else {
      // TODO: We might consider using async file-system API ...
      fs.writeFileSync(path.join(dir, filename), content);
    }
  }

  function catchErrors (err) {
    if (err instanceof Error && err['hasBeenReported'])
      return;
    console.error( '' );
    console.error( 'INTERNAL ERROR: %s', err );
    console.error( util.inspect(err, false, null) );
    console.error( '' );
    process.exitCode = 70;
  }
}
