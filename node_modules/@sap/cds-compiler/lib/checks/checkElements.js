'use strict';

const has = Object.prototype.hasOwnProperty;
const alerts = require('../base/alerts');
const { checkArtifactHasProperType } = require('./checkArtifacts');
const { isComposition } = require('../model/modelUtils.js')

/**
 * Run primary key checks on the given element, for example type checks.
 */
function checkPrimaryKey(elem, model) {
  const { error, warning, signal } = alerts(model);
  let type = '';
  // apparently this is the resolved type (over an derived type chain)
  if(elem._finalType && elem._finalType.type && elem._finalType.type._artifact)
    type = elem._finalType.type._artifact.name.absolute;

  /**
   * Check that a primary key element is not an unmanaged association or contains unmanaged associations
   *
   * @param {any} element Element to check recursively
   */
  function checkForUnmanagedAssociations(element){
    if(element.on){
      signal(warning`Unmanaged associations cannot be used as primary key`, elem.key.location);
    }

      // Recursively check sub-elements for structured types
    if(element.elements){
      for(let elemName of Object.keys(element.elements)){
        const subElement = element.elements[elemName];
        checkForUnmanagedAssociations(subElement);
      }
    }
  }

  /**
   * Check that a primary key element is not array-like or contains array-like elements
   *
   * @param {any} element Element to check recursively
   */
  function checkKeyArrayLike(element){
    if(element.items){
      signal(error`Array-like types cannot be used as primary key`, element.location);
    }

    // Recursively check sub-elements for structured types
    if(element.elements){
      for(let elemName of Object.keys(element.elements)){
        const subElement = element.elements[elemName];
        checkKeyArrayLike(subElement);
      }
    }
  }

  function checkLocalizedSubElement(element) {
    if (!element.localized || element.localized.val !== true)
      return;

    if (element._parent && element._parent.kind === 'element') {
      signal('Keyword "localized" is ignored for sub elements', element.localized.location, 'Warning', 'localized-sub-element');
    }
  }

  if(elem.key && elem.key.val === true){
    if(['cds.hana.ST_POINT', 'cds.hana.ST_GEOMETRY'].includes(type)){
      signal(error`Type ${type} cannot be used as primary key`, elem.location);
    }

    checkForUnmanagedAssociations(elem);
    checkKeyArrayLike(elem);
  }
  checkLocalizedSubElement(elem);
}

// Perform checks for element (or type) 'elem' concerning managed associations,
// only for managed assocs directly declared on 'elem', not those from derived
// types etc (checked there): If no explicit foreign keys are provided, there
// must be at least one implicit one (i.e. the target must have keys).
// Cardinality of a managed association should not be to-many, except for partial keys.
function checkManagedAssoc(elem, model) {
  const { error, warning, signal } = alerts(model);
  let target = elem.target;
  // Not a managed assoc at all, inferred elem or redirected => nothing to check
  if (!target || elem.on || elem.onCond || elem.$inferred || !elem.type || elem.type.$inferred || !['entity', 'view'].includes(target._artifact.kind) || target._artifact.abstract && target._artifact.abstract.val) {
    return;
  }
  // No foreign keys at all => error
  let foreignKeys = elem.foreignKeys;
  if (!foreignKeys) {
    signal(error`The target "${target._artifact.name.absolute}" of the managed association "${elem.name.id}" does not have keys.`, elem.location);
  }
  let targetMax = (elem.cardinality && elem.cardinality.targetMax && elem.cardinality.targetMax.val);
  if (targetMax === '*' || Number(targetMax) > 1) {
    if(doForeignKeysCoverTargetKeys(foreignKeys,target._artifact.elements)) {
      // FIXME: convenience function (reuse in forHana)?
      const isNoDb = elem._parent.abstract || ((elem._parent['@cds.persistence.skip'] && elem._parent['@cds.persistence.skip'].val !== null && elem._parent['@cds.persistence.skip'].val !== false)|| (elem._parent['@cds.persistence.exists'] && elem._parent['@cds.persistence.exists'].val !== null && elem._parent['@cds.persistence.exists'].val !== false));
      let assocType = isComposition(elem.type) ? 'composition' : 'association';
      signal(warning`The ${assocType} "${elem.name.id}" has cardinality "to many" but no ON-condition`, elem.location, undefined, isNoDb ? 'to-many-no-on-noDB' : 'to-many-no-on');
    }
  }
}

// checks if the foreign keys cover completely the target keys
function doForeignKeysCoverTargetKeys(foreignKeys,targetElements) {
  let keysOfTarget = collectKeys(targetElements)
  let flattenedFKs = [];
  // flatten foreign keys into flattenedFKs
  for(let name in foreignKeys) {
    let fk = foreignKeys[name];
    let fullKeyName = fk.targetElement.path.map(X => X.id).join('.')
    let hasChildren=false;
    keysOfTarget.forEach(K => {
      if(K.startsWith(fullKeyName+'.')) { // structured key found
        hasChildren=true;
        flattenedFKs.push(K);
      }
    })
    if(!hasChildren)
      flattenedFKs.push(fullKeyName);
  }
  // check keysOfTarget are included into flattenedFKs
  let allKeysCovered=true;
  keysOfTarget.forEach(K => {
    if(!flattenedFKs.includes(K))
      allKeysCovered=false;
  })
  return allKeysCovered;

  // function walks elements recursively and returns all keys, structured ones are joined with a dot
  function collectKeys(elements,parent=[],insideKey=false) {
    let keys=[]
    if(!elements) return keys;
    for(let elementName in elements) {
      let element = elements[elementName];
      let tkey = element.key;
      let isKey=false;
      if(tkey && tkey.val || insideKey) {
        if(!element.elements)
          keys.push(parent.concat(elementName).join('.'))
        isKey=true;
      }
      keys.push(...collectKeys(element.elements,parent.concat(elementName), isKey));
    }
    return keys;
  }
}

// Check element 'elem' for semantical errors involving virtual elements
function checkVirtualElement(elem, model) {
  const { error, signal } = alerts(model);
  // when the element itself is declared as virtual
  if (elem.virtual) {
    if (elem.key && elem.key.val) {
      signal(error`Element cannot be virtual and key.`, elem.location);
    }
    if (isStruct(elem)) {
      signal(error`Element cannot be virtual and structured.`, elem.location);
    }
    if (isAssoc(elem)) {
      signal(error`Element cannot be virtual and an association.`, elem.location);
    }
  }
  if(isAssoc(elem))
    checkAssociation(elem, model);
}

// Check that a structured element ist not casted to a different type
function checkStructureCasting(elem, model) {
  const { error, signal } = alerts(model);
  if (elem.type && !elem.type.$inferred) {
    if (elem._finalType && elem._finalType.elements)
      signal(error`Cannot cast to structured element.`, elem.location);

    else if (elem.value && elem.value._artifact && elem.value._artifact._finalType && elem.value._artifact._finalType.elements)
      signal(error`Structured element cannot be casted to a different type.`, elem.location);
  }
}

function checkAssociation(elem, model) {
  const { error, signal } = alerts(model);
  // when virtual element is part of association
  if (elem.foreignKeys) {
    for (let k in elem.foreignKeys) {
      let key = elem.foreignKeys[k].targetElement;
      if (key && key._artifact && key._artifact.virtual && key._artifact.virtual.val === true) {
        signal(error`Virtual elements cannot be used as a foreign key for a managed association.`, key.location);
      }
    }
  }
  if (elem.onCond && !elem.onCond.$inferred)
    checkAssociationCondition(elem, model, elem.onCond);
}

function checkAssociationCondition(elem, model, onCond) {
  if(onCond===undefined)
    return;
  if(Array.isArray(onCond)) // condition in brackets results an array
    onCond.forEach(Cond => checkAssociationCondition(elem, model, Cond))
  else
    checkAssociationConditionArgs(elem, model, onCond.args, onCond.op)
}

function checkAssociationConditionArgs(elem, model, args, op) {
  if(!args)
    return;
  args.forEach(Arg => checkAssociationOnCondArg(elem, model, Arg, op));
}

function checkAssociationOnCondArg(elem, model, arg, op) {
  if(Array.isArray(arg)) {
    arg.forEach(Arg => checkAssociationOnCondArg(elem, model, Arg, op))
    return;
  } else {
    checkAssociationConditionArgs(elem, model, arg.args, arg.op);
  }

  singleCheckUnmanagedAssocCondArgumentNoFollowUnmanagedAssoc(elem, model, arg, op);
}

function singleCheckUnmanagedAssocCondArgumentNoFollowUnmanagedAssoc(elem, model, arg, op) {
  if(!arg.path)
    return;
  let path0=arg.path[0]
  if(!path0)
    return;
  if(path0.id=='$self') { // $self (backlink) checks
    checkAssociationArgumentStartingWithSelf();
    return;
  }
  if(!path0._artifact) // not resolved
    return;
  let artifactName = path0._artifact.name;
  if(artifactName.absolute && artifactName.element) {
    let targetArtifact = model.definitions[artifactName.absolute];
    if (targetArtifact instanceof Array) {
      return;
    }
    let argTarget = targetArtifact.elements[artifactName.element];
    //the check is valid for unmanaged associations
    //TODO clarify if the full resolved path to the target field should consist of managed associations or just the first
    if(isUnmanagedAssociation(argTarget)) {
      var same = path0.id === elem.name.element;
      if(!same) {
        const { error, signal } = alerts(model);
        signal(error`Unmanaged association condition can not follow another unmanaged association.`, path0.location);
      }
    }
  }

  function checkAssociationArgumentStartingWithSelf() {
    if(op && op.val==='xpr') // no check for xpr
      return;
    if(op && op.val!=='=') {
      const { error, signal } = alerts(model);
      signal(error`Backlink association condition requires an operator equation`, op.location);
    }
  }

}

function isStruct(obj) {
  return has.call(obj, 'elements');
}

function isAssoc(obj) {         // also checks for Compositions
  if (!obj)
    return obj;
  let type = obj._finalType || obj;
  return !!type.target;
}

function isUnmanagedAssociation(obj) {
  return isAssoc(obj) && obj.onCond !== undefined;
}

// Check that required actual parameters on 'node.type' are set, that their values are in the correct range etc.
function checkTypeParameters(node, model) {
  const { error, signal } = alerts(model);

  if (node.type) {
    if (node.typeArguments) {
      signal(error`Too many parameters in type reference to '${node.type._artifact.name.absolute}'`,
        node.typeArguments[0].location);
    }
    let parameters = (node.type._artifact && node.type._artifact.parameters) || [];
    let type = node.type._artifact;
    let absolute = type && type.name && type.name.absolute;

    // does this type has actual type facets?
    let hasTypeFacets = !!parameters.reduce((a,p) => {
      a |= Number(node[p] !== undefined);
      return a;
    }, false);

    // Are all type factes provided?
    if(absolute !== 'cds.Decimal' || hasTypeFacets) {
      for (let name in parameters) {
        let param = parameters[name];
        if (!node[param] && !['cds.hana.ST_POINT', 'cds.hana.ST_GEOMETRY'].includes(absolute))
          signal(error`Actual value for type parameter '${param}' missing in reference to type '${absolute}'`,
            node.type.location );
      }
    }
    switch (absolute) {
      case 'cds.String':
      case 'cds.Binary':
      case 'cds.hana.VARCHAR': {
        checkTypeParamValue(node, 'length', 'positiveInteger', {min: 1, max: 5000});
        break;
      }
      case 'cds.Decimal': {
        if(hasTypeFacets) {
          checkTypeParamValue(node, 'precision', 'positiveInteger', {max: 38});
          checkTypeParamValue(node, 'scale', 'positiveInteger', {max: node.precision && node.precision.val});
        }
        break;
      }

      case 'cds.hana.BINARY':
      case 'cds.hana.NCHAR':
      case 'cds.hana.CHAR': {
        checkTypeParamValue(node, 'length', 'positiveInteger', {min: 1, max: 2000});
        break;
      }
      case 'cds.hana.ST_POINT':
      case 'cds.hana.ST_GEOMETRY': {
        checkTypeParamValue(node, 'srid', 'positiveInteger', {max: Number.MAX_SAFE_INTEGER});
        break;
      }
    }
  }

  // Check that the value of the type property `paramName` (e.g. length, precision, scale ...) is of `expectedType`
  // (which can currently only be 'positiveInteger') and (optional) the value is in a given range
  function checkTypeParamValue(node, paramName, expectedType, range = undefined) {
    let paramValue = node[paramName] && node[paramName].val;
    if (paramValue == undefined)
      return true;
    switch (expectedType) {
      case 'positiveInteger':
        if (!(Number.isInteger(paramValue) && paramValue >= 0)) {
          signal(error`Actual parameter '${paramName}' for '${node.type._artifact.name.absolute}' must be positive integer`,
            node[paramName].location);
          return false;
        }
        break;
      default:
        throw 'Unknown "expectedType"';
    }
    if (range) {
      if (range.max && paramValue > range.max) {
        signal(error`Actual parameter '${paramName}' for '${node.type._artifact.name.absolute}' is larger than allowed (max: ${range.max})`,
          node[paramName].location);
        return false;
      }
      if (range.min && paramValue < range.min) {
        signal(error`Actual parameter '${paramName}' for '${node.type._artifact.name.absolute}' is smaller than allowed (min: ${range.min})`,
          node[paramName].location);
        return false;
      }
    }
    return true;
  }
}

// Check that min and max cardinalities of 'elem' in 'art' have legal values
function checkCardinality(elem, model) {
  const { error, signal } = alerts(model);
  if (!elem.cardinality) {
    return;
  }

  // Max cardinalities must be a positive number or '*'
  for (let prop of ['sourceMax', 'targetMax']) {
    if (elem.cardinality[prop]) {
      if (!(elem.cardinality[prop].literal === 'number' && elem.cardinality[prop].val > 0
            || elem.cardinality[prop].literal === 'string' && elem.cardinality[prop].val === '*')) {
        signal(error`Element "${elem.name.absolute}.${elem.name.id}": Illegal value "${elem.cardinality[prop].val}" for max cardinality (must a positive number or "*")`, elem.cardinality[prop].location);
      }
    }
  }

  // Min cardinality must be a non-negative number (already checked by parser)
  if (elem.cardinality.targetMin) {
    if (!(elem.cardinality.targetMin.literal === 'number' && elem.cardinality.targetMin.val >= 0)) {
      signal(error`Element "${elem.name.absolute}.${elem.name.id}": Illegal value "${elem.cardinality.targetMin.val}" for min cardinality (must a non-negative number)`, elem.cardinality.targetMin.location);
    }
  }

  // If provided, min cardinality must not exceed max cardinality (note that '*' is considered to be >= any number)
  if (elem.cardinality.targetMin && elem.cardinality.targetMax && elem.cardinality.targetMax.literal === 'number'
      && elem.cardinality.targetMin.val > elem.cardinality.targetMax.val) {
    signal(error`Element "${elem.name.absolute}.${elem.name.id}": Target minimum cardinality must not be greater than target maximum cardinality`, elem.cardinality.location);
  }
}

function checkLocalizedElement (elem, model) {
  const { signal, warning } = alerts(model);
  // if it is directly a localized element
  if (elem.localized && elem.localized.val) {
    let type = elem._finalType; // could be the element typed with String(5)
    if (type && type.type)
      type = type.type._artifact;
    if (!type || type.name.absolute !== 'cds.String') {
      signal(warning`Element "${elem.name.absolute}.${elem.name.id}": "localized" may only be used in combination with type "String"`);
    }
  }
}

/**
 * If the given element is not computed, check whether its final type has
 * proper type information.  Useful for checking that `type of` does not refer
 * to a computed element.
 *
 * @param {XSN.Artifact} element
 * @param {XSN.Model} model
 */
function checkElementHasValidTypeOf(element, model) {
  // Computed elements, e.g. "1+1 as foo" in a view don't have a valid type and
  // are skipped here.  Their usage will still be warned about, though.
  // Elements in projections are not tested as well as they don't have the
  // origin's type information copied but reference them in _finalType.
  if (element['@Core.Computed'] || element.origin)
    return;

  checkArtifactHasProperType(element, model);
}

/**
 * Check that there are no .items containing .items.
 *
 * Type definitions and elements are checked - recursion is handled by the semanticChecks
 *
 * @param {object} obj element or type definition
 * @param {object} model the whole model
 */
function checkForItemsChain(obj, model){
  if(obj.items) {
    const itemsType = obj.items.type ? obj.items.type._artifact : obj.items;

    if(itemsType.items){
      const { signal, warning } = alerts(model);
      signal(warning`"Array of"/"many" must not be chained - ${obj.name.id}, ${itemsType.name.id}.`, obj.location, 'Warning', 'chained-array-of');
    }
  }
}

module.exports = {
  checkPrimaryKey,
  checkManagedAssoc,
  checkVirtualElement,
  checkTypeParameters,
  checkCardinality,
  checkLocalizedElement,
  checkStructureCasting,
  checkElementHasValidTypeOf,
  checkForItemsChain
};
