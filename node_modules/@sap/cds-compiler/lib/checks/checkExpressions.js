'use strict';

const alerts = require('../base/alerts');
const transformUtils = require('../transform/transformUtils');


/**
 * Check wether the supplied argument is a virtual element
 *
 * TO CLARIFY: do we want the "no virtual element" check for virtual elements/columns, too?
 *
 * @param {any} arg Argument to check (part of an expression)
 * @returns {Boolean}
 */
function isVirtualElement(arg) {
  return arg.path && arg._artifact.virtual && arg._artifact.virtual.val === true && arg._artifact.kind && arg._artifact.kind === 'element';
}

/**
 * Check a token-stream expression for semantic validity
 *
 * @param {any} xpr The expression to check
 * @param {any} model The model
 * @returns {void}
 */
function checkTokenStreamExpression(xpr, model){
  const { error, signal } = alerts(model);

  // Check for illegal argument usage within the expression
  for (let arg of xpr.args || []) {
    if(isVirtualElement(arg)){
      signal(error`Virtual elements cannot be used in an expression.`, arg.location);
    }

   // Recursively traverse the argument expression
    checkTokenStreamExpression(arg, model);
  }
}

/**
 * Check a tree-like expression for semantic validity
 *
 * @param {any} xpr The expression to check
 * @param {any} model The model
 * @returns {void}
 */
function checkTreeLikeExpression(xpr, model){
  const { error, signal } = alerts(model);
  const { isAssociationOperand, isDollarSelfOperand } = transformUtils.getTransformers(model);

  // No further checks regarding associations and $self required if this is a backlink-like expression
  // (a comparison of $self with an assoc)
  if (isBinaryDollarSelfComparisonWithAssoc(xpr)) {
    return;
  }
  // Check for illegal argument usage within the expression
  for (let arg of xpr.args || []) {
    if(isVirtualElement(arg)){
      signal(error`Virtual elements cannot be used in an expression.`, arg.location);
    }
   // Arg must not be an association and not $self
    if (isAssociationOperand(arg)) {
      signal(error`An association cannot be used as a value in an expression`, arg.location);
    }
    if (isDollarSelfOperand(arg)) {
      signal(error`"${arg.path[0].id}" can only be used as a value in a comparison to an association`, arg.location);
    }

   // Recursively traverse the argument expression
    checkTreeLikeExpression(arg, model);
  }

  /**
   * Return true if 'xpr' is backlink-like expression (a comparison of "$self" with an assoc)
   *
   * @param {any} xpr The expression to check
   * @returns {Boolean}
   */
  function isBinaryDollarSelfComparisonWithAssoc(xpr) {
    // Must be an expression with arguments
    if (!xpr.op || !xpr.args) {
      return false;
    }

    // One argument must be "$self" and the other an assoc
    if (xpr.op.val === '=' && xpr.args.length == 2) {
    // Tree-ish expression from the compiler (not augmented)
      return (isAssociationOperand(xpr.args[0]) && isDollarSelfOperand(xpr.args[1])
         || isAssociationOperand(xpr.args[1]) && isDollarSelfOperand(xpr.args[0]));
    }

    // Nothing else qualifies
    return false;
  }
}

/**
 * Check an expression (or condition) for semantic validity
 *
 * @param {any} xpr The expression to check
 * @param {any} model The model
 * @returns {void}
 */
function checkExpression(xpr, model) {
  // Since the checks for tree-like and token-stream expressions differ, check here what kind of expression we are looking at
  if (xpr.op && xpr.op.val === 'xpr') {
    return checkTokenStreamExpression(xpr, model);
  } else {
    return checkTreeLikeExpression(xpr, model);
  }
}

module.exports = {
  checkExpression,
}
