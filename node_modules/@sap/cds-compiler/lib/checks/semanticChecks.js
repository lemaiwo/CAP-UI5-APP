'use strict';

// Main entry for the CDS semantic checks

const baseModel = require('../base/model');
const alerts = require('../base/alerts');
const checkAnnotationAssignments = require('./checkAnnotationAssignments');
const getFunctionAndActionChecks = require('./checkFunctionsActions');
const keywords = require('../base/keywords');
const { checkNotEmptyOrOnlyVirtualElems, checkNoUnmanagedAssocsInGroupByOrderBy,
        checkTypeDefinitionHasType } = require('./checkArtifacts');
const { checkPrimaryKey, checkVirtualElement, checkManagedAssoc, checkCardinality,
        checkLocalizedElement, checkStructureCasting, checkForItemsChain, checkElementHasValidTypeOf } = require('./checkElements');
const { checkExpression } = require('./checkExpressions');
const { foreachPath } = require('../model/modelUtils');
const { getMessageFunction } = require('../base/messages');

// Note: For the organization of these checks, we distinguish the following terms:
// - a 'construct' is something that has a 'kind' (so this is the the most general term)
// - an 'artifact' is a construct that lives in 'model.definitions' (e.g. an entity or an unbound function)
// - a 'member' is a construct that lives in an artifact, possibly nested (e.g. an element, function or parameter)
// - a 'container' is an artifact that can contain other artifacts (e.g. a context or service)

// Generally, the main 'semanticCheck' function ensures that for each construct, the appropriate
// check functions are called according to 'kind', from generic to specific.
// For example, an entity is an artifact, which is a construct, so the following
// function would be called:
// - checkGenericConstruct(art)
// - checkGenericArtifact(art)
// - checkEntity(art)
// To keep things simple, the actual check functions are intended to be leafs in this call hierarchy,
// so please do not call specific check functions from generic ones, and do not iterate members within
// artifact check functions (or artifacts within containers) just in order to call sub-checks. It is
// of course OK to iterate content if that is part of the actual check itself.

// Perform semantic check on all artifacts within (augmented) model. Report errors to model.messages.
function semanticCheck(model) {
  const message = getMessageFunction(model);
  const { error, info, signal } = alerts(model);
  const { checkActionOrFunction, checkActionOrFunctionParameter, serviceNameFor} = getFunctionAndActionChecks(model);

  // Iterate the model and call generic/specific checkers on each construct
  // (please do not put any actual checks here)
  baseModel.forEachDefinition(model, artifact => {
    checkGenericConstruct(artifact);
    checkGenericArtifact(artifact);
    if (isContainer(artifact)) {
      checkGenericContainer(artifact);
    }

    callKindSpecificCheck(artifact);
    baseModel.forEachMemberRecursively(artifact, member => {
      checkGenericConstruct(member);
      checkGenericMember(member);
      callKindSpecificCheck(member);
    });
  });

  function isContainer(artifact) {
    return ['context', 'service', 'namespace', 'accesspolicy'].includes(artifact.kind);
  }

  // Call the appropriate kind-specific check function for 'construct'
  function callKindSpecificCheck(construct) {
    /**
     * For each kind, there must be a check function (so that we don't forget one)
     *
     * @type {Object.<string, (construct: object) => void>}
     */
    const checkFunctions = {
      accesspolicy: nothingToCheckYet,
      action: checkActionOrFunction,
      annotation: nothingToCheckYet,
      aspect: nothingToCheckYet,
      const: nothingToCheckYet,
      context: nothingToCheckYet,
      element: checkElement,
      entity: checkEntity,
      enum: checkEnum,
      event: nothingToCheckYet,
      function: checkActionOrFunction,
      key: nothingToCheckYet,
      namespace: nothingToCheckYet,
      package: nothingToCheckYet,
      param: checkParam,
      query: nothingToCheckYet,
      role: nothingToCheckYet,
      service: nothingToCheckYet,
      type: checkType,
      view: checkView,
    }
    let func = checkFunctions[construct.kind];
    if (!func) {
      throw Error('No check function defined for kind ' + construct.kind);
    }
    func(construct);
  }

  // ----------------------------------------------------------------------------------
  // Generic check functions. Please put only common checks here and do not iterate
  // or dispatch further (should be done above in semanticCheck)

  // Called for every 'construct', i.e for artifacts and members alike
  function checkGenericConstruct(construct) {
    if (construct.name.id && construct.name.id.indexOf('.') != -1) {
      signal(error`The character '.' is not allowed in an identifier: "${construct.name.id}"`, construct.name.location);
    }
    if (construct.name.id && keywords.cdl.includes(construct.name.id.toUpperCase())) {
      signal(info`Using reserved keyword "${construct.name.id}" as identifier is not recommended`, construct.name.location);
    }
    checkAnnotationAssignments(construct, model);
  }

  /**
   * Called for each main artifact (no need to iterate its members).
   * @param {CSN.Artifact} artifact
   */
  function checkGenericArtifact(artifact) {
    // user defined objects must not live in namespace cds,
    //   exception: they can live in cds.foundation
    // Only an INFO during compile time,
    // reclassified to errors in the backends
    checkNotEmptyOrOnlyVirtualElems(artifact, model);
  }

  // Called for each member (no need to iterate sub-members)
  // eslint-disable-next-line no-unused-vars
  function checkGenericMember(member) {
    // No checks yet
  }

  // Called for each container (no need to iterate contained artifacts)
  function checkGenericContainer(container) {
    if (container.kind === 'namespace' && container.name.absolute === 'localized') {
      baseModel.forEachGeneric(container, 'artifacts', checkLocalizedObjects);
    }

    function checkLocalizedObjects(artifact) {
      if (artifact.kind === 'namespace') {
        baseModel.forEachGeneric(artifact, 'artifacts', checkLocalizedObjects);
      } else if (!artifact.query) {
        signal(error`The namespace "localized" is reserved for localization views`, artifact.name.location);
      }
    }
  }

  // ----------------------------------------------------------------------------------
  // Specific check functions, normally one per kind (exceptions are OK where kinds are
  // too similar)

  function checkEntity(/*entity*/) {
    // no-op
  }

  function isAbstractEntity(entity) {
    return entity && entity.abstract && entity.abstract.val===true;
  }

  function checkView(view) {
    // TODO: check too simple (just one source), as most of those in this file
    if (source(view)) {
      let sourceEntity = source(view)._artifact;
      if(sourceEntity && isAbstractEntity(sourceEntity)) {
        signal(error`View ${view.name.absolute} on abstract entity ${sourceEntity.name.absolute}`, source(view).location);
      }
    }
    checkNoUnmanagedAssocsInGroupByOrderBy(view, model);
    // Check expressions in the various places where they may occur
    for (let query of view.$queries || []) {
      if (query.from) {
        checkExpressionsInPaths(query.from);
      }
      if (query.where) {
        checkExpression(query.where, model);
        checkExpressionsInPaths(query.where);
      }
      if (query.groupBy) {
        for (let groupByEntry of query.groupBy) {
          checkExpression(groupByEntry, model);
          checkExpressionsInPaths(groupByEntry);
        }
      }
      if (query.having) {
        checkExpression(query.having, model);
        checkExpressionsInPaths(query.having);
      }
      if (query.orderBy) {
        for (let orderByEntry of query.orderBy) {
          checkExpression(orderByEntry.value, model);
          checkExpressionsInPaths(orderByEntry.value);
        }
      }
      if(query.mixin){
        for (let mixinName in query.mixin) {
          if(query.mixin[mixinName].onCond){
            checkExpression(query.mixin[mixinName].onCond, model)
          }
        }
      }
      if (query.elements) {
        for (let elemName in query.elements) {
          checkStructureCasting(query.elements[elemName], model);
          checkExpressionsInPaths(query.elements[elemName].value);
        }
      }
    }
  }

  /**
   * Enum specific checks. For example this function checks that the value type
   * of enum values are allowed.
   *
   * @param {XSN.Artifact} enumNode
   */
  function checkEnum(enumNode) {
    if (!enumNode.value)
      return;

    const type = enumNode.value.literal;
    const loc = enumNode.value.location;

    // Special handling to print a more detailed error message
    if (type === 'enum') {
      message('enum-value-ref', loc, enumNode, { }, 'Warning',
        'References to other values are not allowed as enum values');
      return;
    }

    const allowedValueTypes = ['number', 'string'];
    if (!allowedValueTypes.includes(type)) {
      message('enum-value-type', loc, enumNode, { }, 'Warning',
        'Only strings or numbers are allowed as enum values');
    }
  }

  // Traverses 'node' recursively and applies 'checkExpression' to all expressions
  // found within paths (e.g. filters, parameters, ...)
  function checkExpressionsInPaths(node) {
    foreachPath(node, path => {
      for (const pathStep of path) {
        if (pathStep.where) {
          checkExpression(pathStep.where, model);
        }
        // FIXME: I can't actually think of a way to make this check fail, because
        // params are limited to actual values and params
        if (pathStep.namedArgs) {
          checkExpression(pathStep.namedArgs, model);
        }
        if (!path[0] || !path[0]._navigation) { // TODO: Discuss (see #4108)
          checkPathForMissingArguments(pathStep);
        }
      }
    });
  }

  /**
   * Check whether the argument count of the given path expression matches its artifact.
   * If there is a mismatch, an error is issued.
   *
   * @param {object} pathStep The expression to check
   */
  function checkPathForMissingArguments(pathStep) {
    // _artifact may not be set, e.g. for functions like `convert_currency( amount => 3 )`
    // _navigation must not be set or we would (for example) check each field of an entity
    if (!pathStep._artifact || pathStep._navigation)
      return;

    const isAssociation = !!pathStep._artifact.target
    if (isAssociation) {
      const targetFinalType = pathStep._artifact.target._artifact && pathStep._artifact.target._artifact._finalType;
      const finalTypeParams = targetFinalType ? targetFinalType.params : null;
      compareArgs(pathStep.namedArgs, pathStep.args, finalTypeParams);
    } else {
      // Parameters can only be provided when navigating along associations, so because this path
      // is for non-associations, checking arguments along a navigation is unnecessary and faulty.
      compareArgs(pathStep.namedArgs, pathStep.args, pathStep._artifact.params);
    }

    /**
     * Compare two argument dictionaries for correct argument count.
     * @param {object}   namedArgsGiven
     * @param {object[]} unnamedArgsGiven
     * @param {object}   argsExpected
     */
    function compareArgs(namedArgsGiven, unnamedArgsGiven, argsExpected) {
      namedArgsGiven = namedArgsGiven || {};
      unnamedArgsGiven = unnamedArgsGiven || [];
      argsExpected = argsExpected || {};

      const givenNames = Object.keys(namedArgsGiven);
      const expectedNames = Object.keys(argsExpected);

      if (unnamedArgsGiven.length) {
        if (unnamedArgsGiven.length != expectedNames.length) {
          message(undefined, pathStep.location, pathStep,
            { expected: expectedNames.length, given: givenNames.length },
            'Error',
            'Expected $(EXPECTED) arguments but $(GIVEN) given'
          );
        }
      } else {
        if (givenNames.length != expectedNames.length) {
          const missingArguments = expectedNames.filter((name) => !givenNames.includes(name));
          message(undefined, pathStep.location, pathStep,
            { names: missingArguments, expected: expectedNames.length, given: givenNames.length },
            'Error',
            'Expected $(EXPECTED) arguments but $(GIVEN) given; missing: $(NAMES)'
          );
        }
      }
    }
  }

  function checkType(type) {
    checkManagedAssoc(type, model);
    checkTypeDefinitionHasType(type, model);
    checkForItemsChain(type, model);
  }

  function checkElement(elem) {
    checkElementHasValidTypeOf(elem, model);
    checkPrimaryKey(elem, model);
    checkVirtualElement(elem, model);
    checkManagedAssoc(elem, model);
    checkCardinality(elem, model);
    checkForItemsChain(elem, model);
    if (elem.onCond && !elem.onCond.$inferred) {
      checkExpression(elem.onCond, model);
    }
    if (elem.value) {
      checkExpression(elem.value, model);
    }
    checkLocalizedElement(elem, model);
  }

  function checkParam(param) {
    if (param._parent && (param._parent.kind === 'action' || param._parent.kind === 'function')) {
      checkActionOrFunctionParameter(param, serviceNameFor(param._parent));
    }
  }

  // Dummy for things that we don't check yet
  function nothingToCheckYet() {
    // Intentionally empty
  }
}

// TODO: checks on one "source" are incomplete!
function source( view ) {
  let from = view.query && view.query.from;
  return from && from.length === 1 && from[0] && from[0].path && from[0];
}

module.exports = semanticCheck;
