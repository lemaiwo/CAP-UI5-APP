// Compiler phase "resolve": resolve all references

// The resolve phase tries to find the artifacs (and elements) for all
// references in the augmented CSN.  If there are unresolved references, this
// compiler phase fails with an error containing a vector of corresponding
// messages (alternatively, we could just store this vector in the CSN).

// References are resolved according to the scoping rules of CDS specification.
// That means, the first name of a reference path is not only searched in the
// current environments, but also in the parent environments, with the source
// as second-last, and the environment for builtins as the last search
// environment.

// For all type references, we set the property `type._artifact`, the latter is
// the actual type definition.

// If the referred type definition has a `parameters` property, we use it to
// transform the `typeArguments` property (sibling to the `type` property`) to
// named properties.  See function `resolveTypeExpr` below for details.

// Example 'file.cds' (see './definer.js' for the CSN before "resolve"):
//   type C { elem: String(4); }
//
// The corresponding definition of element "elem" looks as follows:
//   {
//     kind: 'element',
//     name: { id: 'elem', component: 'elem', location: ... }
//     type: { absolute: 'cds.String', _artifact: {...}, path: ...},
//     length: { val: 4, location: <of the number literal> },
//     location: ..., _parent: ...
//   }

'use strict';

const {
  isBetaEnabled,
  queryOps,
  setProp,
  forEachDefinition,
  forEachMember,
  forEachGeneric,
  forEachInOrder,
} = require('../base/model');
const {
  addToDict, addToDictWithIndexNo, clearDict,
} = require('../base/dictionaries');
const { dictLocation } = require('../base/location');
const {
  getMessageFunction, hasErrors, searchName, weakLocation,
} = require('../base/messages');
const {
  getDefinerFunctions,
  augmentPath,
  splitIntoPath,
  booleanAnnotation,
} = require('./definer');

const detectCycles = require('./cycle-detector');
const layers = require('./moduleLayers');

const {
  kindProperties, fns, setLink, linkToOrigin, setMemberParent, withAssociation, storeExtension,
} = require('./shared');

const annotationPriorities = {
  define: 1, extend: 2, annotate: 2, edmx: 3,
};


// Export function of this file.  Resolve type references in augmented CSN
// `model`.  If the model has a property argument `messages`, do not throw
// exception in case of an error, but push the corresponding error object to
// that property (should be a vector).
function resolve( model ) {
  const { options } = model;
  // Get shared "resolve" functionality and the message function:
  const { resolvePath, resolveTypeArguments, defineAnnotations } = fns( model, environment );
  const message = getMessageFunction( model );
  const {
    initArtifacts,
    lateExtensions,
    createLocalizedDataView,
    hasTruthyProp,
  } = getDefinerFunctions(model);
  /** @type {any} may also be a boolean */
  let newAutoExposed = [];
  return main();

  function main() {
    // Phase 1: check paths in usings:
    forEachGeneric( model, 'sources', resolveUsings );
    // Phase 2: calculate/init view elements & collect views in order:
    forEachDefinition( model, traverseElementEnvironments );
    while (newAutoExposed.length) {
      // console.log( newAutoExposed.map( a => a.name.absolute ) )
      const all = newAutoExposed;
      newAutoExposed = [];
      all.forEach( traverseElementEnvironments );
    }
    newAutoExposed = true;      // internal error if auto-expose after here
    // Phase 3: calculate keys along simple queries in collected views:
    model._entities.forEach( propagateKeyProps );
    // Phase 4: resolve all artifacts:
    forEachDefinition( model, resolveRefs );
    // Phase 5: rewrite associations, exclude associations:
    forEachDefinition( model, rewriteSimple );
    // TODO: sequence not good enough with derived type of structure with
    // includes: first "direct" structures, then _entities, then the rest
    model._entities.forEach( rewriteView );
    // Phase 6: apply ANNOTATE on autoexposed entities and unknown artifacts:
    lateExtensions( annotateMembers );
    if (model.extensions)
      model.extensions.map( annotateUnknown );
    // Phase 7: report cyclic dependencies:
    detectCycles( model.definitions, ( art, location, user ) => {
      if (location) {
        message( 'ref-cyclic', location, user, { art }, 'Error', {
          std: 'Illegal circular reference to $(ART)',
          element: 'Illegal circular reference to element $(MEMBER) of $(ART)',
        });
      }
    });
    // Phase 8: create convenience views
    if (!hasErrors( model.messages || options.messages ))
      createLocalizedTransitive();
    return model;
  }

  // Resolve the using declarations in `using`.  Issue
  // error message if the referenced artifact does not exist.
  function resolveUsings( src, topLevel ) {
    if (!src.usings)
      return;
    for (const def of src.usings) {
      if (def.usings)           // using {...}
        resolveUsings( def );
      if (!def.name || !def.name.absolute || def.$inferred === 'LOCALIZED-IGNORED')
        continue;               // using {...}, parse error, USING localized.XYZ
      const art = model.definitions[def.name.absolute];
      if (art instanceof Array)
        continue;
      let ref = def.extern;
      if (ref.dcPath) {
        const head = ref.path[0];
        if (!head)
          continue; // in case of parser errors
        const id = `${ ref.dcPath.map( item => item.id ).join('.') }::${ head.id }`;
        const location = {
          filename: head.location.filename,
          start: ref.location.start,
          end: head.location.end,
        };
        ref = { path: [ { id, location }, ...ref.path.slice(1) ], location: ref.location };
      }
      const from = (topLevel ? def : src).fileDep;
      if (art || !from || from.realname)   // no error for non-existing ref with non-existing module
        resolvePath( ref, 'global', def ); // TODO: consider FROM for validNames
    }
  }


  //--------------------------------------------------------------------------
  // The central functions for path resolution - must work on-demand
  //--------------------------------------------------------------------------
  // Phase 2: call populateView(), which also works on-demand

  // Return effective search environment provided by artifact `art`, i.e. the
  // `artifacts` or `elements` dictionary.  For the latter, follow the `type`
  // chain and resolve the association `target`.  View elements are calculated
  // on demand.
  function environment( art, location, user, assocSpec ) {
    if (!art)
      return Object.create(null);
    if (art.artifacts)
      return art.artifacts;
    let type = finalType(art) || art;
    if (type.target) {
      type = resolvePath( type.target, 'target', type );
      if (!type) {
        if (type === 0 && location) {
          dependsOn( art, art, (art.target || art.type).location );
          // console.log( message( null, location, art._deps[0].art, {}, 'Info','FT').toString(),
          //              art._deps && art._deps.length )
          return 0;
        }
        type = {};
      }
      // TODO: combine this with setTargetReferenceKey&Co in getPathItem?
      else if (assocSpec === false) { // TODO: else warning for assoc usage
        message( null, location, user, {}, 'Error',
                 'Following an association is not allowed in a association key definition' );
      }
      else if (assocSpec && user) {
        dependsOn( user, type, location );
      }
    }
    populateView( type );
    return type.elements || Object.create(null);
  }

  function dependsOn( user, art, location ) {
    if (!user._deps)
      setProp( user, '_deps', [] );
    user._deps.push( { art, location } );
  }

  // Follow the `type` chain, i.e. derived types and TYPE OF, stop just before
  // built-in types (otherwise, we would loose type parameters).  Return that
  // type and set it as property `_finalType` on all artifacts on the chain.
  // TODO: clarify for (query) elements without type: self, not undefined - also for entities!
  // TODO: directly "propagate" (with implicit redirection the targets), also
  // "proxy-copy" elements
  function finalType( art ) {
    if ('_finalType' in art)
      return art._finalType;

    // console.log(message( null, art.location, art, {}, 'Info','FT').toString())
    const chain = [];
    while (art && !('_finalType' in art) &&
           (art.type || art.origin || art.value && art.value.path) && // TODO: items
           !art.target && !art.enum) {
      chain.push( art );
      setProp( art, '_finalType', 0 ); // initial setting in case of cycles
      art = directType( art );
    }
    if (art) {
      if (art.builtin && chain.length) {
        const builtin = art;
        art = chain.pop();
        if (art.length || art.precision || art.scale || art.srid || art.typeArguments) {
          setProp( art, '_finalType', art );
        }
        else {
          setProp( art, '_finalType', builtin );
          art = builtin;
        }
      }
      else if ('_finalType' in art) {
        art = art._finalType;
      }
      else {
        setProp( art, '_finalType', art );
      }
    }
    chain.reverse();
    for (const a of chain) {
      // TODO: we had (git tag 'nr-hana') an auto expansion of referred
      // structure types if there existed an annotation assignment for elements
      // of that referred type.  This is not such a good idea since later
      // annotation would not have this effect.  It is better to provide an
      // compiler option --expand-structures which would always expand referred
      // structure types.
      if (art && art.target && redirectImplicitly( a, art ))
        art = a;
      setProp( a, '_finalType', art );
    }
    if (art && art.target)
      redirectImplicitly( art, art ); // explicit: redirect to auto-exposed
    return art;
  }

  function directType( art ) {
    // Be careful when using it with art.target or art.enum or art.elements
    if (art.origin)             // TODO: _origin
      return art.origin._artifact;
    if (art.type)
      return resolveType( art.type, art );
    // console.log( 'EXPR-IN', art.kind, refString(art.name) )
    const query = art._parent && art._parent._leadingQuery || art._parent; // TODO: re-check leading
    // console.log( 'EXPR-QUERY', query.kind, refString(query.name) )
    if (!query || query.kind !== 'query' || !art.value.path)
      return undefined;
    // Reached an element in a query which is a simple ref -> return referred artifact
    // TODO: remember that we still have to resolve path arguments and filters
    return resolvePath( art.value, 'expr', art, query.$combined );
    // console.log( 'EXPR-OUT', art.value._artifact.kind, refString(art.value._artifact.name) );
  }

  // TODO (when --hana-flavor dies): remove this function
  function resolveType( ref, user ) {
    return resolvePath( ref, (ref.scope !== 'typeOf' ? 'type' : 'typeOf'), user );
  }

  // Make a view to have elements (remember: wildcard), and prepare that their
  // final type can be resolved, i.e. we know how to resolve select item refs.
  // We do so by first populate views in the FROM clause, then the view query.
  function populateView( art ) {
    if (!art.$from || art._status === '_query')
      return;
    const resolveChain = [];
    const fromChain = [ art ];
    while (fromChain.length) {
      const view = fromChain.pop();
      if (view._status === '_query') // already fully resolved (status at def)
        continue;
      resolveChain.push( view );
      for (const from of view.$from) {
        if (from._status)       // status at the ref -> illegal recursion -> stop
          continue;
        setProp( from, '_status', '_query' );
        // setProp before resolvePath - Cycle: view V as select from V.toV
        let source = resolvePath( from, 'from', view ); // filter and args in resolveQuery
        // console.log('ST:',msgName(source),from._status)
        if (source && source._main) { // element -> should be assoc
          const type = finalType( source );
          source = type && type.target;
        }
        if (source && source.$from && source._status !== '_query')
          fromChain.push( source );
      }
    }
    // console.log( resolveChain.map( v => msgName(v)+v._status ) );
    for (const view of resolveChain.reverse()) {
      if (view._status !== '_query' ) { // not already resolved
        setProp( view, '_status', '_query' );
        traverseQueryPost( view.query, false, populateQuery );
        if (view.elements$)     // specified elements
          mergeSpecifiedElements( view );
        inheritActions( view );
        if (!view.$entity) {
          model._entities.push( view );
          view.$entity = ++model.$entity;
        }
      }
    }
  }

  function mergeSpecifiedElements( view ) {
    // Later we use specified elements as proxies to inferred of leading query
    for (const id in view.elements) {
      const ielem = view.elements[id];  // inferred element
      const selem = view.elements$[id]; // specified element
      if (!selem) {
        message( 'query-missing-element', ielem.name.location, view, { id },
                 'Info', 'Element $(ID) is missing in specified elements' );
      }
      else if (!Array.isArray( ielem ) && !Array.isArray( selem )) {
        for (const prop in selem) {
          // just annotation assignments for the moment
          if (prop.charAt(0) === '@')
            ielem[prop] = selem[prop];
          else if (prop === 'type' && view.$syntax === 'patched')
            ielem[prop] = selem[prop];
        }
        selem.$replacement = true;
      }
    }
    for (const id in view.elements$) {
      const selem = view.elements$[id]; // specified element
      if (!Array.isArray( selem ) && !selem.$replacement) {
        message( 'query-unspecified-element', selem.name.location, selem, { id },
                 'Error', 'Element $(ID) does not result from the query' );
      }
    }
  }

  function traverseElementEnvironments( art ) {
    populateView( art );
    environment( art );
    // TODO: but we have no proxy copy of sub elements yet - no redirection in ValueHelpList.cds
    forEachGeneric( art, 'elements', traverseElementEnvironments );
  }

  function populateQuery( query ) {
    if (query.$combined)        // already done
      return;
    query.$combined = Object.create(null);
    forEachGeneric( query, '$tableAliases', resolveTabRef );
    if (!query.from)
      return;                   // just "query" for JOIN ... ON

    initFromColumns( query );
    if (query.exclude) {
      for (const name in query.exclude)
        resolveExcluding( name );
    }
    forEachGeneric( query, 'elements', initElem );
    return;

    function resolveTabRef( alias ) {
      if (alias.kind === 'element' || alias.self) // mixin element or $projection
        return;
      if (!alias.$navigation) { // TODO: should always be true
        // if (main._block.$frontend!=='json') console.log('TABREF:',alias.name,main,main._block)
        const tab = resolvePath( alias.type, 'from', query );
        const elements = environment( alias ); // works for table ref (incl assoc) and sub query
        alias.$navigation = Object.create(null); // Set explicitly, as...
        // ...with circular dep to source, no elements can be found.
        forEachGeneric( { elements }, 'elements', ( origin, name ) => {
          const elem = linkToOrigin( origin, name, alias, '$navigation',
                                     (tab || origin).name.location );
          elem.kind = '$navElement';
          // elem.name.query = query.name.query;
          if (origin.masked)
            elem.masked = Object.assign( { $inferred: 'nav' }, origin.masked );
        });
      }
      forEachGeneric( { elements: alias.$navigation }, 'elements', ( elem, name ) => {
        addToDict( query.$combined, name, elem, null );
      });
    }

    function resolveExcluding( name ) {
      if (query.$combined[name])
        return;
      /** @type {object} */
      const copmileMessageRef = message( 'ref-undefined-excluding', query.exclude[name].location, query, { name }, 'Info', 'Element $(NAME) has not been found' );
      copmileMessageRef.validNames = query.$combined;
      if (options.testMode) {
        message( null, query.exclude[name].location, null, {}, 'Info',
                 `Valid: ${ Object.keys( query.$combined ).sort().join(', ') }` );
      }
    }

    function initElem( elem ) {
      if (elem.type && !elem.type.$inferred && !elem.viaAll)
        return;                 // explicit type -> enough or directType()
      if (elem.viaAll) {
        // redirectImplicitly( elem, elem.origin._artifact );
        return;
      }
      if (!elem.value || !elem.value.path) // TODO: test $inferred
        return;                 // no value ref or $inferred
      // TODO: what about SELECT from E { $projection.a as a1, a } !!!!!!

      const origin = resolvePath( elem.value, 'expr', elem, query.$combined );
      // console.log( message( null, elem.location, elem, {art:query}, 'Info','RED').toString(),
      //              elem.value)
      // TODO: make this resolvePath() also part of directType() ?!
      if (!origin)
        return;
      elem.origin = elem.value; // TODO: remove origin, make it a _origin = origin._artifact
      // now set things which are necessary for later sub phases:
      const nav = pathNavigation( elem.value );
      if (nav.navigation && nav.item === elem.value.path[elem.value.path.length - 1]) {
        // for rewrite (from source or mixin), TODO: introduce a pushLink function
        addProjection( elem, nav.navigation );
        // redirectImplicitly( elem, origin );
      }
      if (elem.foreignKeys) {   // REDIRECTED with explicit foreign keys
        // TODO: re-check whether it is ok to call finalType here (query
        // element had been set, though).
        const assoc = finalAssoc( elem );
        if (assoc && assoc.onCond) {
          message( 'assoc-unexpected-keys', dictLocation( elem.foreignKeys, elem.target.location ),
                   elem, {}, 'Error',
                   'Explicit foreign keys cannot be provided for unmanaged associations' );
        }
        // TODO: we should also have a check whether the "new" keys fit to the "orig" ones
        forEachGeneric( elem, 'foreignKeys', (key, name) => initKey( key, name, elem ) );
      }
    }
  }

  function finalAssoc( elem ) {
    const ftype = elem && finalType( elem );
    if (!ftype)                 // cycles or undefined similar
      return ftype;
    elem = elem.value && elem.value._artifact;
    while (elem && elem.target) {
      if (elem.onCond || elem.foreignKeys)
        return elem;
      elem = elem.value && elem.value._artifact;
    }
    return elem;
  }

  function initKey( key, name, elem ) {
    setProp( key, '_block', elem._block );
    setMemberParent( key, name, elem ); // TODO: set _block here if not present?
  }

  function redirectImplicitly( elem, assoc ) {
    // PRE: elem has no target, assoc has target prop
    if (elem.kind === '$tableAlias')
      return false;
    const service = (elem._main || elem)._service;
    let target = resolvePath( assoc.target, 'target', assoc );
    // console.log( message( null, elem.location, elem, {target,art:assoc,name:''+assoc.target},
    //              'Info','RED').toString())
    if (!target)
      return false;             // error in target ref
    const { location } = elem.value || elem.type || elem.name;
    if (service && target._service !== service) {
      // we only implicitly redirect for inferred associations or to autoexposed
      const inferredAssoc = (assoc._main || assoc)._service !== service;
      const exposed = minimalExposure( target._descendants &&
                                       target._descendants[service.name.absolute] );
      // console.log( message( null, elem.location, elem, {art: service, target},
      //     'Info','BLUE').toString(), exposed.length)

      if (!exposed.length) {
        const origTarget = target;
        if (isAutoExposed( target ))
          target = createAutoExposed( origTarget, service );
        const desc = origTarget._descendants ||
                   setLink( origTarget, Object.create(null), '_descendants' );
        desc[service.name.absolute] = [ target ];
      }
      else if (exposed.length === 1) {
        const autoexposed = exposed[0]['@cds.autoexposed'];
        // console.log(message( null, elem.location, elem, {art: service, target: exposed[0]},
        //     'Info','TO').toString(), autoexposed, exposed[0])
        if (inferredAssoc || autoexposed && (autoexposed.val === undefined || autoexposed.val))
          target = exposed[0];
      }
      else if (inferredAssoc) {
        const names = exposed.map( e => e.name.absolute ).sort();
        message( 'redirected-implicitly-ambiguous', (elem.value || elem.name).location, elem,
                 { target, art: service, names }, 'Warning',
                 'Target $(TARGET) is exposed in service $(ART) by multiple projections $(NAMES) - no implicit redirection' );
      }
    }
    if (!elem.target) {
      elem.target = {
        path: [ { id: target.name.absolute, location } ],
        scope: 'global',
        location,
        $inferred: (target !== assoc.target._artifact ? 'IMPLICIT' : 'rewrite' ),
      };
      setLink( elem.target, target );
      setLink( elem.target.path[0], target );
    }
    else if (elem.target._artifact !== target) {
      elem.target.$inferred = ''; // redirection to autoexposed of explicit target
      setLink( elem.target, target );
    }
    // console.log(message( null, elem.location, elem, {target},
    //             'Info',elem.target.$inferred).toString())
    return true;
  }

  function minimalExposure( exposed ) {
    if (!exposed || exposed.length < 2)
      return exposed || [];
    let min = null;
    for (const e of exposed) {
      if (!min || min._ancestors && min._ancestors.includes(e))
        min = e;
      else if (!e._ancestors || !e._ancestors.includes( min ))
        return exposed;
    }
    return [ min ];
  }

  function isAutoExposed( target ) {
    if (target.$autoexpose !== undefined)
      return target.$autoexpose;
    const origTarget = target;
    const chain = [];
    let source = target.$from && resolvePath( target.$from[0], 'from', target );
    // query source ref might not have been resolved yet, cycle avoided as
    // setAutoExposed() sets $autoexpose and a second call on same art would
    // return false
    while (target.$autoexpose === undefined && setAutoExposed( target ) && source) {
      // stop at first ancestor with annotation or at non-query entity
      chain.push( target );
      target = source;
      source = target.$from && resolvePath( target.$from[0], 'from', target );
    }
    const autoexpose = target.$autoexpose;
    if (typeof autoexpose === 'boolean') {
      for (const a of chain)
        a.$autoexpose = autoexpose;
    }
    return origTarget.$autoexpose;
  }

  function setAutoExposed( art ) {
    const anno = art['@cds.autoexpose'];
    if (anno && anno.val !== null) { // XSN TODO: set val, but no location for anno short form
      // @cds.autoexpose:true or @cds.autoexpose:false
      art.$autoexpose = anno.val === undefined || !!anno.val;
      return false;
    }
    // no @cds.autoexpose or @cds.autoexpose:null
    art.$autoexpose = model.$compositionTargets[art.name.absolute] ? 'Composition' : null;
    return true;
  }

  function createAutoExposed( target, service ) {
    const targetName = target.name.absolute;
    const absolute = `${ service.name.absolute }.${
      options.longAutoexposed
        ? targetName.replace( /\./g, '_' )
        : targetName.substring( targetName.lastIndexOf('.') + 1 ) }`;
    const autoexposed = model.definitions[absolute];
    if (autoexposed) {
      // It is an error because the semantics would be processing-dependent otherwise
      message( 'duplicate-autoexposed', service.name.location, service,
               { target, art: absolute }, 'Error',
               'Name $(ART) of autoexposed entity for $(TARGET) collides with other definition' );
      message( null, target.name.location, target,
               { art: service }, 'Info',
               'Expose this (or the competing) entity explicitly in service $(ART)' );
      if (autoexposed.$inferred !== 'autoexposed')
        return target;
      const firstTarget = autoexposed.query.from[0]._artifact;
      message( 'duplicate-autoexposed', service.name.location, service,
               { target: firstTarget, art: absolute }, 'Error',
               'Name $(ART) of autoexposed entity for $(TARGET) collides with other definition' );
      message( null, firstTarget.name.location, firstTarget,
               { art: service }, 'Info',
               'Expose this (or the competing) entity explicitly in service $(ART)' );
      autoexposed.$inferred = 'duplicate-autoexposed';
      return target;
    }
    // console.log(absolute)
    const { location } = target.name;
    const artifacts = Object.create(null);
    const from = augmentPath( location, target.name.absolute );
    const art = {
      kind: 'entity',
      name: { location, path: splitIntoPath( location, absolute ) },
      location: target.location,
      query: { location, op: { val: 'query', location }, from: [ from ] },
      $inferred: 'autoexposed',
      '@cds.autoexposed': {
        name: { path: [ { id: 'cds.autoexposed', location } ], location },
      },
    };
    artifacts[absolute] = art;
    setLink( art, service, '_service' );
    initArtifacts( { artifacts }, null, model.$internal, false, '' );
    // populate view (phase 2 of resolver has to be repeated as the view was created afterwards)
    populateView( art );
    // TODO: try to set locations of elements locations of orig target elements
    newAutoExposed.push( art );
    return art;
  }

  function addProjection( proj, nav ) {
    if (nav._projections)
      nav._projections.push( proj );
    else
      setProp( nav, '_projections', [ proj ] );
  }

  // TODO: make this function shorter - make part of this (e.g. setting
  // parent/name) also be part of definer.js
  // TODO: really make view elements proxies to elements of main query!
  function initFromColumns( query ) {
    const elements = Object.create(null);
    clearDict( query, 'elements' );
    if (query._main._leadingQuery === query)
      query._main.elements = query.elements;
    let wildcard = false;

    for (const col of query.columns || [ { val: '*' } ]) {
      if (col.val === '*') {
        wildcard = col.location || query.from[0] && query.from[0].location || query.location;
        continue;
      }
      col.kind = 'element';
      if (!col.value)
        continue;             // error should have been reported by parser
      if (!col.name) {
        const { path } = col.value;
        if (!path) {
          message( 'query-req-name', col.value.location || col.location, query, {},
                   'Error', 'Alias name is required for this select item' );
        }
        else if (path.length && !path.broken) {
          const last = path[path.length - 1];
          if (last)
            col.name = { id: last.id, location: last.location, $inferred: 'as' };
        }
        if (!col.name) {
          // invent a name for code completion in expression
          col.name = { id: '', location: col.value.location, $inferred: 'none' };
        }
      }
      const { id } = col.name;
      addToDict( elements, id, col, ( name, location ) => {
        message( 'duplicate-definition', location, query, { name, '#': 'element' },
                 'Error', { element: 'Duplicate definition of element $(NAME)' } );
      });
      setMemberParent( col, id, query );
      if (!wildcard) {
        addToDictWithIndexNo( query, 'elements', id, col );
        col.$replacement = true;
      }
    }
    if (wildcard)
      expandWildcard( elements, wildcard );
    return;

    // TODO: make this function shorter, probably outside initFromColumns
    // eslint-disable-next-line no-shadow
    function expandWildcard( elements, location ) {
      const exclude = query.exclude || Object.create(null);
      // TODO: paths in exclude? - Did I mention it? EXCLUDING is ill-defined...
      for (const name in query.$combined) {
        const navElem = query.$combined[name];
        if (exclude[name] || navElem.masked && navElem.masked.val)
          continue;
        const selElem = elements[name];
        if (selElem) {
          if (!selElem.name)    // no name with parse error or repeated def
            continue;
          const path = selElem.value && selElem.value.path;
          // TODO: to bring the message below for ParentElem.Assoc, we should move this
          // check to resolveElem for elems with $replacement, by comparing the
          // name with the name.element of the _origin.
          // We cannot check path.length === 1, as we want to allow Alias.Elem.

          // TODO: bring this less often (only if shadowed elem does not appear
          // in expr and if not projected as other name)
          if (!selElem.redirected && selElem.$replacement !== 'silent' ||
              path && path[path.length - 1].id !== selElem.name.id) {
            if (navElem instanceof Array) {
              message( 'wildcard-excluding-many', selElem.name.location, query, { id: name },
                       'Info', 'This select item replaces $(ID) from two or more sources' );
            }
            else {
              message( 'wildcard-excluding-one', selElem.name.location, query,
                       { id: name, alias: navElem._parent.name.id },
                       'Info', 'This select item replaces $(ID) from table alias $(ALIAS)' );
            }
          }
          if (!selElem.$replacement || selElem.$replacement === 'silent') {
            selElem.$replacement = true;
            addToDictWithIndexNo( query, 'elements', name, selElem );
          }
          else {
            selElem.$inferred = 'query';
          }
        }
        else if (navElem instanceof Array) {
          const names = navElem.filter( e => !e.$duplicate)
            .map( e => `${ e.name.alias }.${ e.name.element }` );
          if (names.length) {
            message( 'wildcard-ambiguous', location, query, { id: name, names },
                     'Error', 'Ambiguous wildcard, select $(ID) explicitly with $(NAMES)' );
          }
        }
        else {
          location = weakLocation( location );
          const origin = navElem.origin._artifact;
          const elem = linkToOrigin( origin, name, query, 'elements', location );
          elem.$inferred = '*';
          elem.name.$inferred = '*';
          elem.name.calculated = true;
          elem.viaAll = true;
          setElementOrigin( elem, navElem, name, location );
        }
      }
      forEachInOrder( { elements }, 'elements', (elem, name) => {
        if (!elem.$replacement)
          addToDictWithIndexNo( query, 'elements', name, elem );
      });
    }
  }

  function setElementOrigin( queryElem, navElem, name, location ) {
    const sourceElem = navElem.origin._artifact;
    const alias = navElem._parent;
    const path = [ { id: alias.name.id, location }, { id: name, location } ];
    queryElem.value = queryElem.origin;
    // always expand * to path with table alias (reason: columns current_date etc)
    queryElem.value.path = path;
    const real = alias.origin || alias.type; // is undefined for sub query
    const assoc = alias.type && alias._finalType && alias._finalType.target;
    // TODO: or should we set the _artifact/_finalType directly to the target?
    setProp( path[0], '_artifact', assoc && assoc._artifact || real && real._artifact || alias );
    setProp( path[0], '_navigation', alias );
    setProp( path[1], '_artifact', sourceElem );
    addProjection( queryElem, navElem );
    // TODO: _finalType?
  }

  function inheritActions( view ) {
    const primary = view.$from[0] && view.$from[0]._artifact;
    if (!primary || !primary.actions)
      return;
    const { location } = view.$from[0];
    const actions = view.actions || Object.create(null);
    clearDict( view, 'actions' );
    forEachGeneric( primary, 'actions', ( origin, id ) => {
      const own = actions[id];
      if (!own) {
        const action = linkToOrigin( origin, id, view, 'actions', location );
        action.$inferred = 'proxy';
      }
      else if (!own.$inferred) {
        // TODO: or in-place if shadowed?  But the order is unimportant anyway...
        message( 'shadowed-action', own.name.location, view, { id, art: primary },
                 'Info', 'This definition shadows action $(ID) of $(ART)' );
      }
    });
    forEachGeneric( { actions }, 'actions', ( action, name ) => {
      addToDictWithIndexNo( view, 'actions', name, action );
    });
  }


  //--------------------------------------------------------------------------
  // Phase 3: calculate propagated KEYs
  //--------------------------------------------------------------------------

  function propagateKeyProps( view ) {
    // console.log(message( null, view.location, {art:view}, 'Info','$(ART)').toString())
    traverseQueryPost( view.query, true, ( query ) => {
      if (!withExplicitKeys( query ) && inheritKeyProp( query ) &&
          withKeyPropagation( query )) // now the part with messages
        inheritKeyProp( query, true );
    } );
  }

  function withExplicitKeys( query ) {
    for (const name in query.elements) {
      const es = query.elements[name];
      for (const elem of (es instanceof Array) ? es : [ es ]) {
        if (elem.key)           // also those from includes
          return true;
      }
    }
    return false;
  }

  function inheritKeyProp( query, doIt ) {
    for (const name in query.elements) {
      const elem = query.elements[name];
      // no key prop for duplicate elements or additional specified elements:
      if (elem instanceof Array || !elem.value)
        continue;
      const nav = pathNavigation( elem.value );
      if (!nav.navigation)
        continue;            // undefined, expr, $magic, :const, $self (!), $self.elem
      const { item } = nav;
      if (item !== elem.value.path[elem.value.path.length - 1])
        continue;         // having selected a sub elem / navigated along assoc
      const { key } = item._artifact;
      if (key) {
        if (!doIt)
          return true;
        elem.key = { location: elem.value.location, val: key.val, $inferred: 'query' };
      }
    }
    return false;
  }

  function withKeyPropagation( query ) {
    let from = query.from[0];
    while (from instanceof Array)
      from = from[0];
    if (!from)                  // parse error SELECT FROM <EOF>
      return false;

    let propagateKeys = true;   // used instead early RETURN to get more messages
    const toMany = withAssociation( from, targetMaxNotOne, true );
    if (toMany) {
      propagateKeys = false;
      message( 'query-from-many', toMany.location, query, { art: toMany },
               'Info', {
                 std: 'Selecting from to-many association $(ART) - key properties are not propagated',
                 element: 'Selecting from to-many association $(MEMBER) of $(ART) - key properties are not propagated',
               } );
    }
    // Check that all keys from the source are projected:
    const notProjected = [];    // we actually push to the array
    const navElems = query._firstAliasInFrom && query._firstAliasInFrom.$navigation;
    for (const name in navElems) {
      const nav = navElems[name];
      if (nav instanceof Array)
        continue;
      const { key } = nav.origin._artifact;
      // if (key) console.log( 'KEY:', nav.origin._artifact.name.id, !!key.val, nav._projections);
      if (key && key.val && !(nav._projections && nav._projections.length))
        notProjected.push( nav.name.id );
    }
    if (notProjected.length) {
      propagateKeys = false;
      message( 'query-missing-keys', from.location, query, { names: notProjected },
               'Info', {
                 std: 'Keys $(NAMES) have not been projected - key properties are not propagated',
                 one: 'Key $(NAMES) has not been projected - key properties are not propagated',
               } );
    }
    // Check that there is no to-many assoc used in select item:
    for (const name in query.elements) {
      const elem = query.elements[name];
      if (!elem.$inferred && elem.value &&
          testExpr( elem.value, selectTest, () => false ))
        propagateKeys = false;
    }
    return propagateKeys;

    function selectTest( expr ) {
      const art = withAssociation( expr, targetMaxNotOne );
      if (art) {
        message( 'query-navigate-many', art.location, query, { art },
                 'Info', {
                   std: 'Navigating along to-many association $(ART) - key properties are not propagated',
                   element: 'Navigating along to-many association $(MEMBER) of $(ART) - key properties are not propagated',
                   alias: 'Navigating along to-many mixin association $(MEMBER) - key properties are not propagated',
                 } );
      }
      return art;
    }
  }

  //--------------------------------------------------------------------------
  // Phase 4:
  //--------------------------------------------------------------------------

  // TODO: have $applied/$extension/$status on extension with the following values
  //  - 'unknown': artifact to extend/annotate is not defined or contains unknown member
  //  - 'referred': contains annotation for element of referred type (not yet supported)
  //  - 'inferred': only contains extension for known member, but some inferred ones
  //    (inferred = elements from structure includes, query elements)
  //  - 'original': only contains extensions on non-inferred members

  // Resolve all references in artifact or element `art`.  Do so recursively in
  // all sub elements.
  // TODO: make this function smaller
  function resolveRefs( art ) {
    // console.log(message( null, art.location, art, {}, 'Info','REFS').toString())
    finalType( art );           // make sure implicitly redirected target exists
    // console.log(message( null, art.location, art, {target:art.target}, 'Info','RR').toString())
    if (!art._deps)
      setProp( art, '_deps', [] );
    if (art.key && !art.key.$inferred && art._parent &&
        ![ 'entity', 'view', 'query' ].includes( art._parent.kind )) {
      message( 'unexpected-key', art.key.location, art, {},
               'Warning', 'KEY is only supported for elements in an entity or view' );
    }

    const thing = art.returns || art;
    const obj = thing.items || thing; // the object which has type properties

    if (obj.type) {
      resolveTypeExpr( obj, art );

      // typeOf unmanaged assoc?
      if (obj.type._artifact && obj.type._artifact.target && obj.type._artifact.onCond) {
        message( 'assoc-as-type-of', obj.type.location, art, {},
                 'Error', 'An unmanaged association cannot be used in type-of' );
        return;
      }
    }
    if (obj.target) {
      // console.log(message( null, obj.location, obj, {target:obj.target}, 'Info','TARGET')
      //             .toString(), obj.target.$inferred)
      if (!obj.target.$inferred)
        resolveTarget( art, obj );
      else if (obj.target.$inferred)
        resolveRedirected( art, obj.target._artifact );
    }
    else if (obj.name && obj.name.$mixin) {
      message( 'non-assoc-in-mixin', (obj.type || obj.name).location, art, {},
               [ 'Error' ], 'Only unmanaged associations are allowed in mixin clauses' );
    }
    if (art.targetElement) {    // in foreign keys
      const target = art._parent && art._parent.target;
      if (target && target._artifact) {
        // we just look in target for the path
        // TODO: also check that we do not follow associations? no args, no filter
        resolvePath( art.targetElement, 'targetElement', art,
                     environment( target._artifact ), target._artifact );
      }
    }
    // Resolve projections/views
    if (art.$from)              // use $from to avoid queries by old augmentor
      traverseQueryPost( art.query, false, resolveQuery );
    if (obj.type || obj.origin || obj.value && obj.value.path || obj.elements) // typed artifacts
      finalType(obj);  // set _finalType if appropriate, (future?): copy elems if extended
    if (thing.items)
      setProp( thing, '_finalType', thing );

    if (obj.elements) {           // silent dependencies
      forEachGeneric( obj, 'elements', (elem) => {
        art._deps.push( { art: elem } );
      } );
    }
    if (obj.foreignKeys) {       // silent dependencies
      forEachGeneric( obj, 'foreignKeys', (elem) => {
        art._deps.push( { art: elem } );
      } );
      addForeignKeyNavigations( art );
    }

    resolveExpr( art.default, 'const', art );
    resolveExpr( art.value, 'expr', art );
    if (art.kind === 'element')
      finalType( art );
    resolveTechnicalConfig( art );

    annotateMembers( art );     // TODO recheck - recursively, but also forEachMember below
    for (const prop in art) {
      if (prop.charAt(0) === '@')
        chooseAssignment( prop, art );
    }

    if (!art.source)            // don't run for old augmentor - locations missing - TODO: remove
      forEachMember( art, resolveRefs, art.target );

    // Set '@Core.Computed' in the Core Compiler to have it propagated...
    if (art.kind !== 'element' || art['@Core.Computed'])
      return;
    if (art.virtual && art.virtual.val ||
        art.value &&
        (!art.value._artifact || !art.value.path || // in localization view: _artifact, but no path
         [ 'builtin', 'param' ].includes( art.value._artifact.kind ))) {
      art['@Core.Computed'] = {
        name: {
          path: [ { id: 'Core.Computed', location: art.location } ],
          location: art.location,
        },
        $inferred: 'computed',
      };
    }
  }

  // resolve all paths inside a technical configuration
  function resolveTechnicalConfig( art ) {
    // user required? works only with extDict = art.elements is that so?
    const tc = art.technicalConfig;
    if (!tc)
      return;
    if (!options.hanaFlavor && !isBetaEnabled( options, 'technicalConfig' ) && tc.location) {
      message( null, tc.location, art, {}, 'Error',
               'TECHNICAL CONFIGURATION is not supported yet' );
    }

    // secondary and fulltext indexes
    forEachGeneric( tc, 'indexes', (index) => {
      index.columns.forEach( (col) => {
        resolvePath( col, 'element', art, art.elements );
      });
      if (index.language)
        resolvePath( index.language.column, 'element', art, art.elements );
      resolvePath( index.mimeTypeColumn, 'element', art, art.elements );
    });
    // fuzzy indexes
    if (tc.fzindexes) {
      tc.fzindexes.forEach( (i) => {
        i.columns.forEach((c) => {
          resolvePath( c, 'element', art, art.elements );
        });
      });
    }
    // partition expressions
    if (tc.partition) {
      tc.partition.specs.forEach( (s) => {
        if (s.columns)
          s.columns.forEach( p => resolvePath( p, 'element', art, art.elements) );
      } );
    }
  }

  // Phase 4 - annotations ---------------------------------------------------

  function annotateUnknown( ext ) {
    if (ext.$extension)         // extension for known artifact -> already applied
      return;
    annotateMembers( ext );
    for (const prop in ext) {
      if (prop.charAt(0) === '@')
        chooseAssignment( prop, ext );
    }
  }

  function annotateMembers( art, extensions = [], prop, name, parent, kind ) {
    const showMsg = !art && parent && parent.kind !== 'annotate';
    if (!art && extensions.length) {
      if (Array.isArray( parent ))
        return;
      const parentExt = extensionFor(parent);
      art = parentExt[prop] && parentExt[prop][name];
      if (!art) {
        art = {
          kind,                 // for setMemberParent()
          name: { id: name, location: extensions[0].name.location },
          location: extensions[0].location,
        };
        setMemberParent( art, name, extensionFor(parent), prop );
        art.kind = 'annotate';  // after setMemberParent()!
      }
    }

    for (const ext of extensions) {
      if ('_artifact' in ext.name) // already applied
        continue;
      setProp( ext.name, '_artifact', art );

      if (art) {
        defineAnnotations( ext, art, ext._block, ext.kind );
        // eslint-disable-next-line no-shadow
        forEachMember( ext, ( elem, name, prop ) => {
          storeExtension( elem, name, prop, art, ext._block );
        });
      }
      if (showMsg) {
        // somehow similar to checkDefinitions():
        const feature = kindProperties[parent.kind][prop];
        if (prop === 'elements' || prop === 'enum') {
          if (!feature) {
            message( 'anno-unexpected-elements', ext.name.location, art, {}, 'Warning',
                     'Elements only exist in entities, types or typed constructs' );
          }
          else {
            message( 'anno-undefined-element', ext.name.location, art,
                     { art: searchName( parent, name, parent.enum && 'enum' ) } );
          }
        }
        else if (prop === 'actions') {
          if (!feature) {
            message( 'anno-unexpected-actions', ext.name.location, art, {}, 'Warning',
                     'Actions and functions only exist top-level and for entities' );
          }
          else {
            message( 'anno-undefined-action', ext.name.location, art,
                     { art: searchName( parent, name, 'action' ) } );
          }
        }
        else if (!feature) {
          message( 'anno-unexpected-params', ext.name.location, art, {}, 'Warning',
                   'Parameters only exist for actions or functions' );
        } // TODO: entities betaMod
        else {
          message( 'anno-undefined-param', ext.name.location, art,
                   { art: searchName( parent, name, 'param' ) } );
        }
      }
    }
    if (art) {
      let obj = art.returns || art; // why the extra `returns` for actions?
      obj = obj.items || obj;
      annotate( obj, 'element', 'elements', 'enum', art );
      annotate( art, 'action', 'actions' );
      annotate( art, 'param', 'params' );
    }
    return;

    // eslint-disable-next-line no-shadow
    function annotate( obj, kind, prop, altProp, parent = obj ) {
      const dict = art._annotate && art._annotate[prop];
      const env = obj[prop] || altProp && obj[altProp] || null;
      for (const n in dict)
        annotateMembers( env && env[n], dict[n], prop, n, parent, kind );
    }
  }

  function extensionFor( art ) {
    if (art.kind === 'annotate')
      return art;
    if (art._extension)
      return art._extension;

    // $extension means: already applied
    const ext = {
      kind: art.kind,           // set kind for setMemberParent()
      $extension: 'exists',
      location: art.location,    // location( extension to existing art ) = location(art)
    };
    const { location } = art.name;
    if (!art._main) {
      ext.name = {
        path: [ { id: art.name.absolute, location } ],
        location,
        absolute: art.name.absolute,
      };
      if (model.extensions)
        model.extensions.push(ext);
      else
        model.extensions = [ ext ];
    }
    else {
      ext.name = { id: art.name.id, location };
      const parent = extensionFor( art._parent );
      const kind = kindProperties[art.kind].normalized || art.kind;
      // enums would be first in elements
      if ( parent[kindProperties[kind].dict] &&
           parent[kindProperties[kind].dict][art.name.id] )
        throw new Error(art.name.id);
      setMemberParent( ext, art.name.id, parent, kindProperties[kind].dict );
    }
    ext.kind = 'annotate';    // after setMemberParent()!
    setProp( art, '_extension', ext );
    setProp( ext.name, '_artifact', art );
    return ext;
  }

  function chooseAssignment( annoName, art ) {
    // TODO: getPath an all names
    const anno = art[annoName];
    if (!(anno instanceof Array)) // just one assignment -> use it
      return;
    // sort assignment according to layer
    const layerAnnos = Object.create(null);
    for (const a of anno) {
      const layer = layers.layer( a._block );
      const name = (layer) ? layer.realname : '';
      const done = layerAnnos[name];
      if (done)
        done.annos.push( a );
      else
        layerAnnos[name] = { layer, annos: [ a ] };
    }
    // collect assignments of upper layers (are in no _layerExtends)
    const exts = Object.keys( layerAnnos ).map( layerExtends );
    const allExtends = Object.assign( Object.create(null), ...exts );
    const collected = [];
    for (const name in layerAnnos) {
      if (!(name in allExtends))
        collected.push( prioritizedAnnos( layerAnnos[name].annos ) );
    }
    // inspect collected assignments - choose the one or signal error
    const justOnePerLayer = collected.every( annos => annos.length === 1);
    if (!justOnePerLayer || collected.length > 1) {
      for (const annos of collected) {
        for (const a of annos ) {
          message( 'anno-duplicate', a.name.location, art,
                   { anno: annoName, '#': justOnePerLayer && 'unrelated' },
                   [ 'Error' ], {
                     std: 'Duplicate assignment with $(ANNO)',
                     // we could add USING...FROM between the unrelated layers:
                     unrelated: 'Duplicate assignment with $(ANNO) in unrelated layers',
                   });
        }
      }
    }
    art[annoName] = collected[0][0]; // just choose any one with error
    return;

    function layerExtends( name ) {
      const { layer } = layerAnnos[name];
      return layer && layer._layerExtends;
    }
  }

  function prioritizedAnnos( annos ) {
    let prio = 0;
    let r = [];
    for (const a of annos) {
      const p = annotationPriorities[a.priority] || annotationPriorities.define;
      if (p === prio) {
        r.push(a);
      }
      else if (p > prio) {
        r = [ a ];
        prio = p;
      }
    }
    return r;
  }

  // Phase 4 - queries and associations --------------------------------------

  function resolveQuery( query ) {
    populateQuery( query );
    forEachGeneric( query, '$tableAliases', ( alias ) => {
      // console.log(message( null, alias.location, {art:alias}, 'Info','$(ART)').message)
      if (alias.kind === 'element')
        resolveRefs( alias );   // mixin element
      else if (!alias.self)    // not $projection/$self
        // pure path has been resolved, resolve args and filter now:
        resolveExpr( alias.type, 'from', query._parent );
    } );
    if (query !== query._main._leadingQuery) // will be done later
      // TODO: rethink elements(view) === elements(view._leadingQuery)
      forEachGeneric( query, 'elements', resolveRefs );
    if (query.on)
      resolveExpr( query.on, 'expr', query, query.$combined );
    if (query.where)
      resolveExpr( query.where, 'expr', query, query.$combined );
    if (query.groupBy)
      resolveBy( query.groupBy, 'expr' );
    resolveExpr( query.having, 'expr', query, query.$combined );
    if (query.$orderBy)       // ORDER BY from UNION:
      // TODO clarify: can I access the tab alias of outer queries?  If not:
      // 4th arg query._main instead query._parent.
      resolveBy( query.$orderBy, 'order-by-union', query.elements, query._parent );
    if (query.orderBy) {       // ORDER BY
    // If we would allow VIEW extensions, re-think the Object.assign
      resolveBy( query.orderBy, 'expr',
                 Object.assign( Object.create(null), query.$combined, query.elements ) );
    }
    return;

    // Note the strange name resolution (dynamic part) for ORDER BY: the same
    // as for select items if it is an expression, but first look at select
    // item alias (i.e. like `$projection.NAME` if it is a path.  If it is an
    // ORDER BY of an UNION, do not allow any dynamic path in an expression,
    // and only allow the elements of the leading query if it is a path.
    //
    // This seem to be similar, but different in SQLite 3.22.0: ORDER BY seems
    // to bind stronger than UNION (see <SQLite>/src/parse.y), and the name
    // resolution seems to use select item aliases from all SELECTs of the
    // UNION (see <SQLite>/test/tkt2822.test).
    function resolveBy( array, mode, pathDict, q ) {
      for (const item of array ) {
        const value = pathDict ? item.value : item; // XSN TODO: no extra value?
        if (value)
          resolveExpr( value, mode, q || query, value.path && pathDict );
      }
    }
  }

  function resolveTarget( art, obj ) {
    if (art !== obj) {
      message( 'assoc-in-array', obj.onCond.location, art, {},
               // TODO: also check parameter parent, two messages?
               [ 'Error' ], 'An association cannot used for arrays or parameters' );
      setProp( obj.target, '_artifact', undefined );
      return;
    }
    const target = resolvePath( obj.target, 'target', art );
    if (obj.onCond) {
      if (!art._main || !art._parent.elements) {
        message( 'assoc-as-type', obj.onCond.location, art, {},
                 [ 'Error' ], 'An unmanaged association cannot be defined as type' );
        // TODO: also warning if inside structure
      }
      else {
        // TODO: extra with $inferred (to avoid messages)?
        resolveExpr( obj.onCond, art.name.$mixin ? 'mixin-on' : 'on', art );
      }
    }
    else if (art.name.$mixin) {
      message( 'assoc-in-mixin', obj.target.location, art, {},
               'Error', 'Managed associations are not allowed for MIXIN elements' );
    }
    else if (target && !obj.foreignKeys && [ 'entity', 'view' ].includes( target.kind )) {
      if (!obj.type || obj.type.$inferred || obj.target.$inferred) { // REDIRECTED
        resolveRedirected( art, target );
      }
      else if (obj.type._artifact && obj.type._artifact.internal) { // cds.Association, ...
        addImplicitForeignKeys( art, target );
      }
      // else console.log( message( null,obj.location,obj, {target}, 'Info','NOTARGET').toString())
    }
    // else console.log( message( null, obj.location, obj, {target}, 'Info','NORE').toString())
  }

  function addImplicitForeignKeys( art, target ) {
    forEachInOrder( target, 'elements', ( elem, name ) => {
      if (elem.key && elem.key.val) {
        const { location } = art.target;
        const key = {
          name: { location, id: elem.name.id, $inferred: 'keys' }, // more by setMemberParent()
          kind: 'key',
          targetElement: { path: [ { id: elem.name.id, location } ], location },
          location,
          calculated: true,
          $inferred: 'keys',
        };
        setMemberParent( key, name, art, 'foreignKeys' );
        setProp( key.targetElement, '_artifact', elem );
        setProp( key.targetElement.path[0], '_artifact', elem );
        setProp( key, '_finalType', finalType(elem) );
        setProp( key, '_deps', [ { art: elem, location } ] );
        art._deps.push( { art: key } );
      }
    });
    art.implicitForeignKeys = true;
  }

  function addForeignKeyNavigations( art ) {
    art.$keysNavigation = Object.create(null);
    forEachGeneric( art, 'foreignKeys', ( key ) => {
      if (!key.targetElement || !key.targetElement.path)
        return;
      let dict = art.$keysNavigation;
      const last = key.targetElement.path[key.targetElement.path.length - 1];
      for (const item of key.targetElement.path) {
        let nav = dict[item.id];
        if (!nav) {
          nav = {};
          dict[item.id] = nav;
          if (item === last)
            setLink( nav, key );
          else
            nav.$keysNavigation = Object.create(null);
        }
        else if (item === last || nav._artifact) {
          message( 'duplicate-key-ref', item.location, key, {}, 'Error',
                   'The same target reference has already been used in a key definition' );
          return;
        }
        dict = nav.$keysNavigation;
      }
    } );
  }

  function resolveRedirected( elem, target ) {
    setProp( elem, '_redirected', null ); // null = do not touch path steps after assoc
    const assoc = directType( elem );
    const origType = assoc && finalType( assoc );
    if (!origType || !origType.target) {
      message( 'redirected-no-assoc', elem.target.location, elem, {},
               'Error', 'Only an association can be redirected' );
      return;
    }
    const nav = elem._main && elem._main.query && pathNavigation( elem.value );
    // console.log(message( null, elem.location, elem, {target,art:origType}, 'Info','RE')
    //             .toString())
    if (nav && nav.item !== elem.value.path[elem.value.path.length - 1]) {
      if (origType.onCond) {
        message( 'rewrite-not-supported', elem.target.location, elem, {},
                 // TODO: Better text ?
                 'Warning',
                 'The ON condition is not rewritten here - provide an explicit ON condition' );
        return;
      }
    }
    const origTarget = origType.target._artifact;
    if (!origTarget || !target)
      return;

    const chain = [];
    if (target === origTarget) {
      if (!elem.target.$inferred) {
        message( 'redirected-to-same', elem.target.location, elem, { art: target },
                 'Info', 'The redirected target is the original $(ART)' );
      }
      setProp( elem, '_redirected', chain ); // store the chain
      return;
    }
    // now check whether target and origTarget are "related"
    while (target.query) {
      const from = (target.query.args) ? [ 1, 2 ] : target.query.from;
      if (!from || !from.length || !from[0]) // parse error
        return;
      if (from.length > 1 || !from[0].path) {
        // TODO: no messages with explicit keys/on ?
        message( 'redirected-to-complex', elem.target.location, elem,
                 { art: target, '#': target === elem.target._artifact ? 'target' : 'std' },
                 'Warning', {
                   std: 'Redirection involves the complex view $(ART)',
                   target: 'The redirected target $(ART) is a complex view',
                 });
        break;
      }
      target = from[0]._artifact;
      if (!target)
        return;
      chain.push( from[0]._tableAlias );
      if (target === origTarget) {
        chain.reverse();
        setProp( elem, '_redirected', chain );
        return;
      }
    }
    let redirected = null;
    let news = [ { chain: chain.reverse(), sources: [ target ] } ];
    const dict = Object.create(null);
    while (news.length) {
      const outer = news;
      news = [];
      for (const o of outer) {
        for (const s of o.sources) {
          const art = (s.kind === '$tableAlias') ? s.type._artifact : s;
          if (art !== origTarget) {
            if (findOrig( o.chain, s, art ) && !redirected)
              redirected = false;   // do not report futher error
          }
          else if (redirected) {
            // TODO: no messages with explicit keys/on ? non-configurable error otherwise
            message( 'redirected-to-ambiguous', elem.target.location, elem, { art: origTarget },
                     [ 'Error' ], 'The redirected target originates repeatedly from $(ART)' );
            return;
          }
          else {
            redirected = (s.kind === '$tableAlias') ? [ s, ...o.chain ] : o.chain;
          }
        }
      }
    }
    if (redirected) {
      setProp( elem, '_redirected', redirected );
    }
    else if (redirected == null) {
      // TODO: no messages with explicit keys/on ? non-configurable error otherwise
      message( 'redirected-to-unrelated', elem.target.location, elem, { art: origTarget },
               [ 'Error' ],
               'The redirected target does not originate from $(ART)' );
    }
    return;

    // B = proj on A, C = A x B, X = { a: assoc to A on a.Q1 = ...}, Y = X.{ a: redirected to C }
    // what does a: redirected to C means?
    // -> collect all elements Qi used in ON (corr: foreign keys)
    // -> only use an tableAlias which has propagation for all elements
    // no - error if the original target can be reached twice
    // even better: disallow complex view (try as error first)

    // eslint-disable-next-line no-shadow
    function findOrig( chain, alias, art ) {
      if (!art || dict[art.name.absolute])
        // some include ref or query source cannot be found, or cyclic ref
        return true;
      dict[art.name.absolute] = true;

      if (art.includes)
        news.push( { chain: [ art, ...chain ], sources: art.includes.map( r => r._artifact ) } );
      const query = art._leadingQuery;
      if (!query)
        return false;           // non-query entity
      if (!query.$tableAliases) // previous error in query definition
        return true;
      const sources = [];
      for (const n in query.$tableAliases) {
        const a = query.$tableAliases[n];
        if (a.type && !a.self && !a.name.$mixin)
          sources.push( a );
      }
      if (alias.kind === '$tablealias')
        news.push( { chain: [ alias, ...chain ], sources } );
      else
        news.push( { chain, sources } );
      return false;
    }
  }

  //--------------------------------------------------------------------------
  // Phase 5: rewrite associations
  //--------------------------------------------------------------------------
  // Only top-level queries and sub queries in FROM

  function rewriteSimple( art ) {
    // If we have a proper seperation of view elements and elements of the
    // primary query, we can delete this function.
    // return;
    if (!art.includes && !art.query) {
      // console.log(message( null, art.location, art, {target:art._target},
      //   'Info','RAS').toString())
      rewriteAssociation( art );
      forEachGeneric( art, 'elements', rewriteAssociation );
    }
    if (art._service)
      forEachGeneric( art, 'elements', excludeAssociation );
  }

  function rewriteView( view ) {
    traverseQueryPost( view.query, false, ( query ) => {
      forEachGeneric( query, 'elements', rewriteAssociation );
    } );
    if (view.includes)          // entities with structure includes:
      forEachGeneric( view, 'elements', rewriteAssociation );
  }

  function excludeAssociation( elem ) {
    const target = elem.target && elem.target._artifact;
    if (!target || target._service) // assoc to other service is OK
      return;
    if (!elem.$inferred) {      // && !elem.target.$inferred
      message( 'assoc-target-not-in-service', elem.target.location, elem,
               { target, '#': (elem._main.query ? 'select' : 'define') }, 'Warning', {
                 define: 'Target $(TARGET) of explicitly defined association is outside any service',
                 select: 'Target $(TARGET) of explicitly selected association is outside any service',
               } );
    }
    else if (elem._xref && elem._xref.length) {
      for (const xref of elem._xref) {
        message( 'assoc-target-not-exposed', xref.where.location, elem,
                 { target, art: elem._main._service }, 'Warning',
                 'Target $(TARGET) of referred association is not exposed in service $(ART)' );
      }
    }
    else {
      message( 'assoc-outside-service', elem.target.location, elem,
               { target }, 'Info',
               'Association target $(TARGET) is outside any service' );
    }
  }

  function rewriteAssociation( elem ) {
    const assoc = directType( elem );
    const ftype = assoc && finalType( assoc );
    if (!ftype)
      return;
    const target = ftype.target && ftype.target._artifact;
    if (!target)
      return;
    // console.log(message( null, elem.location, elem,
    // {art:assoc,target,ftype:JSON.stringify(ftype)}, 'Info','RA').toString())

    // With cyclic dependencies on select items, testing for the _finalType to
    // be 0 (test above) is not enough if we we have an explicit redirection
    // target -> avoid infloop ourselves with _status.
    const chain = [];
    while (!elem.onCond && !elem.foreignKeys) {
      chain.push( elem );
      if (elem._status === 'rewrite') { // circular dependency (already reported)
        for (const e of chain)
          setProp( e, '_status', null ); // XSN TODO: nonenum _status -> enum $status
        return;
      }
      setProp( elem, '_status', 'rewrite' );
      elem = directType( elem );
      if (!elem || elem.builtin) // safety
        return;
    }
    chain.reverse();
    for (const art of chain) {
      setProp( elem, '_status', null );
      if (elem.onCond)
        rewriteCondition( art, elem );
      else if (elem.foreignKeys)
        rewriteKeys( art, elem );
      elem = art;
    }
  }

  function rewriteKeys( elem, assoc ) {
    // TODO: split this function: create foreign keys without `targetElement`
    // already in Phase 2: redirectImplicitly()
    // console.log(message( null, elem.location, elem, {art:assoc,target:assoc.target},
    //  'Info','FK').toString())
    forEachInOrder( assoc, 'foreignKeys', ( orig, name ) => {
      const fk = linkToOrigin( orig, name, elem, 'foreignKeys', elem.location );
      fk.$inferred = 'rewrite'; // TODO: other $inferred value?
      // TODO: re-check for case that foreign key is managed association
      if ('_finalType' in orig)
        setProp( fk, '_finalType', orig._finalType);
      const te = copyExpr( orig.targetElement, elem.location );
      if (elem._redirected) {
        const i = te.path[0];   // TODO: or also follow path like for ON?
        const state = rewriteItem( elem, i, i.id, elem, true );
        if (state && state !== true && te.path.length === 1)
          setLink( te, state );
      }
      fk.targetElement = te;
    });
  }

  function rewriteCondition( elem, assoc ) {
    const nav = (elem._main && elem._main.query) ? pathNavigation( elem.value )
      : { navigation: assoc };
    const cond = copyExpr( assoc.onCond,
      // replace location in ON except if from mixin element
                           nav.tableAlias && elem.origin.location );
    cond.$inferred = 'copy';
    elem.onCond = cond;
    // console.log(message( null, elem.location, elem, {art:assoc,target:assoc.target},
    //   'Info','ON').toString(), nav)
    const { navigation } = nav;
    if (!navigation) // TODO: what about $projection.assoc as myAssoc ?
      return;                 // should not happen: $projection, $magic, or ref to const
    // console.log(message( null, elem.location, elem, {art:assoc}, 'Info','D').toString())
    // Currently, having an unmanaged association inside a struct is not
    // supported by this function:
    if (navigation !== assoc && navigation.origin &&
        navigation.origin._artifact !== assoc) { // TODO: re-check
      // For "assoc1.assoc2" and "structelem1.assoc2"
      if (elem._redirected !== null) { // null = already reported
        message( 'rewrite-not-supported', elem.target.location, elem, {},
                 'Warning',
                 'The ON condition is not rewritten here - provide an explicit ON condition' );
      }
      return;
    }
    if (!nav.tableAlias || nav.tableAlias.type) {
      resolveExpr( cond, rewriteExpr, elem, nav.tableAlias );
    }
    else {
      // TODO: support that
      message( null, elem.value.location, elem,
               'Selecting unmanaged associations from a sub query is not supported' );
    }
    cond.$inferred = 'rewrite';
  }

  function rewriteExpr( expr, assoc, tableAlias ) {
    // Rewrite ON condition (resulting in outside perspective) for association
    // 'assoc' in query or including entity from ON cond of mixin element /
    // element in included structure / element in source ref/d by table alias.

    // TODO: re-check args in references, forbid parameter use for the moment
    // TODO: complain about $self (unclear semantics)
    // console.log( message(null, assoc.name.location, assoc,
    //   { names: expr.path.map(i=>i.id) }, 'Info', 'A'))

    if (!expr.path || !expr._artifact)
      return;
    if (!assoc._main)
      return;
    if (tableAlias) { // from ON cond of element in source ref/d by table alias
      const source = tableAlias._finalType && tableAlias._finalType.target &&
            tableAlias._finalType.target._artifact ||
            tableAlias.type._artifact;
      const root = expr.path[0]._navigation || expr.path[0]._artifact;
      // if (root._main !== source)
      // console.log('NO',assoc.name,(root._main ? root._main.name: root.name),source&&source.name)
      if (!root || root._main !== source)
        return;                 // not $self or source element
      const item = expr.path[root.self ? 1 : 0];
      // console.log('YE', assoc.name, item, root.name, expr.path)
      rewritePath( expr, item, assoc,
                   navProjection( item && tableAlias.$navigation[item.id], assoc ),
                   assoc.value.location );
    }
    else if (assoc._main.query) { // from ON cond of mixin element in query
      const nav = pathNavigation( expr );
      if (nav.navigation || nav.tableAlias) { // rewrite src elem, mixin, $self[.elem]
        rewritePath( expr, nav.item, assoc,
                     navProjection( nav.navigation, assoc ),
                     nav.item ? nav.item.location : expr.path[0].location );
      }
    }
    else {                     // from ON cond of element in included structure
      const root = expr.path[0]._navigation || expr.path[0]._artifact;
      if (root.builtin || !root.self && root.kind !== 'element')
        return;
      const item = expr.path[root.self ? 1 : 0];
      if (!item)
        return;                                   // just $self
      const elem = assoc._main.elements[item.id]; // corresponding elem in including structure
      if (!(elem instanceof Array ||              // no msg for redefs
            elem.origin && elem.origin._artifact === item._artifact)) {
        const art = assoc.origin && assoc.origin._artifact;
        message( 'rewrite-shadowed', elem.name.location, elem,
                 { art: art && finalType( art ) },
                 'Warning', {
                   std: 'This element is not originally referred to in the ON condition of association $(ART)',
                   element: 'This element is not originally referred to in the ON condition of association $(MEMBER) of $(ART)',
                 } );
      }
      rewritePath( expr, item, assoc, (elem instanceof Array ? false : elem), null );
    }
  }

  function rewritePath( ref, item, assoc, elem, location ) {
    const { path } = ref;
    let root = path[0];
    if (!elem) {
      if (location) {
        message( 'rewrite-not-projected', location, assoc,
                 { name: assoc.name.id, art: item._artifact }, [ 'Error' ], {
                   std: 'Projected association $(NAME) uses non-projected element $(ART)',
                   element: 'Projected association $(NAME) uses non-projected element $(MEMBER) of $(ART)',
                 } );
      }
      delete root._navigation;
      setProp( root, '_artifact', elem );
      setProp( ref, '_artifact', elem );
      return;
    }
    if (item !== root) {
      root.id = '$self';
      setLink( root, assoc._parent.$tableAliases.$self, '_navigation' );
      setLink( root, assoc._parent );
    }
    else if (elem.name.id.charAt(0) === '$') {
      root = { id: '$self', location: item.location };
      path.unshift( root );
      setLink( root, assoc._parent.$tableAliases.$self, '_navigation' );
      setLink( root, assoc._parent );
    }
    if (!elem.name)      // nothing to do for own $projection, $projection.elem
      return;            // (except having it renamed to $self)
    item.id = elem.name.id;
    let state = null;
    for (const i of path) {
      if (!state) {
        if (i === item)
          state = setLink( i, elem );
      }
      else if (i) {
        state = rewriteItem( state, i, i.id, assoc );
        if (!state || state === true)
          break;
      }
      else {
        return;
      }
    }
    if (state !== true)
      setLink( ref, state );
  }

  function rewriteItem( elem, item, name, assoc, forKeys ) {
    if (!elem._redirected)
      return true;
    for (const alias of elem._redirected) {
      // TODO: a message for the same situation as msg 'rewrite-shadowed'?
      if (alias.$navigation) {
        // TODO: if there is a "multi-step" redirection, we should probably
        // consider intermediate "preferred" elements - not just `assoc`,
        // but its origins, too.
        const proj = navProjection( alias.$navigation[name], assoc );
        name = proj && proj.name && proj.name.id;
        if (!name) {
          if (!forKeys)
            break;
          setLink( item, null );
          message( 'rewrite-undefined-key', weakLocation( (elem.target || elem).location ), assoc,
                   { id: item.id, art: alias._main },
                   (isBetaEnabled( options, 'keyRefError' ) ? [ 'Error' ] : 'Warning'),
                   'Foreign key $(ID) has not been found in target $(ART)' );
          return null;
        }
        item.id = name;
      }
    }
    const env = name && environment(elem);
    elem = setLink( item, env && env[name] );
    if (elem && !(elem instanceof Array))
      return elem;
    // TODO: better (extra message)
    message( 'query-undefined-element', item.location, assoc, { id: name || item.id }, 'Warning',
             'Element $(ID) has not been found in the elements of the query; secondary associations are not fully supported' );
    return (elem) ? false : null;
  }

  //--------------------------------------------------------------------------
  // Phase 8: create transitive localized convenience views (not with errors)
  //--------------------------------------------------------------------------
  //
  // We have three kinds of localized convenience views:
  //
  // 1. "direct ones" using coalesce() for the table entities with localized
  //    elements: as projection on the original (created in definer.js)
  // 2. for table entities with associations to entities which have a localized
  //    convenience views or redirections thereon: as projection on the original
  // 3. for view entities with associations to entities which have a localized
  //    convenience views or redirections thereon: as entity using the same
  //    query as the original, but replacing all sources by their localized
  //    convenience view variant if present
  //
  // Here, we build all 2 and 3 transitively (i.e. as long as an entity has an
  // association which directly or indirectly leads to an entity with localized
  // elements, we create a localied variant for it), and finally make sure via
  // redirection that associatons in localized convenience views have as target
  // the localized convenience view variant if present.

  function createLocalizedTransitive() {
    let arrayOfEntities = [];
    let entities = [];
    forEachDefinition( model, collect );
    // console.log( 'INIT:', entities.map( a => a.name.absolute ) )
    while (entities.length) {
      entities.forEach( create );
      entities = [].concat( ...arrayOfEntities );
      arrayOfEntities = [];
    }
    forEachDefinition( model, rewriteToLocalized );
    return;

    function collect( art ) {
      if (art.kind === 'entity' || art.kind === 'view') {
        if (!art._localized)
          Object.values( art.elements || {} ).forEach( setDep );
        else if (art._localized !== true) // not the localized view itself
          entities.push( art );
        // TODO: check the _texts entity itself if an assoc has been a key
      }
    }

    function setDep( elem ) {
      if (hasTruthyProp( elem, 'localized' )) {
        const origElem = elem.value && elem.value._artifact;
        if (origElem)
        // if (!origElem._main) console.log(origElem)
          pushLink( origElem._main, '_assocSources', elem._main );
      }
      else if (elem.target) {
        pushLink( elem.target._artifact, '_assocSources', elem._main );
        const origTarget = elem.value && elem.value._artifact && elem.value._artifact.target;
        // TODO: re-check implicit redirection to autoexposed in assoc defined as mixin
        if (origTarget && origTarget._artifact !== elem.target._artifact) // if redirected
          pushLink( origTarget._artifact, '_assocSources', elem._main );
      }
      else if (elem.elements) {
        Object.values( elem.elements ).forEach( setDep );
      }
    }

    function create( art ) {
      if (art._assocSources) {
        arrayOfEntities.push( art._assocSources );
        // console.log( 'PUSH:', art.name.absolute, art._assocSources.map( a => a.name.absolute ) )
        art._assocSources = null;
      }
      if (art._localized == null && (!art.abstract || !art.abstract.val))
        // console.log( 'CREATE:', art.name.absolute )
        createLocalizedView( art );
    }
  }

  function createLocalizedView( art ) {
    const viewName = `localized.${ art.name.absolute }`;
    if (model.definitions[viewName]) {
      setLink( art, false, '_localized' ); // blocked
      message( null, art.name.location, art, null, 'Info', 'Convenience view can not be created due to conflicting names' );
      return;                   // skip creation
    }
    const view = (art.query ? createLocalizedViewView : createLocalizedDataView)( art, viewName );
    if (art._service)         // make implicit redirection work
      setLink( view, art._service, '_service' );
    // execute sub phases which have already been executed in general:
    populateView( view );
    propagateKeyProps( view );
    resolveRefs( view );
  }

  function createLocalizedViewView( base, absolute ) {
    const { location } = base.name;
    const view = {
      kind: 'entity',
      name: { location, path: splitIntoPath( location, absolute ) },
      location: base.location,
      '@odata.draft.enabled': booleanAnnotation( location, 'odata.draft.enabled', false ),
      query: copyExpr( base.query, location, true, true ),
      $inferred: 'LOCALIZED-VERTICAL',
    };

    // usually, a "proxy copy" is needed, a "reuse" is ok for localization view
    if (base.params)
      view.params = base.params;

    const artifacts = Object.create(null);
    artifacts[absolute] = view;
    // TODO: support for name.space::Base ?
    initArtifacts( { artifacts }, null, model.$internal, false, '' );
    setLink( base, view, '_localized' );
    setLink( view, true, '_localized' );
    return view;
  }

  function rewriteToLocalized( art ) {
    if (art.$inferred === 'LOCALIZED-VERTICAL') {
      rewritePropToLocalized( art.query );
    }
    else if (art.$inferred === 'LOCALIZED-HORIZONTAL') {
      for (const elem of Object.values( art.elements )) {
        rewritePropToLocalized( elem.target );
        rewritePropToLocalized( elem.onCond );
        rewritePropToLocalized( elem.foreignKeys );
      }
    }
  }

  function rewritePropToLocalized( obj ) {
    if (!obj || typeof obj !== 'object') {
      return;
    }
    else if (obj instanceof Array) {
      obj.forEach( rewritePropToLocalized );
      return;
    }

    for (const prop of Object.getOwnPropertyNames( obj )) {
      const descr = Object.getOwnPropertyDescriptor( obj, prop );
      if (descr.enumerable) {
        rewritePropToLocalized( descr.value );
      }
      else if (descr.value &&
               (prop === '_artifact' || prop === '_navigation' || prop === '_finalType' )) {
        const art = getLocalizedVariant( descr.value );
        if (art) {
          descr.value = art;
          Object.defineProperty( obj, prop, descr );
        }
      }
    }
  }

  function getLocalizedVariant( art ) {
    // just inside queries, no need for `actions`, `params`
    let localized = (art._main || art)._localized;
    if (!localized || localized === true)
      return null;
    const { name } = art;
    if (name.query != null)
      localized = localized.$queries[name.query];
    if (name.alias)
      localized = localized.$tableAliases[name.alias];
    if (!name.element)
      return localized;
    for (const elemName of name.element.split('.')) {
      // if (!localized) { console.log('M:', elemName, name, obj ); return null; }
      const dict = localized.elements || localized.$navigation ||
                   localized.foreignKeys || localized.enum;
      if (!dict)
        // e.g. for bpns.ObjectPermission: struct elem in view, used in ON condition
        return null;            // no proxy sub elements yet
      localized = dict[elemName];
    }
    return localized;
  }

  //--------------------------------------------------------------------------
  // General resolver functions
  //--------------------------------------------------------------------------

  // Resolve the type and its arguments if applicable.
  function resolveTypeExpr( art, user ) {
    const typeArt = resolveType( art.type, user );
    if (!typeArt)
      return;
    resolveTypeArguments(art, typeArt, user);
  }

  function resolveExpr( expr, expected, user, extDict) {
    if (!expr || typeof expr === 'string') // parse error or keywords in {xpr:...}
      return;
    if (expr instanceof Array) {
      expr.forEach( e => resolveExpr( e, expected, user, extDict ) );
    }
    else if (expr.path) {
      if (expected instanceof Function) {
        expected( expr, user, extDict );
        return;
      }
      resolvePath( expr, expected, user, extDict );

      const last = expr.path[expr.path.length - 1];
      for (const step of expr.path) {
        if (step && (step.namedArgs || step.where) &&
            step._artifact && !Array.isArray( step._artifact ) )
          resolveParamsAndWhere( step, expected, user, extDict, step === last );
      }
    }
    else if (expr.op && queryOps[expr.op.val]) {
      if (expr.kind || expr._leadingQuery) { // UNION has _leadingQuery
        traverseQueryPost( expr, false, resolveQuery );
      }
      else {
        message( 'expr-no-subquery', expr.location, user, {},
                 'Error', 'Subqueries are not supported here' );
      }
    }
    else if (expr.op && expr.args) {
      const func = expr.func && expr.func.path && expr.func.path[0].id;
      if (func && func.toUpperCase() === 'ROUND') // TODO: temp?
        resolveExpr( expr.args[0], expected, user, extDict );
      else
        expr.args.forEach( e => resolveExpr( e, expected, user, extDict ) );
    }
  }

  function resolveParamsAndWhere( step, expected, user, extDict, isLast ) {
    const alias = step._navigation && step._navigation.kind === '$tableAlias' && step._navigation;
    const type = alias || finalType( step._artifact );
    const art = type && type.target && type.target._artifact || type;
    if (!art)
      return;
    const entity = (art.kind === 'entity' || art.kind === 'view') && (!isLast || expected === 'from') && art;
    if (step.namedArgs)
      resolveParams( step.namedArgs, art, entity, expected, user, extDict );
    if (!step.where)
      return;

    if (!entity) {
      message( 'expr-no-filter', step.where.location, user, { '#': expected },
               [ 'Error' ], {
                 std: 'A filter can only be provided when navigating along associations',
                 from: 'A filter can only be provided for the source entity or associations',
               } );
    }
    else {
      resolveExpr( step.where, 'filter', user, environment( type ) );
    }
  }

  function resolveParams( dict, art, entity, expected, user, extDict ) {
    if (!entity || !entity.params) {
      let first = dict[Object.keys(dict)[0]];
      if (first instanceof Array)
        first = first[0];
      message( 'args-no-params',
               dictLocation( dict, first && first.name && first.name.location ), user,
               { art, '#': (entity ? 'entity' : expected ) },
               [ 'Error' ], {
                 std: 'Parameters can only be provided when navigating along associations',
                 from: 'Parameters can only be provided for the source entity or associations',
                 // or extra message id for entity?
                 entity: 'Entity $(ART) has no parameters',
               } );
      return;
    }
    const exp = (expected === 'from') ? 'expr' : expected;
    // TODO: allow to specify expected for arguments in in specExpected
    for (const name in dict) {
      const param = art.params[name];
      const arg = dict[name];
      for (const a of (arg instanceof Array) ? arg : [ arg ]) {
        setProp( a.name, '_artifact', param );
        if (!param) {
          message( 'args-undefined-param', a.name.location, user, { art, id: name },
                   [ 'Error' ], 'Entity $(ART) has no parameter $(ID)' );
        }
        resolveExpr( a, exp, user, extDict );
      }
    }
  }
}

function copyExpr( expr, location, skipUnderscored, rewritePath ) {
  if (!expr || typeof expr !== 'object')
    return expr;
  else if (expr instanceof Array)
    return expr.map( e => copyExpr( e, location, skipUnderscored, rewritePath ) );

  const proto = Object.getPrototypeOf( expr );
  if (proto && proto !== Object.prototype) // do not copy object from special classes
    return expr;
  const r = Object.create( proto );
  for (const prop of Object.getOwnPropertyNames( expr )) {
    const pd = Object.getOwnPropertyDescriptor( expr, prop );
    if (!pd.enumerable) { // should include all properties starting with _
      if (!skipUnderscored || prop === '_artifact' || prop === '_navigation' || prop === '_finalType')
        Object.defineProperty( r, prop, pd );
    }
    else if (!proto) {
      r[prop] = copyExpr( pd.value, location, skipUnderscored, rewritePath );
    }
    else if (prop === 'location') {
      r[prop] = location || pd.value;
    }
    else if ((prop.charAt(0) !== '$' && prop !== 'annotationAssignments') || prop === '$inferred') {
      // TODO: rename to $annotationAssignments
      r[prop] = copyExpr( pd.value, location, skipUnderscored, rewritePath );
    }
    else if (!skipUnderscored) {  // skip $ properties
      Object.defineProperty( r, prop, pd );
    }
  }
  return r;
}

function testExpr( expr, pathTest, queryTest ) {
  // TODO: also check path arguments/filters
  if (!expr || typeof expr === 'string') // parse error or keywords in {xpr:...}
    return false;
  else if (expr instanceof Array)
    return expr.some( e => testExpr( e, pathTest, queryTest ) );
  else if (expr.path)
    return pathTest( expr );
  else if (expr.op && queryOps[expr.op.val])
    return queryTest( expr );
  else if (expr.op && expr.args)
    return expr.args.some( e => testExpr( e, pathTest, queryTest ) );
  return false;
}

// Return true if the path `item` with a final type `assoc` has a max target
// cardinality greater than one - either specified on the path item or assoc type.
function targetMaxNotOne( assoc, item ) {
  // Semantics of associations without provided cardinality: [*,0..1]
  const cardinality = item.cardinality || assoc.cardinality;
  return cardinality && cardinality.targetMax && cardinality.targetMax.val !== 1;
}

// Return condensed info about reference in select item
// - tableAlias.elem       -> { navigation: navElem, item: path[1], tableAlias }
// - sourceElem (in query) -> { navigation: navElem, item: path[0], tableAlias }
// - mixinElem             -> { navigation: mixinElement, item: path[0] }
// - $projection.elem      -> also $self.item -> { item: path[1], tableAlias: $self }
// - $self                 -> { item: undefined, tableAlias: $self }
// - $parameters.P, :P     -> {}
// - $now, current_date    -> {}
// - undef, redef          -> {}
// With 'navigation': store that navigation._artifact is projected
// With 'navigation': rewrite its ON condition
// With navigation: Do KEY propagation
function pathNavigation( ref ) {
  // currently, indirectly projectable elements are not included - we might
  // keep it this way!  If we want them to be included - be aware: cycles
  if (!ref._artifact)
    return {};
  let item = ref.path && ref.path[0];
  const root = item && item._navigation;
  if (!root)
    return {};
  if (root.kind === '$navElement')
    return { navigation: root, item, tableAlias: root._parent };
  if (root.name.$mixin)
    return { navigation: root, item };
  item = ref.path[1];
  if (root.self)
    return { item, tableAlias: root };
  if (root.kind !== '$tableAlias' || ref.path.length < 2)
    return {};                // should not happen
  return { navigation: root.$navigation[item.id], item, tableAlias: root };
}

function navProjection( navigation, preferred ) {
  // TODO: Info if more than one possibility?
  // console.log(navigation,navigation._projections)
  if (!navigation)
    return {};
  else if (!navigation._projections)
    return null;
  return (preferred && navigation._projections.includes( preferred ))
    ? preferred
    : navigation._projections[0] || null;
}

// Query tree post-order traversal - called for everything which makes a query
// except "real ones": operands of UNION etc, JOIN with ON, and sub queries in FROM
function traverseQueryPost( query, simpleOnly, callback ) {
  // console.log( msgName(query), query.name.query );
  while (query instanceof Array) // query in parentheses
    query = query[0];
  if (!query || !query.op)      // parser error or just path
    return;
  if (simpleOnly) {
    if (!query.from || query.from.length !== 1)
      return;                   // UNION or FROM a,b -> not simple
    let from = query.from[0];
    while (from instanceof Array)
      from = from[0];
    if (!from || from.join)     // parse error or join
      return;
  }
  if (query.from) {             // SELECT
    for (const q of query.from)
      traverseQueryPost( q, simpleOnly, callback );
    callback( query );
  }
  else if (query.args) {             // JOIN, UNION, INTERSECT
    for (const q of query.args)
      traverseQueryPost( q, simpleOnly, callback );
    if (query.on)
      callback( query );
  }
  // else: with parse error (`select from <EOF>`, `select distinct from;`)
}

function pushLink( obj, prop, value ) {
  const p = obj[prop];
  if (p)
    p.push( value );
  else
    Object.defineProperty( obj, prop, { value: [ value ], configurable: true, writable: true } );
}

module.exports = resolve;
