// Compiler functions and utilities shared across all phases


'use strict';

const { isBetaEnabled } = require('../base/model');
const { searchName, getMessageFunction } = require('../base/messages');
const { addToDict, addToDictWithIndexNo, pushToDict } = require('../base/dictionaries');

const dictKinds = {
  definitions: 'absolute',
  elements: 'element',
  enum: 'enum',
  foreignKeys: 'key',
  actions: 'action',
  params: 'param',
};

const kindProperties = {
  // TODO: also foreignKeys ?
  namespace: { artifacts: true }, // on-the-fly context
  context: { artifacts: true, normalized: 'namespace' },
  service: { artifacts: true, normalized: 'namespace' }, // actions: true with "service-bound" actions
  entity: { elements: true, actions: true, params: () => false },
  view: { elements: true, actions: true, params: () => false },
  query: { elements: true },
  $tableAlias: { normalized: 'alias', $navigation: true }, // table alias in select
  $navElement: { normalized: 'element', $navigation: true },
  event: { elements: true },
  type: { elements: propExists, enum: propExists },
  annotation: { elements: propExists, enum: propExists },
  const: {},
  enum: { normalized: 'element' },
  element: { elements: propExists, enum: propExists, dict: 'elements' },
  action: {
    params: () => false, elements: () => false, enum: () => false, dict: 'actions',
  }, // no extend params, only annotate
  function: {
    params: () => false, elements: () => false, enum: () => false, normalized: 'action',
  }, // no extend params, only annotate
  key: { normalized: 'element' },
  param: { elements: () => false, enum: () => false, dict: 'params' },
  source: { artifacts: true },
  block: { artifacts: true },
  using: {},
  extend: {
    isExtension: true,
    noDep: 'special',
    elements: true, /* only for parse-cdl */
    actions: true,  /* only for parse-cdl */
  },
  annotate: {
    isExtension: true, noDep: 'special', elements: true, enum: true, actions: true, params: true,
  },
  builtin: {},                  // = CURRENT_DATE, TODO: improve
  $parameters: {},              // $parameters in query entitis
};

function propExists( prop, parent ) {
  const obj = parent.returns || parent;
  return (obj.items || obj)[prop];
}

function artifactsEnv( art ) {
  return art.artifacts || Object.create(null);
}

/**
 * Main export function of this file.  Return "resolve" functions shared for phase
 * "define" and "resolve".  Argument `model` is the augmented CSN.  Optional
 * argument `environment` is a function which returns the search environment
 * defined by its argument - it defaults to the dictionary of subartifacts of
 * the argument.
 *
 * @param {XSN.Model} model
 * @param {(a, b?, c?) => any} environment
 * @returns {object} Commonly used "resolve" functions.
 */
function fns( model, environment = artifactsEnv ) {
  const options = model.options || {};
  const message = getMessageFunction( model );
  // TODO: combine envFn and assoc ?
  const specExpected = {
    annotation: { useDefinitions: true, noMessage: true },
    extend: { useDefinitions: true, envFn: artifactsEnv }, // ref in top-level EXTEND
    annotate: {
      useDefinitions: true, envFn: artifactsEnv, undefinedDef: 'anno-undefined-def', undefinedArt: 'anno-undefined-art',
    },
    type: { reject: rejectNonType }, // TODO: more detailed later (e.g. for enum base type?)
    // if we want to disallow assoc nav for TYPE, do not do it her
    typeOf: { next: '_$next' },
    include: { reject: rejectNonStruct, envFn: artifactsEnv },
    context: { reject: rejectNonContext, envFn: artifactsEnv },
    target: { reject: rejectNonEntity, noDep: true, envFn: artifactsEnv },
    compositionTarget: { reject: rejectNonTarget, noDep: true, envFn: artifactsEnv },
    // TODO: dep for (explicit+implicit!) foreign keys
    element: { next: '__none_' },  // TODO: something for technical config - re-think
    targetElement: { next: '__none_', assoc: false },
    filter: { next: '_$next', lexical: 'main' },
    from: { reject: rejectNonSource, assoc: 'from', argsSpec: 'expr' },
    const: { next: '_$next', reject: rejectNonConst },
    expr: {
      next: '_$next', escape: 'param', assoc: 'nav',
    },
    on: {               // TODO: there will also be a 'from-on'
      escape: 'param',          // meaning of ':' in front of path?  search in 'params'
      next: '_$next',           // TODO: lexical: ... how to find the (next) lexical environment
      rootEnv: 'elements',      // the final environment for the path root
      noDep: true,              // do not set dependency for circular-check
    }, // TODO: special assoc for only on user
    'mixin-on': {
      escape: 'param',          // meaning of ':' in front of path?  search in 'params'
      next: '_$next',           // TODO: lexical: ... how to find the (next) lexical environment
      noDep: true,              // do not set dependency for circular-check
    }, // TODO: special assoc for only on user
    rewrite: {
      next: '_$next', escape: 'param', noDep: true, rewrite: true,
    }, // TODO: assertion that there is no next/escape used
    'order-by-union': {
      next: '_$next', escape: 'param', noDep: true, noExt: true,
    },
    // expr TODO: better - on condition for assoc, other on
    // expr TODO: write dependency, but care for $self
    param: { reject: rejectNonConst },
    global: { useDefinitions: true, global: true }, // for using declaration
  };

  return {
    resolveUncheckedPath,
    resolvePath,
    resolveTypeArguments,
    defineAnnotations,
  };

  // TODO: for reject, distinguish between "completely wrong", i.e. assoc
  // target is no struct, and "rejected"; the former have _artifact: null, the
  // latter the referred one.
  function rejectNonConst( art ) {
    return [ 'builtin', 'param', 'const' ].includes( art.kind ) ? undefined : 'expected-const';
  }

  function rejectNonStruct( art ) {
    return ([ 'type', 'entity' ].includes( art.kind ) && art.elements && !art.query && !art.params)
      ? undefined
      : 'expected-struct';
  }

  function rejectNonContext( art ) {
    return ([ 'context', 'service' ].includes( art.kind ))
      ? undefined
      : 'expected-context';
  }

  function rejectNonType( art ) {
    return ([ 'type', 'entity', 'view' ].includes( art.kind ) ||
            // art.kind === 'type' || // too strong for positive/BoundFunctions
            // art._main && art._main.kind === 'type')  // currently too strong
            art._main && [ 'type', 'entity', 'view' ].includes( art._main.kind ))
      ? undefined
      : 'expected-type';
  }

  function rejectNonEntity( art ) {
    return ([ 'view', 'entity' ].includes( art.kind ) && !(art.abstract && art.abstract.val))
      ? undefined
      : 'expected-entity';
  }

  function rejectNonTarget( art ) {
    return (isBetaEnabled( options, 'aspectCompositions' ) &&
            // TODO: delete 'abstract', proper kind: 'aspect'
            (art.kind === 'type' || art.kind === 'entity' && art.abstract && art.abstract.val))
      ? rejectNonStruct( art )
      : rejectNonEntity( art );
  }

  function rejectNonSource( art, path ) {
    if ([ 'view', 'entity' ].includes( art.kind ))
      return (art.abstract && art.abstract.val) ? 'expected-source' : undefined;
    const main = [ ...path ].reverse().find( item => !item._artifact._main )._artifact;
    // TODO: better error location if error for main
    if (![ 'view', 'entity' ].includes( main.kind ) || main.abstract && main.abstract.val)
      return 'expected-source';  // orig: 'A source must start at an entity, projection or view';
    environment( art );           // sets _finalType on art
    return (!art._finalType || art._finalType.target)
      ? undefined
      : 'expected-source';      // orig: 'The path must end with an association'
  }

  // Return absolute name for unchecked path `ref`.  We first try searching for
  // the path root starting from `env`.  If it exists, return its absolute name
  // appended with the name of the rest of the path and set `ref.absolute` to
  // the return value.  Otherwise, complain if `unchecked` is false, and set
  // `ref.absolute` to the path name of `ref`.
  // Used for collecting artifact extension, and annotation assignments.
  function resolveUncheckedPath( ref, expected, user ) {
    if (!ref.path || ref.path.broken) // incomplete type AST
      return undefined;
    const spec = specExpected[expected];
    let art = (ref.scope === 'global' || spec.global)
      ? getPathRoot( ref.path, spec, user, {}, model.definitions )
      : getPathRoot( ref.path, spec, user, user._block, null, true );
    if (art === false)          // redefinitions
      art = ref.path[0]._artifact[0]; // array stored in head's _artifact
    else if (!art)
      return (spec.useDefinitions) ? pathName( ref.path ) : null;
    // art can be using proxy...
    if (ref.path.length > 1)
      return `${ art.name.absolute }.${ pathName( ref.path.slice(1) ) }`;
    return art.name.absolute;
  }

  // Return artifact or element referred by the path in `ref`.  The first
  // environment we search in is `env`.  If no such artifact or element exist,
  // complain with message and return `undefined`.  Record a dependency from
  // `user` to the found artifact if `user` is provided.
  function resolvePath( ref, expected, user, extDict, msgArt ) {
    if (ref == null)       // no references -> nothing to do
      return undefined;
    if ('_artifact' in ref)     // also true for _artifact: undefined
      return ref._artifact;
    if (!ref.path || ref.path.broken || !ref.path.length) {
      // incomplete type AST or empty env (already reported)
      return setLink( ref, undefined );
    }
    setLink( ref, 0 );   // avoid cycles for  type T: association to T.m;

    let spec = specExpected[expected];
    const { path } = ref;
    const head = path[0];
    // message(null,head.location,{art:user,expected, id: head.id},
    //   'Info','User $(ART), $(EXPECTED) $(ID)')
    let env = user._block;     // artifact references: block

    if (ref.scope === 'param') {
      if (!spec.escape) {
        const variant = (env.$frontend && env.$frontend !== 'cdl') ? 'std' : 'cdl';
        message( 'ref-unexpected-scope', head.location, user, { name: head.id, '#': variant },
                 'Error', {
                   std: 'Unexpected parameter scope for name $(NAME)',
                   cdl: 'Unexpected `:` before name $(NAME)',
                 } );
        return setLink( ref, null );
      }
      spec = specExpected[spec.escape];
      // In queries and query entities, the first lexical search environment
      // are the parameters, otherwise the block.  It is currently ensured that
      // _block in queries is the same as _block of the query entity:
      const lexical = (user._main || user).$tableAliases; // queries (but also query entities)
      env = lexical && lexical.$parameters || user._block;
      extDict = null;           // let getPathRoot() choose it
    }
    else if (spec.next === '__none_') {
      env = {};
    }
    else if (spec.next) {       // TODO: combine spec.next / spec.lexical to spec.lexical
      // TODO: SIMPLIFY this function
      // eslint-disable-next-line no-nested-ternary
      const query = (spec.lexical === 'main')
        ? user._main      // in path filter, just $magic (and $parameters)
        : (user.kind === 'query')
          ? user
          : user._parent && user._parent.kind === 'query' && user._parent;
      env = (spec.lexical === 'from') ? query._parent : query || user._main || user;
      // queries: first tabaliases, then $magic - value refs: first $self, then $magic
      if (!extDict && !spec.noExt) {
        extDict = query && spec.rootEnv !== 'elements' && query.$combined ||
                  environment( user._main ? user._parent : user );
      }
    }

    // 'global' for CSN later in value paths, CDL for Association/Composition:
    let art = (ref.scope === 'global' || spec.global)
      ? getPathRoot( path, spec, user, {}, model.definitions )
      : getPathRoot( path, spec, user, env, extDict, msgArt || 0 );
    if (!art) {
      return setLink( ref, art );
    }
    else if (art.kind === 'using') {
      art = model.definitions[art.name.absolute];
      if (!art)
        return setLink( ref, art );
      else if (art instanceof Array) // redefined art referenced by using proxy
        return setLink( ref, false );
      setLink( head, art );     // we do not want to see the using
    }
    else if (art.name.$mixin) { // TODO: art.kind === 'mixin'
      // console.log(message( null, art.location, art, {}, 'Info','MIX').toString())
      setLink( head, art, '_navigation' );
    }
    else if (art.kind === '$navElement') {
      // console.log(message( null, art.location, art, {}, 'Info','NE').toString())
      setLink( head, art, '_navigation' );
      setLink( head, art.origin._artifact );
      setXref( head._artifact, user, head );
    }
    else if (art.kind === '$tableAlias') {
      setLink( head, art, '_navigation' );
      // console.log( message( null, art.location, art,
      //     {type: art.type, target: art._finalType && art._finalType.target},
      //     'Info','NAV').toString())
      // TODO: probable better set the _artifact link of FROM.assoc to target!
      if (art.type) {           // FROM reference
        const assoc = art._finalType && art._finalType.target;
        art = setLink( head, assoc ? assoc._artifact : art.type._artifact );
        if (!art)
          return setLink( ref, art );
      }
      else {                    // FROM subquery, $projection, $self
        setLink( head, art._finalType ); // the query (sub or self)
      }
    }

    art = getPathItem( path, spec, user );
    if (!art)
      return setLink( ref, art );

    if (art.$autoElement) {
      const { location } = path[path.length - 1];
      const step = { id: art.$autoElement, $inferred: '$autoElement', location };
      art = art.elements[step.id];
      setLink( step, art );
      path.push( step );
    }
    if (spec.reject) {
      const msg = spec.reject( art, path );
      if (msg) {
        signalNotFound( msg, ref.location, user );
        return setLink( ref, false );
      }
    }
    if (user && !spec.noDep) {
      const { location } = ref; // || combinedLocation( head, path[tail.length] );
      // TODO: location of last path item if not main artifact
      if (!user._deps)
        setProp( user, '_deps', [] );
      if (!art._main || spec.assoc !== 'from') {
        user._deps.push( { art, location } );
      }
      else {
        user._deps.push( { art: art._main, location } );
        environment( art, location, user );
      // Without on-demand resolve, we can simply signal 'undefined "x"'
      // instead of 'illegal cycle' in the following case:
      //    element elem: type of elem.x;
      }
    }
    return setLink( ref, art );
  }

  // Resolve the type arguments provided with a type referenced for artifact or
  // element `artifact`.  This function does nothing if the referred type
  // `typeArtifact` does not have a `parameters` property (currently, only
  // builtin-types have it, see ./builtins.js).
  //
  // For each property name `<prop>` in `typeArtifact.parameters`, we move a number
  // in art.typeArguments (a vector of numbers with locations) to `artifact.<prop>`.
  // TODO: error if no parameters applicable
  // TODO: also check for number
  function resolveTypeArguments(artifact, typeArtifact, user) {
    const args = artifact.typeArguments || [];
    const parameters = typeArtifact.parameters || [];
    const parLength = parameters.length;

    for (let i = 0; i < parLength; ++i) {
      let par = parameters[i];
      if (!(par instanceof Object))
        par = { name: par };
      if (!artifact[par.name] && (i < args.length || par.literal)) {
        const { location } = artifact.type;
        artifact[par.name] = args[i] || {
          literal: par.literal, val: par.val, location, $inferred: 'type-param',
        };
      }
    }
    if (args.length > parLength) {
      artifact.typeArguments = artifact.typeArguments.slice(parLength);
      message( 'unexpected-type-arg', artifact.typeArguments[0].location,
               user, { art: typeArtifact },
               'Warning', 'Too many arguments for type $(ART)' );
    }
    else if (artifact.typeArguments) {
      delete artifact.typeArguments;
    }
  }

  // Set a cross-reference from the 'user' in artifact 'art'
  // 'user' is a navigatable node, while 'where' gives a closer hint (e.g. an item in a path)
  // For example in 'a.b.c as d' the definition of b gets a xref object  with user d and where = b
  function setXref(art, user, where = user) {
    if (!user)
      return;
    if (!art._xref)
      setProp( art, '_xref', [] );
    // if (!art._xref.includes(user))
    //  art._xref.push(user);
    art._xref.push( { user, where } );
  }

  function transformMagicName( name ) {
    // TODO: store magic variable in lower case (nicer for code completion)
    return (name === 'self' || name.charAt(0) === '$') ? name : name.toUpperCase();
  }

  // Return artifact or element referred by name `head`.  The first environment
  // we search in is `env`.  If `unchecked` is equal to `true`, do not report an error
  // if the artifact does not exist.  Return a "fresh" artifact for
  // non-existing external using references if `unchecked` is truthy.
  function getPathRoot( path, spec, user, env, extDict, msgArt ) {
    const head = path[0];
    if (!head || !head.id || !env)
      return undefined;         // parse error
    // if head._artifact is set or is null then it was already computed once
    if ('_artifact' in head)
      return (head._artifact instanceof Array) ? false : head._artifact;
    // console.log(pathName(path), !spec.next && !extDict &&
    //   (spec.useDefinitions || env.$frontend === 'json' || env))
    if (!spec.next && !extDict) {
      // CSN artifact paths are always fully qualified so we use
      // model.definitions for the JSON frontend.
      extDict = (spec.useDefinitions || env.$frontend && env.$frontend !== 'cdl')
        ? model.definitions
        : model.$builtins;
    }
    const nextProp = spec.next || '_block';
    for (let art = env; art; art = art[nextProp]) {
      const e = art.artifacts || art.$tableAliases || Object.create(null);
      const r = (art.kind !== '$magicVariables')
        ? e[head.id]
      // do not find magic variables if quoted:
        : (!head.quoted) && e[transformMagicName( head.id )];
      if (r) {
        if (r instanceof Array) { // redefinitions
          setLink( head, r );
          return false;
        }
        else if (r.kind === 'block') {
          return setLink( head, r.name._artifact );
        }
        else if (r.kind === '$parameters') {
          if (!head.quoted && path.length > 1) {
            message( 'ref-obsolete-parameters', head.location, user,
                     { code: `$parameters.${ path[1].id }`, newcode: `:${ path[1].id }` },
                     [ 'Error' ], 'Obsolete $(CODE) - replace by $(NEWCODE)' );
            // TODO: replace it in to-csn correspondingly
            return setLink( head, r );
          }
        }
        else if (r.kind !== '$tableAlias' ||
                 (r.self ? !head.quoted : path.length > 1)) {
        // except $self if quoted, or "real" table aliases (not $self) with path len 1
        // TODO: $projection only if not quoted _and_ length > 1
          return setLink( head, r );
        }
      }
    }
    if (extDict) {
      const r = extDict[head.id];
      if (r instanceof Array) {
        if (r[0].kind === '$navElement') {
          const names = r.filter( e => !e.$duplicate)
            .map( e => `${ e.name.alias }.${ e.name.element }` );
          if (names.length) {
            message( 'ref-ambiguous', head.location, user, { id: head.id, names },
                     'Error', 'Ambiguous $(ID), replace by $(NAMES)' );
          }
        }
        setLink( head, r );
        return false;
      }
      else if (r) {
        return setLink( head, r );
      }
    }
    if (spec.noMessage || msgArt === true && extDict === model.definitions)
      return setLink( head, null );

    const valid = [];
    for (let art = env; art; art = art[nextProp]) {
      const e = art.artifacts || art.$tableAliases || Object.create(null);
      valid.push( e );
    }
    if (extDict) {
      const e = Object.create(null);
      // the names of the external dictionary are valid, too, except duplicate
      // navigation elements (for which you should use a table alias)
      if (extDict !== model.definitions) {
        for (const name in extDict) {
          const def = extDict[name];
          if (!(def instanceof Array && def[0].kind === '$navElement'))
            e[name] = def;
        }
      }
      else {
        for (const name in extDict) {
          if (!name.includes('.'))
            e[name] = extDict[name];
        }
      }
      valid.push( e );
    }

    if (spec.next) {            // value ref
      // TODO: if not in query, specify where we search for elements and delete env.$msg
      // TODO: also something special if it starts with '$'
      if (msgArt) {
        signalNotFound( 'ref-undefined-element', head.location, user, valid,
                        { art: searchName( msgArt, head.id, 'element' ) } );
      }
      else {
        signalNotFound( 'ref-undefined-var', head.location, user, valid, { id: head.id },
                        'Error', 'Element or variable $(ID) has not been found' );
      }
    }
    else if (env.$frontend && env.$frontend !== 'cdl' || spec.global) {
    // IDE can inspect <model>.definitions - provide null for valid
      signalNotFound( spec.undefinedDef || 'ref-undefined-def', head.location, user, valid,
                      { art: head.id } );
    }
    else {
      signalNotFound( spec.undefinedArt || 'ref-undefined-art', head.location, user, valid,
                      { name: head.id } );
    }
    return setLink( head, null );
  }

  // Return artifact or element referred by path (array of ids) `tail`.  The
  // search environment (for the first path item) is `arg`.  For messages about
  // missing artifacts (as opposed to elements), provide the `head`(first
  // element item in the path)
  function getPathItem( path, spec, user ) {
    let art;
    let nav = spec.assoc !== '$keys' && null; // false for '$keys'
    const last = path[path.length - 1];
    for (const item of path) {
      if (!item || !item.id)    // incomplete AST due to parse error
        return undefined;
      if (item._artifact) {     // should be there on first path element
        art = item._artifact;
        if (art instanceof Array)
          return false;
      }
      else {
        const env = (spec.envFn || environment)( art, item.location, user, spec.assoc );
        const sub = setLink( item, env && env[item.id] );
        if (!sub)
          return (sub === 0) ? 0 : error( item, env );
        else if (sub instanceof Array) // redefinitions
          return false;

        if (nav) {              // we have already "pseudo-followed" a managed association
          // We currently rely on the check that targetElement references do
          // not (pseudo-) follow associations, otherwise potential redirection
          // there had to be considered, too.  Also, fk refs to sub elements in
          // combinations with redirections of the target which directly access
          // the potentially renamed sub elements would be really complex.
          // With our restriction, no renaming must be considered for item.id.
          nav = setTargetReferenceKey( item.id, item );
        }
        // Now set an _navigation link for managed assocs in ON condition etc
        else if (art && art.target && nav != null) {
          // Find the original ref for sub and the original foreign key
          // definition.  This way, we do not need the foreign keys with
          // rewritten target element path, which might not be available at
          // this point (rewriteKeys in Resolver Phase 5).  If we want to
          // follow associations in foreign key definitions, rewriteKeys must
          // be moved to the on-demand Resolver Phase 2.
          let orig;             // for the original target element
          for (let o = sub; o; o = o.value && o.value._artifact)
            orig = o;
          nav = (orig._finalType || orig).$keysNavigation;
          nav = setTargetReferenceKey( orig.name.id, item );
        }
        art = sub;
        setXref( art, user, item );
      }
    }
    return art;

    function setTargetReferenceKey( id, item ) {
      const node = nav && nav[id];
      nav = null;
      if (node) {
        if (node._artifact) {
          // set the original(!) foreign key for the assoc - the "right" ones
          // after rewriteKeys() is the one with the same name.id
          setLink( item, node._artifact, '_navigation' );
          if (item === last)
            return;
        }
        else if (item !== last) {
          nav = node.$keysNavigation;
          return;
        }
      }
      message( null, item.location, user, {}, 'Error',
               'You cannot follow associations other than to elements referred to in a managed association\'s key' );
    }

    function error( item, env ) {
      if (!spec.next) {         // artifact ref
        // TODO: better for TYPE OF, FROM e.Assoc (even disallow for other refs)
        signalNotFound( spec.undefinedDef || 'ref-undefined-def', item.location, user,
                        [ env ], { art: searchName( art, item.id, spec.envFn && 'absolute' ) } );
      }
      else if (art.name.query) {
        // TODO: 'The current query has no element $(MEMBER)' with $self.MEMBER
        // and 'The sub query for alias $(ALIAS) has no element $(MEMBER)'
        // TODO: probably not extra messageId, but text variant
        // TODO: views elements are proxies to query-0 elements, not the same
        signalNotFound( 'query-undefined-element', item.location, user,
                        [ env ], { id: item.id }, 'Error',
                        'Element $(ID) has not been found in the elements of the query' );
      }
      else if (art.kind === '$parameters') {
        signalNotFound( 'ref-undefined-param', item.location, user,
                        [ env ], { art: searchName( art._main, item.id, 'param' ) },
                        'Error', { param: 'Entity $(ART) has no parameter $(MEMBER)' } );
      }
      else {
        signalNotFound( 'ref-undefined-element', item.location, user,
                        [ env ], { art: searchName( art, item.id ) } );
      }
      return null;
    }
  }

  function signalNotFound( msgId, location, home, valid, ...args ) {
    // if (!location) console.log(msgId, valid, ...args)
    if (location.$notFound)
      return;
    location.$notFound = true;
    /** @type {object} */
    const err = message( msgId, location, home, ...args );
    // console.log( Object.keys( Object.assign( Object.create(null), ...valid.reverse() ) ) )
    if (valid && (options.attachValidNames || options.testMode))
      err.validNames = Object.assign( Object.create(null), ...valid.reverse() );
    // TODO: remove internal, i.e. cds.Association
    if (options.testMode && valid) {
      const names = Object.keys( err.validNames );
      message( null, location, null,
               names.length ? `Valid: ${ names.sort().join(', ') }` : 'No valid names',
               'Info' );
    }
  }

  // Resolve all annotation assignments for the node `art`.  Set `art.@` to all
  // flattened assignments.  This function might issue error message for
  // duplicate assignments.
  // TODOs:
  // * do something for extensions by CSN or Properties parsers
  // * make sure that we do not issue repeated warnings due to flattening if an
  //   annotation definition is missing
  function defineAnnotations( construct, art, block, priority ) {
    // TODO: block should be construct._block
    if (construct.annotationAssignments && construct.annotationAssignments.doc )
      art.doc = construct.annotationAssignments.doc;
    if (!construct.annotationAssignments || !construct.annotationAssignments.length) {
      if (construct === art)
        return;
      for (const annoProp in construct) {
        if (annoProp.charAt(0) === '@') {
          let annos = construct[annoProp];
          if (!(annos instanceof Array))
            annos = [ annos ];
          for (const a of annos) {
            setProp( a, '_block', block );
            addToDict( art, annoProp, a );
          }
        }
      }
      return;
    }
    for (const anno of construct.annotationAssignments) {
      const ref = anno.name;
      const name = resolveUncheckedPath( ref, 'annotation', { _block: block } );
      const annoProp = (anno.name.variant)
        ? `@${ name }#${ anno.name.variant.id }`
        : `@${ name }`;
      flatten( ref.path, annoProp, anno.value || {}, anno.name.variant, anno.name.location );
    }
    return;

    function flatten( path, annoProp, value, iHaveVariant, location ) {
      // Be robust if struct value has duplicate element names
      if (value instanceof Array) // TODO: do that differently in CDL parser
        return;                 // discard duplicates in flattened form

      if (value.literal === 'struct') {
        for (const item of value._struct || []) {
          let prop = pathName(item.name.path);
          if (item.name.variant) {
            if (iHaveVariant) {
              message( 'anno-duplicate-variant', item.name.variant.location, construct, {}, // TODO: params
                       'Error', 'Annotation variant has been already provided' );
            }
            prop = `${ prop }#${ item.name.variant.id }`; // TODO: check for double variants
          }
          flatten( [ ...path, ...item.name.path ], `${ annoProp }.${ prop }`, item, iHaveVariant || item.name.variant);
        }
        for (const prop in value.struct) {
          const item = value.struct[prop];
          flatten( [ ...path, item.name ], `${ annoProp }.${ prop }`, item, iHaveVariant );
        }
        return;
      }
      const anno = Object.assign( {}, value ); // shallow copy
      anno.name = {
        path,
        location: location ||
          value.name && value.name.location ||
          value.path && value.path.location,
      };
      if (priority)
        anno.priority = priority;
      setProp( anno, '_block', block );
      // TODO: _parent, _main is set later (if we have ElementRef), or do we
      // set _artifact?
      setAnnotation( art, annoProp, anno, priority );
    }
  }

  function setAnnotation( art, annoProp, anno, priority = 'define') {
    anno.priority = priority;
    addToDict( art, annoProp, anno );
  }
}

// Return string 'A.B.C' for parsed source `A.B.C` (is vector of ids with
// locations):
function pathName(path) {
  return (path.broken) ? '' : path.map( id => id.id ).join('.');
}

// Like `obj.prop = value`, but not contained in JSON / CSN
function setProp( obj, prop, value ) {
  Object.defineProperty( obj, prop, { value, configurable: true, writable: true } );
  return value;
}

// The link (_artifact,_finalType,...) usually has the artifact as value.
// Falsy values are:
// - undefined: not computed yet, parse error, no ref
// - null: no valid reference, param:true if that is not allowed
// - false (only complete ref): multiple definitions, rejected
// - 0 (for _finalType only): circular reference
function setLink( obj, value = null, prop = '_artifact' ) {
  Object.defineProperty( obj, prop, { value, configurable: true, writable: true } );
  return value;
}

function linkToOrigin( origin, name, parent, prop, location ) {
  const elem = {
    name: { location: location || origin.name.location, id: origin.name.id },
    kind: origin.kind,
    origin: { location },
    location: location || origin.location,
  };
  if (origin.name.$inferred)
    elem.name.$inferred = origin.name.$inferred;
  if (parent)
    setMemberParent( elem, name, parent, prop ); // TODO: redef in template
  setProp( elem.origin, '_artifact', origin );
  // TODO: make this just elem._origin, remove elem.origin
  return elem;
}

function setMemberParent( elem, name, parent, prop ) {
  if (prop) {              // extension or structure include
    // TODO: consider ARRAY OF and RETURNS, COMPOSITION OF type
    if (!(prop in parent))
      parent[prop] = Object.create(null);
    addToDictWithIndexNo( parent, prop, name, elem );
  }
  if (parent._outer)
    parent = parent._outer;
  setProp( elem, '_parent', parent );
  setProp( elem, '_main', parent._main || parent );
  elem.name.absolute = elem._main.name.absolute;
  if (name == null)
    return;
  const normalized = kindProperties[elem.kind].normalized || elem.kind;
  [ 'element', 'alias', 'query', 'param', 'action' ].forEach( ( kind ) => {
    if (normalized === kind)
      elem.name[kind] = (parent.name[kind] != null && kind !== 'query') ? `${ parent.name[kind] }.${ name }` : name;

    else if (parent.name[kind] != null)
      elem.name[kind] = parent.name[kind];

    else
      delete elem.name[kind];
  });
  // try { throw new Error('Foo') } catch (e) { elem.name.stack = e; };
}

function storeExtension( elem, name, prop, parent, block ) {
  if (prop === 'enum')
    prop = 'elements';
  setProp( elem, '_block', block );
  const kind = `_${ elem.kind }`; // _extend or _annotate
  if (!parent[kind])
    setProp( parent, kind, {} );
  if (!parent[kind][prop])
    parent[kind][prop] = Object.create(null);
  pushToDict( parent[kind][prop], name, elem );
}

/** @type {(a: any, b: any) => boolean} */
const testFunctionPlaceholder = () => true;

// Return path step if the path navigates along an association whose final type
// satisfies function `test`; "navigates along" = last path item not considered
// without truthy optional argument `alsoTestLast`.
function withAssociation( ref, test = testFunctionPlaceholder, alsoTestLast ) {
  for (const item of ref.path || []) {
    const art = item && item._artifact; // item can be null with parse error
    if (art && art._finalType && art._finalType.target && test( art._finalType, item ))
      return (alsoTestLast || item !== ref.path[ref.path.length - 1]) && item;
  }
  return false;
}

module.exports = {
  dictKinds,
  kindProperties,
  fns,
  setLink,
  linkToOrigin,
  setMemberParent,
  storeExtension,
  withAssociation,
};
