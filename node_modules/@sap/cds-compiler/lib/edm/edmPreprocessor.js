'use strict';
/* eslint max-statements-per-line:off */
const { setProp } = require('../base/model');
const { forEachDefinition, isEdmPropertyRendered, forEachMemberRecursively, getUtils, cloneCsn } = require('../model/csnUtils');
const alerts = require('../base/alerts');
const edmUtils = require('./edmUtils.js')

const {
  intersect,
  validateOptions,
  foreach,
  forAll,
  isAssociationOrComposition,
  isComposition,
  isStructuredArtifact,
  isParameterizedEntityOrView,
  isActionOrFunction,
  getReferentialConstraints,
} = require('./edmUtils.js');


/**
 *  edmPreprocessor warms up the model so that it can be converted into an EDM document and
 *  contains all late & application specific model transformations
 *  that should NOT become persistent in the published CSN model but only
 *  be presented in the resulting EDM files. These late tweaks or mods can
 *  be dependent to EDM version.
 *
 * @param {CSN.Model} csn
 * @param {object}    _options
 */
function initializeModel(csn, _options)
{
  if (!_options)
    throw Error('Please debug me: initializeModel must be invoked with options');

  const { signal } = alerts(csn);
  const {
      getCsnDef,
      getFinalTypeDef,
      isStructured,
      isAssocOrComposition,
    } = getUtils(csn);


  // make sure options are complete
  let options = validateOptions(_options);

  // First attach names to all definitions in the model
  forAll(csn.definitions, (a, n) => {
    assignProp (a, 'name', n);
  });

  foreach(csn.definitions, isActionOrFunction, a => {
    forAll(a.params, (p,n) => {
      setProp (p, 'name', n);
    })
  });

  // Fetch service objects
  let services = Object.keys(csn.definitions).reduce((services, artName) => {
    let art = csn.definitions[artName];
    if(art.kind === 'service' && !art.abstract) {
      services.push(art);
    }
    return services;
  }, [] );

  let serviceNames = services.map(s => s.name);
  // Link association targets and spray @odata.contained over untagged compositions
  foreach(csn.definitions, isStructuredArtifact, linkAssociationTarget);
  // Create data structures for containments
  foreach(csn.definitions, isStructuredArtifact, initializeContainments);
  // Initialize entities with parameters (add Parameter entity)
  foreach(csn.definitions, isParameterizedEntityOrView, initializeParameterizedEntityOrView);
  // Initialize structures
  foreach(csn.definitions, isStructuredArtifact, initializeStructure);
  // Initialize associations
  foreach(csn.definitions, isStructuredArtifact, initializeAssociation);
  // get constraints for associations
  foreach(csn.definitions, isStructuredArtifact, initializeConstraints);
  // create association target proxies
  foreach(csn.definitions, isStructuredArtifact, redirectDanglingAssociationsToProxyTargets);
  // create edmKeyRefPaths
  foreach(csn.definitions, isStructuredArtifact, initializeEdmKeyRefPaths);

  // decide if an entity set needs to be constructed or not
  foreach(csn.definitions, isStructuredArtifact, determineEntitySet);

  // let all doc props become @Core.Descriptions
  forEachDefinition(csn, artifact => {
    assignAnnotation(artifact, '@Core.Description', artifact.doc);
    forEachMemberRecursively(artifact,
      member => {
        assignAnnotation(member, '@Core.Description', member.doc);
      }
    );
  });

  return [services, options];

  // link association target to association and add @odata.contained to compositions in V4
  function linkAssociationTarget(struct) {
    foreach(struct.elements, isAssociationOrComposition, (element, name) => {
      if (element._ignore)
        return;
      if(!element._target) {
        let target = csn.definitions[element.target];
        if(target) {
          setProp(element, '_target', target);
          // If target has parameters, xref assoc at target for redirection
          if(isParameterizedEntityOrView(target)) {
            if(!target.$sources) {
              setProp(target, '$sources', Object.create(null));
            }
            target.$sources[struct.name + '.' + name] = element;
          }
        }
        else {
          signal(signal.error`Target ${element.target} cannot be found in the model`, [ 'definitions', struct.name, 'elements', element.name ]);
        }
      }
      // in V4 tag all compositions to be containments
      if(options.odataContainment &&
         options.isV4() &&
         isComposition(element) &&
         element['@odata.contained'] === undefined) {
        element['@odata.contained'] = true;
      }
    });
  }

  // Perform checks and add attributes for "contained" sub-entities:
  // - A container is recognized by having an association/composition annotated with '@odata.contained'.
  // - All targets of such associations ("containees") are marked with a property
  //   '_containerEntity: []', having as value an array of container names (i.e. of entities
  //   that have a '@odata.contained' association pointing to the containee). Note that this
  //   may be multiple entities, possibly including the container itself.
  // - All associations in the containee pointing back to the container are marked with
  //   a boolean property '_isToContainerEntity : true', except if the association itself
  //   has the annotation '@odata.contained' (indicating the top-down link in a hierarchy).
  // - Rewrite annotations that would be assigned to the containees entity set for the
  //   non-containment rendering. If containment rendering is active, the containee has no
  //   entity set. Instead try to rewrite the annotation in such a way that it is effective
  //   on the containment navigation property.
  function initializeContainments(container) {
    foreach(container.elements, isAssociationOrComposition, (element, elementName) => {
      if (element._ignore)
        return;
      if(element['@odata.contained']) {
        // Let the containee know its container
        // (array because the contanee may contained more then once)
        let containee = element._target;
        if (!containee._containerEntity) {
          setProp(containee, '_containerEntity', []);
        }
        // add container only once per containee
        if (!containee._containerEntity.includes(container.name)) {
          containee._containerEntity.push(container.name);
          // Mark associations in the containee pointing to the container (i.e. to this entity)
          for (let containeeElementName in containee.elements) {
            let containeeElement = containee.elements[containeeElementName];
            if (containeeElement._target && containeeElement._target.name) {
              // If this is an association that points to a container (but is not by itself contained,
              // which would indicate the top role in a hierarchy) mark it with '_isToContainer'
              if (containeeElement._target.name == container.name && !containeeElement['@odata.contained']) {
                setProp(containeeElement, '_isToContainer', true);
              }
            }
          }
        }
        rewriteContainmentAnnotations(container, containee, elementName);
      }
    });
  }

  // Split an entity with parameters into two entity types with their entity sets,
  // one named <name>Parameter and one named <name>Type. Parameter contains Type.
  // Containment processing must take place before because it might be that this
  // artifact with parameters is already contained. In such a case the existing
  // containment chain must be propagated and reused. This requires that the
  // containment data structures must be manually added here and rewriteContainmentAnnotations()
  // must be called.
  function initializeParameterizedEntityOrView(entityCsn, entityName) {

    // Naming rules for aggregated views with parameters
    // Parameters: EntityType <ViewName>Parameters, EntitySet <ViewName>
    //             with NavigationProperty "Results" pointing to the entity set of type <ViewName>Result
    // Result:     EntityType <ViewName>Result, EntitySet <ViewName>Results

    // Naming rules for non aggregated views with parameters
    // Parameters: EntityType <ViewName>Parameters, EntitySet <ViewName>
    //             with NavigationProperty "Set" pointing to the entity set of type <ViewName>Type
    // Result:     EntityType <ViewName>Type, EntitySet <ViewName>Set
    //             Backlink Navigation Property "Parameters" to <ViewName>Parameters

    // this code can be extended for aggregated views
    let parameterEntityName = entityName + 'Parameters';
    let parameterEntitySetName = entityName;
    let originalEntityName = entityName + 'Type';
    let originalEntitySetName = entityName + 'Set';
    let parameterToOriginalAssocName = 'Set';
    let backlinkAssocName = 'Parameters';
    let hasBacklink = true;

    // Construct the parameter entity
    let parameterCsn = {
      name: parameterEntityName,
      entitySetName: parameterEntitySetName,
      kind: 'entity',
      elements: Object.create(null),
      '@sap.semantics': 'parameters',
    };

    /*
    <EntitySet Name="ZRHA_TEST_CDS" EntityType="ZRHA_TEST_CDS_CDS.ZRHA_TEST_CDSParameters" sap:creatable="false" sap:updatable="false" sap:deletable="false" sap:pageable="false" sap:content-version="1"/>
    */

    assignProp(parameterCsn, '_EntitySetAttributes', 
      {'@sap.creatable': false, '@sap.updatable': false, '@sap.deletable': false, '@sap.pageable': false });

    assignProp(parameterCsn, '$keys', Object.create(null));
    setProp(parameterCsn, '$isParamEntity', true);

    // propagate containment information, if containment is recursive, use parameterCsn.name as _containerEntity
    if(entityCsn._containerEntity) {
      setProp(parameterCsn, '_containerEntity', []);
      for(let c of entityCsn._containerEntity) {
        parameterCsn._containerEntity.push((c==entityCsn.name)?parameterCsn.name:c);
      }
    }
    entityCsn._containerEntity = [ parameterCsn ];

    forAll(entityCsn.params, (p,n) => {
      let elt = cloneCsn(p);
      elt.name = n;
      delete elt.kind;
      elt.key = true; // params become primary key in parameter entity
      parameterCsn.$keys[n] = parameterCsn.elements[n] = elt;
    });

    // add assoc to result set, FIXME: is the cardinality correct?
    parameterCsn.elements[parameterToOriginalAssocName] = {
      '@odata.contained': true,
      name: parameterToOriginalAssocName,
      target: entityCsn.name,
      type: 'cds.Association',
      cardinality: { src: 1, min: 0, max: '*' }
    };
    setProp(parameterCsn.elements[parameterToOriginalAssocName], '_target', entityCsn);

    csn.definitions[parameterCsn.name] = parameterCsn;
    // modify the original parameter entity with backlink and new name
    csn.definitions[originalEntityName] = entityCsn;
    delete csn.definitions[entityCsn.name];
    entityCsn.name = originalEntityName;
    setProp(entityCsn, 'entitySetName', originalEntitySetName);

    // add backlink association
    if(hasBacklink) {
      entityCsn.elements[backlinkAssocName] = {
        name: backlinkAssocName,
        target: parameterCsn.name,
        type: 'cds.Association',
        on: [ { ref: [ 'Parameters', 'Set' ] }, '=', { ref: [ '$self' ] } ]
      };
      setProp(entityCsn.elements[backlinkAssocName], '_partnerCsn', []);
      setProp(entityCsn.elements[backlinkAssocName], '_target', parameterCsn);
    }

/*
<EntitySet Name="ZRHA_TEST_CDSSet" EntityType="ZRHA_TEST_CDS_CDS.ZRHA_TEST_CDSType" sap:creatable="false" sap:updatable="false" sap:deletable="false" sap:addressable="false" sap:content-version="1"/>
*/
    assignProp(entityCsn, '_EntitySetAttributes', 
      {'@sap.creatable': false, '@sap.updatable': false, '@sap.deletable': false, '@sap.addressable': false });



    // redirect inbound associations/compositions to the parameter entity
    Object.keys(entityCsn.$sources || {}).forEach(n => {
      entityCsn.$sources[n]._target = parameterCsn;
      entityCsn.$sources[n].target = parameterCsn.name;
    });
    rewriteContainmentAnnotations(parameterCsn, entityCsn, parameterToOriginalAssocName);
  }

  // Initialize structured artifact (type or entity) 'struct' by doing the
  // following:
  // - attach attributes 'name', 'Name' to elements (FIXME: We currently really require both 'Name' and 'name'!)
  // - create a property 'keys' with all its primary key elements
  // - optionally add the magic ValueList association
  // - call 'initializeAssociation' for each element that has an association type
  // - attach attribute 'name' to all actions and their parameters.

  function initElement(element, name, struct) {
    setProp(element, 'name', name)
    setProp(element, '_parent', struct);
  }

  function initializeStructure(struct) {
    let keys = Object.create(null);
    let validFrom = [], validKey = [];

    // Iterate all struct elements
    forAll(struct.elements, (element, elementName) => {
      initElement(element, elementName, struct);
      if(element['@cds.valid.key']) {
        validKey.push(element);
      }
      if(element['@cds.valid.from']) {
        validFrom.push(element);
      }

      if(options.isV4()) {
        /* Do not expose
           1) foreign keys in structured mode (always)
           1a) foreign keys of associations to container
               (but only for containment establishing
                association, see FIXME below)
           2) elements that are tagged with @odata.containment.ignore
              and parent is containee
        */
        if(!element.target) {
          if(element['@odata.foreignKey4']) {
            let isContainerAssoc = false;
            let elements = struct.elements;
            let assoc = undefined;
            let paths = element['@odata.foreignKey4'].split('.')
            for(let p of paths) {
              assoc = elements[p];
              if(assoc) // could be that the @odata.foreignKey4 was propagated...
                elements = assoc.elements;
            }

            if(assoc)
              isContainerAssoc = assoc._isToContainer || assoc['@odata.contained'];
            /* FIXME:
              In combination flat/containment, keys of non-parent association shall
              be rendered:
              entity Orders {
                ...;
                items: composition of many Items on $self = items.parent;
              }
              entity Items {
                ...;
                parent: association to Orders;
                // FKs shall be rendered as this is not the assoc that establishes the composition
                // in flat mode only
                leadOrder: association to Orders;
              };
            */
            if(isContainerAssoc || options.isStructFormat)
              assignAnnotation(element, '@cds.api.ignore', true);
          }
          // if this is an explicitly containment ignore tagged element,
          // ignore it if parent is containee
          else {
            if(element['@odata.containment.ignore'] &&
                element._parent._containerEntity && element._parent._containerEntity.length)
              assignAnnotation(element, '@cds.api.ignore', true);
          }
        }
        // it's an association
        else if(element['@odata.containment.ignore'] &&
            (element._isToContainer || element['@odata.contained'])) {
          // if this is an association in the containee
          // that is marked with containment ignore then don't render it
          assignAnnotation(element, '@odata.navigable', false);
        }
      }

      // Collect keys
      if (element.key) {
        keys[elementName] = element;
      }
      applyAppSpecificLateCsnTransformationOnElement(options, element, struct);
    });

    // if artifact has a cds.valid.key make this the only primary key and
    // add all @cds.valid.from + original primary keys as alternate keys
    // @Core.AlternateKeys: [{ Key: [ { Name: 'slID', Alias: 'slID' }, { Name: 'validFrom', Alias: 'validFrom'} ] }]

    if(validKey.length) {
      let altKeys = [{ Key: [] }];
      forAll(keys, (k, kn) => {
        altKeys[0].Key.push( { Name: kn, Alias: kn } );
        delete k.key;
      });
      validFrom.forEach(e => {
        altKeys[0].Key.push( { Name: e.name, Alias: e.name } );
      });
      if(struct['@Core.AlternateKeys'] === undefined) {
        struct['@Core.AlternateKeys'] = altKeys;
      }
      keys = Object.create(null);
      validKey.forEach(e => {
        e.key = true;
        keys[e.name] = e;
      });
    }
    else {
      validFrom.forEach(e => {
        e.key = true;
        keys[e.name] = e;
      });
    }

    assignProp(struct, '_EntitySetAttributes', Object.create(null));
    assignProp(struct, '$keys', keys);

    applyAppSpecificLateCsnTransformationOnStructure(options, struct);

    // initialize bound actions and functions

    // Attach name to actions and their parameters
    forAll(struct.actions, (a, n) => {
      a.name = n;
      forAll(a.params, (p, n) => {
        p.name = n;
      });
    });
  }

  // Resolve the association type of 'element' in 'struct' by doing the following:
  // - collect the foreign key elements for the target into attribute 'elements'
  function initializeAssociation(struct) {
    foreach(struct.elements, isAssociationOrComposition, element => {
      if (element._ignore)
        return;
      if(!element._target) {
        throw Error('Expect target to be resolved, parent: ' + struct.name + ', assoc: ' + element.name + ', target: ' + element.target);
      }
      // in case this is a forward assoc, store the backlink partneres here, _partnerCsn.length > 1 => error
      setProp(element, '_partnerCsn', []);
      setProp(element._target, '$proxies', []);

      //forward annotations from managed association element to its foreign keys
      if(element.keys && options.isFlatFormat) {
        for(let fk of element.keys) {
          forAll(element, (attr, attrName) => {
            if(attrName[0] === '@')
              struct.elements[fk.$generatedFieldName][attrName] = attr;
          });
        }
      }
    });
  }

  function initializeConstraints(struct) {
    foreach(struct.elements, isAssociationOrComposition, element => {
      if (element._ignore) return;
      setProp(element, '_constraints', getReferentialConstraints(element, signal, options.isFlatFormat));

      // only in V2 we must set the target cardinality of the backlink to the forward:
      if(element._constraints._originAssocCsn && element.cardinality && element.cardinality.max) {
        if(element._constraints._originAssocCsn.cardinality) {
          if(element._constraints._originAssocCsn.cardinality.src) {
            let srcMult = (element._constraints._originAssocCsn.cardinality.src == 1) ? '0..1' : '*';
            let newMult = (element.cardinality.max > 1) ? '*' : '0..1';
            if(options.isV2() && srcMult != newMult) {
              // Association 'E_toF': Multiplicity of Role='E' defined to '*', conflicting with target multiplicity '0..1' from
              signal(signal.warning`Source cardinality "${element._constraints._originAssocCsn.cardinality.src}" of "${element._constraints._originAssocCsn._parent.name}/${element._constraints._originAssocCsn.name}" conflicts with target cardinality "${element.cardinality.max}" of association "${element._parent.name}/${element.name}"`);
            }
          }
          else {
            element._constraints._originAssocCsn.cardinality.src = element.cardinality.max;
          }
        }
        else {
          element._constraints._originAssocCsn.cardinality = { src: element.cardinality.max };
        }
      }
    });
  }

  // For defining service create proxy target, if original target is outside of defining service
  function redirectDanglingAssociationsToProxyTargets(struct) {

    function whatsMyServiceName(n) {
      return serviceNames.reduce((rc, sn) => n.startsWith(sn + '.') ? rc = sn : rc, undefined);
    }

    let myServiceName = whatsMyServiceName(struct.name);
    // if this artifact is a service member check its associations
    if(myServiceName) {
      foreach(struct.elements, isAssociationOrComposition, element => {
        if (element._ignore || element['@odata.navigable'] === false) {
          return;
        }
        /*
         * Consider everthing @cds.autoexpose: falsy to be a proxy candidate for now
         */
        /*
        if(element._target['@cds.autoexpose'] === false) {
          // :TODO: Also _ignore foreign keys to association?
          foreach(struct.elements,
            e =>
              e['@odata.foreignKey4'] === element.name,
            e => e._ignore = true);
          element._ignore = true;
          signal(signal.info`${element.type.replace('cds.', '')} "${element.name}" excluded, target "${element._target.name}" is annotated '@cds.autoexpose: ${element._target['@cds.autoexpose']}'`,
            ['definitions', struct.name, 'elements', element.name]);
          return;
        }
        */
        // if target is outside defining service, create/reuse proxy
        if(myServiceName !== whatsMyServiceName(element._target.name)) {
          if(edmUtils.isBetaEnabled(options) && options.isStructFormat && options.isV4() && options.toOdata.odataProxies) {
            // search for eventually existing proxy
            let proxy = element._target.$proxies.filter(p => p.name.startsWith(myServiceName + '.'))[0];
            if(!proxy) {
              let name = myServiceName + '.' + element._target.name.split('.').join('_') + '_proxy';
              proxy = { name, kind: 'entity', $proxy: true, elements: Object.create(null) };
              setProp(proxy, '$proxy', true);
              setProp(proxy, '$keys', Object.create(null));
              forAll(element._target.$keys, e => {
                let newElt = e;
                if (isEdmPropertyRendered(e, options)) {
                  if(isAssocOrComposition(e.type) && !e.on && !e.onCond) {
                  // convert managed association into structured element
                    if(e.keys) {
                      newElt = cloneCsn(e);
                      initElement(newElt, e.name, struct);
                      newElt.elements = Object.create(null);
                      // remove all unwanted garbage
                      delete newElt.keys;
                      delete newElt.target;
                      delete newElt.type;
                      // if this association has no keys or if it is a redirected parameterized entity,
                      // use the primary keys of the target
                      let keys = (!e._target.$isParamEntity && e.keys) ||
                        Object.keys(e._target.$keys).map(k => { return { ref: [k] } });
                      keys.forEach(k => {
                        let art = e._target || getCsnDef(e.target);
                        for(let ps of k.ref) {
                          art = art.elements[ps];
                        }
                        // art is in the target side, clone it and remove key property
                        let cloneArt = cloneCsn(art);
                        setProp(cloneArt, 'name', art.name);
                        delete cloneArt.key;
                        newElt.elements[art.name] = cloneArt;
                      });
                      e = newElt; // treat as structure in if(isStructured(e)) below
                    }
                    else {
                      signal(signal.info`Unmanaged associations not supported as primary keys of proxy entity type "${name}" for unexposed association target "${element._target.name}"`,
                        ['definitions', struct.name, 'elements', element.name]);
                    }
                  }
                  if(isStructured(e)) {
                    exposeStructTypeOf(e, `${name.replace(/\./g, '_')}_${e.name}`, e.name);
                    // FIXME: double clone for assoc?
                    newElt = cloneCsn(e);
                    initElement(newElt, e.name, struct);
                  }
                  proxy.$keys[e.name] = proxy.elements[e.name] = newElt;
                  Object.keys(proxy.elements[e.name]).forEach(k => {
                    if(k[0] === '@') delete proxy.elements[e.name][k]
                  });
                }
              });
              if(proxy.$keys.length === 0) {
                element._ignore = true;
                signal(signal.info`Could not create proxy entity type "${name}" for unexposed association target "${element._target.name}", because target has no primary keys`,
                  ['definitions', struct.name, 'elements', element.name]);
                return;
              }
              // wire up proxy
              if(csn.definitions[name] !== undefined)
                signal(signal.error`Duplicate proxy entity type "${name}" for unexposed association target "${element._target.name}"`,
                ['definitions', struct.name, 'elements', element.name]);
              else {
                signal(signal.info`Created proxy entity type "${name}" for unexposed association target "${element._target.name}"`,
                  ['definitions', struct.name, 'elements', element.name]);
                csn.definitions[name] = proxy;
              }
              element._target.$proxies.push(proxy);
            }
            element._target = proxy;
              // remove referential constraints
            element._constraints.constraints = Object.create(null);
          }
          else {
            element._ignore = true;
            signal(signal.warning`No OData navigation property generated for association "${element.name}", as target "${element._target.name}" is outside any service`,
              ['definitions', struct.name, 'elements', element.name]);
            return;
          }
        }
      });
    }

    // If 'node' exists and has a structured type that is not exposed in 'service', (because the type is
    // anonymous or has a definition outside of 'service'), create an equivalent type in 'service', either
    // using the type's name or (if anonymous) 'artificialName', and make 'node' use that type instead.
    // Complain if there is an error.
    function exposeStructTypeOf(node, artificialName, parentName) {
      if (!node) {
        return;
      }
      if (node.items) {
        exposeStructTypeOf(node.items, artificialName, parentName);
      }

      let elements = (csn.definitions[node.type] || node).elements;
      let isNotInProtNS = node.type && (!node.type.startsWith('cds.') || node.type.startsWith('cds.foundation'));
      // let isNotInService = node.type && myServiceName !== whatsMyServiceName(node.type);
      // Always expose types referred to by a proxy, never reuse an eventually exisiting type
      // as the nested elements must all be not nullable
      if (elements && !node.type || (/*isNotInService && */isNotInProtNS)) {
        let typeDef = node.type ? csn.definitions[node.type] : /* anonymous type */ node;
        if (typeDef && isStructured(typeDef)) {
          // if type has been exposed already use this type name
          if(typeDef.$odataProxyType) {
            node.type = typeDef.$odataProxyType;
            return;
          } else {
            // expose the type
            let typeId = node.type ? `${artificialName}_${node.type.replace(/\./g, '_')}` : artificialName;
            let type = exposeStructType(typeId, typeDef.elements);
            if(type) {
              // Recurse into elements of 'type' (if any)
              for (let elemName in type.elements) {
                exposeStructTypeOf(type.elements[elemName], `${typeId}_${elemName}`, parentName);
              }
              typeDef.$odataProxyType = node.type = `${myServiceName}.${typeId}`;
            }
          }
        }
      }

      function exposeStructType(typeId, elements) {
        let typeName = `${myServiceName}.${typeId}`;
        // If type already exists, reuse it (complain if not created here)
        let type = csn.definitions[typeName];
        if (type) {
          signal(signal.error`Cannot create type "${typeName}" for "${parentName}" because the name is already used`);
          return undefined;
        }
        // Create type with empty elements
        type = {
          kind: 'type',
          name: typeName,
          elements: Object.create(null),
        };
        setProp(type, '$odataProxyType', typeName);
        // Duplicate the type's elements
        for (let elemName in elements) {
          // !!! DO NOT expose associations for proxies!!!
          let elem = elements[elemName];
          if(!elem.target) {
            type.elements[elemName] = Object.create(null);
            for (let prop in elem)
              type.elements[elemName][prop] = elem[prop];
            // all exposed key struct types are not null as required by OData V4
            type.elements[elemName].notNull = true;
          }
        }
        csn.definitions[typeName] = type;
        return type;
      }
    }
  }

  /*
    Initialize the key ref paths into the property list
    Iterate over all keys and ignore the non-rendered elements
      * For Flat V2/V4 take all elements except associations/compositions,
        all elements are flat, no need to treat them any further
      * For Structured V4 flatten out all key elements, if the element
        is an association/composition, flatten out the foreign keys as well.
  */
  function initializeEdmKeyRefPaths(struct) {
    setProp(struct, '$edmKeyPaths', []);
    // for all key elements that shouldn't be ignored produce the paths
    foreach(struct.$keys, kn => !kn._ignore, (k, kn) => {
      if(isEdmPropertyRendered(k, options)) {
        if(options.isV4() && options.isStructFormat)
          // This is structured OData ONLY
          struct.$edmKeyPaths.push(...produceKeyRefPaths(k, kn));
        else if(!k.target) {
          struct.$edmKeyPaths.push([kn]);
        }
      }
    });

    /*
      Produce the list of paths for this element
      - If element is not rendered in EDM, return empty array.
      - If element is structured type, do structure flattening and then check for each
        leaf element if it is a managed association and flatten further recursively.
      - If element is a managed association, use the FK path as prefix and flatten out
        all foreign keys (eventually recursively). This filters the association itself
        to become an entry in the path array which is correct as OData doesn't allow
        navprops to be key ref.
      If element is of scalar type, return it as an array.
    */
    function produceKeyRefPaths(eltCsn, prefix) {
      let keyPaths = [];
      if(!isEdmPropertyRendered(eltCsn, options)) {
        let annos = Object.keys(eltCsn).filter(a=>a[0]==='@').join(', ');
        signal(signal.warning`${struct.name}: OData V4 primary key path: "${prefix}" is unexposed by one of these annotations "${annos}"`, ['definitions', struct.name, 'elements', eltCsn.name ]);
        return keyPaths;
      }
      // TODO: Add check that all path elements are not null
      // OData requires all elements along the path to be nullable: false (that is either key or notNull)

      let elements = eltCsn.elements || getFinalTypeDef(eltCsn.type).elements;
      if(elements) {
        for(let eltName in elements) {
          let elt = elements[eltName];
          keyPaths.push(...produceKeyRefPaths(elt, prefix + options.pathDelimiter + eltName));
        }
      }
      /* If element is a managed association (can't be anything else),
         flatten foreign keys and use foreign key path as new starting prefix
         This also implies that the association itself is never added into the
         list of primary key refs
      */
      else if(eltCsn.target && !eltCsn.on && !eltCsn.onCond) {
        // if this association has no keys or if it is a redirected parameterized entity,
        // use the primary keys of the target
        let keys = (!eltCsn._target.$isParamEntity && eltCsn.keys) ||
          Object.keys(eltCsn._target.$keys).map(k => { return { ref: [k] } });
        keys.forEach(k => {
          let art = eltCsn._target || getCsnDef(eltCsn.target);
          for(let ps of k.ref) {
            art = art.elements[ps];
            if(!(art.type.startsWith('cds.') || art.type.startsWith('cds.foundation.'))) {
              art = getCsnDef(art.type);
            }
          }
          keyPaths.push(...produceKeyRefPaths(art, prefix + options.pathDelimiter + k.ref.join(options.pathDelimiter)));
        });
      }
      else {
        keyPaths.push([prefix]);
      }
      return keyPaths;
    }
  }

  function determineEntitySet(struct) {
    // if this is an entity or a view, determine if an entity set is required or not
    // 1) must not be a proxy and not a containee in V4
    // No annos are rendered for non-existing EntitySet targets.
    if(struct.hasEntitySet === undefined) {
      let hasEntitySet = ['entity', 'view'].includes(struct.kind) && !(options.isV4() && edmUtils.isContainee(struct)) && !struct.$proxy;
      setProp(struct, 'hasEntitySet', hasEntitySet);
    }
  }

  // If containment in V4 is active, annotations that would be assigned to the containees
  // entity set are not renderable anymore. In such a case try to reassign the annotations to
  // the containment navigation property.
  // Today only Capabilities.*Restrictions are known to be remapped as there exists a CDS
  // short cut annotation @readonly that gets expanded and can be safely remapped.
  function rewriteContainmentAnnotations(container, containee, assocName) {
    // rectify Restrictions to NavigationRestrictions
    if(options.isV4() && container['@Capabilities.NavigationRestrictions'] === undefined) {
      let navRestr = {
        RestrictedProperties: [
          {
            NavigationProperty: assocName
          }
        ]
      };
      let hasRestrictions = false;
      if(containee['@Capabilities.DeleteRestrictions.Deletable'] !== undefined) {
        navRestr.RestrictedProperties[0].DeleteRestrictions =
          { 'Deletable': containee['@Capabilities.DeleteRestrictions.Deletable'] };
        delete containee['@Capabilities.DeleteRestrictions.Deletable'];
        hasRestrictions = true;
      }
      if(containee['@Capabilities.InsertRestrictions.Insertable'] !== undefined) {
        navRestr.RestrictedProperties[0].InsertRestrictions =
          { 'Insertable': containee['@Capabilities.InsertRestrictions.Insertable'] };
        delete containee['@Capabilities.InsertRestrictions.Insertable'];
        hasRestrictions = true;
      }
      if(containee['@Capabilities.UpdateRestrictions.Updatable'] !== undefined) {
        navRestr.RestrictedProperties[0].UpdateRestrictions =
          { 'Updatable': containee['@Capabilities.UpdateRestrictions.Updatable'] };
        delete containee['@Capabilities.UpdateRestrictions.Updatable'];
        hasRestrictions = true;
      }
      //'@Capabilities.ReadRestrictions.Readable'
      if(containee['@Capabilities.ReadRestrictions.Readable'] !== undefined) {
        navRestr.RestrictedProperties[0].ReadRestrictions =
          { 'Readable': containee['@Capabilities.ReadRestrictions.Readable'] };
        delete containee['@Capabilities.ReadRestrictions.Readable'];
        hasRestrictions = true;
      }
      if(hasRestrictions)
        container['@Capabilities.NavigationRestrictions'] = navRestr;
    }
  }
}




/*
 * Late application specific transformations
 *  At present there are two transformation targets: Structure and Element
 *  These transformations are available today:
 *
 *  Analytical Scenario:
 *    If a structure is annotated with @Aggregation.ApplySupported.PropertyRestrictions
 *    then a number of annotation rewrites are done to this structure and to the
 *    elements of this structure
 *    Also the key properties of all structure elements are removed and a new
 *    artificial key element 'key _ID : String' is inserted at first position of
 *    the elements dictionary
 *
 * PDM (Personal Data Management)
 *    Planned but not yet implemented annotation rewriting (pending to finalization)
 * /

/* eslint max-statements-per-line:off */

function mapAnnotationAssignment(artifact, parent, mappingDictionary)
{
  let props = intersect(Object.keys(mappingDictionary), Object.keys(artifact));
  // now start the substituation
  props.forEach(prop => {
    let [ mapping, value, remove_original ] = mappingDictionary[prop];
    if(mapping instanceof Function)
    {
      mapping(artifact, parent, prop);
    }
    else
    {
      assignAnnotation(artifact, mapping, value || artifact[prop]['='] || artifact[prop]);
    }

    if(remove_original)
      delete artifact[prop];
  });
}

function applyAppSpecificLateCsnTransformationOnElement(options, element, struct)
{
  if(options.isV2())
  {
    if(struct['@Aggregation.ApplySupported.PropertyRestrictions'])
    {
      mapAnnotationAssignment(element, struct, AnalyticalAnnotations());
    }
    mapAnnotationAssignment(element, struct, PDMSemantics());
  }

  // etag requires Core.OptimisticConcurrency to be set in V4 (cap/issues#2641)
  // Oliver Heinrich mentions in the issue that the Okra runtime must be set to a
  // concurrent runtime mode by the caller, if the annotation is added this late,
  // it doesn't appear in the forOData processed CSN, meaning that the
  // runtime cannot set that okra flag (alternatively the runtime has to search
  // for @[odata|cds].etag anntotions...
  if(options.isV4())
  {
    if(element['@odata.etag'] == true || element['@cds.etag'] == true) {
      // don't put element name into collection as per advice from Ralf Handl, as
      // no runtime is interested in the property itself, it is sufficient to mark
      // the entity set.
      assignAnnotation(struct, '@Core.OptimisticConcurrency',
        (struct['@Core.OptimisticConcurrency'] || [])/*.push(element.name)*/);
    }
  }

  // nested functions begin
  function PDMSemantics()
  {
    let dict = Object.create(null);
    /*
    dict['@PDM.xxx1'] = [ '@sap.pdm-semantics' ];
    dict['@PDM.xxx2'] = [ '@sap.pdm-propery' ];
    dict['@PDM.xxx3'] = [ '@sap.pdm-display-sq-no' ];
    dict['@PDM.xxx4'] = [ '@sap.pdm-record-identifier' ];
    dict['@PDM.xxx5'] = [ '@sap.pdm-field-group' ];
    dict['@PDM.xxx6'] = [ '@sap.pdm-mask-find-pattern' ];
    dict['@PDM.xxx7'] = [ '@sap.pdm-mask-replacement-pattern' ];
    dict['@PDM.xxx8'] = [ '@sap.deletable' ];
    dict['@PDM.xxx8'] = [ '@sap.updatable' ];

    // respect flattened anntotation $value
    Object.keys(dict).forEach(k => dict[k+'.$value'] = dict[k]);
    */
    return dict;
  }

  function AnalyticalAnnotations()
  {
    function mapCommonAttributes(element, struct, prop)
    {
      let CommonAttributes = element[prop];
      if(!Array.isArray(CommonAttributes))
        throw 'This is not an array value for @Common.attributes: ' + CommonAttributes;
      let targets = intersect(CommonAttributes, Object.keys(struct.elements));
      targets.forEach(tgt => {
        assignAnnotation(struct.elements[tgt], '@sap.attribute-for', element.name);
      });
    }

    function mapContextDefiningProperties(element, struct, prop)
    {
      let ContextDefiningProperties = element[prop];
      if(!Array.isArray(ContextDefiningProperties))
        throw 'This is not an array value for @Aggregation.ContextDefiningProperties: ' + ContextDefiningProperties;
      if(ContextDefiningProperties.length > 0)
        assignAnnotation(element, '@sap.super-ordinate', ContextDefiningProperties[ContextDefiningProperties.length-1]);
    }

    let dict = Object.create(null);
    //analytics term definition unknown, lower case
    dict['@Analytics.Measure'] = [ '@sap.aggregation-role', 'measure' ];
    dict['@Analytics.Dimension'] = [ '@sap.aggregation-role', 'dimension' ];
    dict['@Semantics.currencyCode'] = [ '@sap.semantics', 'currency-code', true ];
    dict['@Semantics.unitOfMeasure'] = [ '@sap.semantics', 'unit-of-measure', true ];

    dict['@Measures.ISOCurrency'] = [ '@sap.unit' ];
    dict['@Measures.Unit'] = [ '@sap.unit' ];

    dict['@Common.Label'] = [ '@sap.label' ];
    dict['@Common.Text'] = [ '@sap.text' ];
    dict['@Aggregation.ContextDefiningProperties'] = [ mapContextDefiningProperties ];
    dict['@Common.Attributes'] = [ mapCommonAttributes ];

    // respect flattened anntotation $value
    Object.keys(dict).forEach(k => dict[k+'.$value'] = dict[k]);
    return dict;
  }
}

function applyAppSpecificLateCsnTransformationOnStructure(options, struct)
{
  if(options.isV2())
  {
    if(struct['@Aggregation.ApplySupported.PropertyRestrictions'])
    {
      transformAnalyticalModel(struct);
      mapAnnotationAssignment(struct, undefined, AnalyticalAnnotations());
    }
  }

  // nested functions begin
  function transformAnalyticalModel(struct)
  {
    let keyName = 'ID__';
    if(struct == undefined || struct.elements == undefined || struct.elements[keyName] != undefined)
      return;

    // remove key prop from elemens, add new key to elements
    let elements = Object.create(null);
    let key =  { name: keyName, key : true, type : 'cds.String', '@sap.sortable':false, '@sap.filterable':false, '@UI.Hidden': true };
    elements[keyName] = key;
    struct.$keys = { [keyName] : key };
    forAll(struct.elements, (e,n) =>
    {
      if(e.key) delete e.key;
      elements[n] = e;
    });
    struct.elements = elements;
  }

  function AnalyticalAnnotations()
  {
    function mapFilterRestrictions(struct, parent, prop)
    {
      let stringDict = Object.create(null);
      stringDict['SingleValue'] = 'single-value';
      stringDict['MultiValue'] = 'multi-value';
      stringDict['SingleRange'] = 'interval';

      let filterRestrictions = struct[prop];
      if(!Array.isArray(filterRestrictions))
        throw 'This is not an array value for @Capabilities.FilterRestrictions.FilterExpressionRestrictions: ' + filterRestrictions;
      filterRestrictions.forEach(v => {
        let e = struct.elements[v.Property];
        if(e)
          assignAnnotation(e, '@sap.filter-restriction', stringDict[v.AllowedExpressions]);
      });
    }

    function mapRequiredProperties(struct, parent, prop)
    {
      let requiredProperties = struct[prop];
      if(!Array.isArray(requiredProperties))
        throw 'This is not an array value for @Capabilities.FilterRestrictions.RequiredProperties: ' + requiredProperties;
      let props = intersect(Object.keys(struct.elements), requiredProperties)
      props.forEach(p => {
        assignAnnotation(struct.elements[p], '@sap.required-in-filter', true);
      });
    }

    function mapRequiresFilter(struct, parent, prop)
    {
      let requiresFilter = struct[prop];
      if(requiresFilter)
        assignAnnotation(struct._EntitySetAttributes, '@sap.requires-filter', requiresFilter);
    }

      // Entity Props
    let dict = Object.create(null);
    dict['@Aggregation.ApplySupported.PropertyRestrictions'] = [ '@sap.semantics', 'aggregate' ];
    dict['@Common.Label'] = [ '@sap.label' ];
    dict['@Capabilities.FilterRestrictions.RequiresFilter'] = [ mapRequiresFilter ];
    dict['@Capabilities.FilterRestrictions.RequiredProperties'] = [ mapRequiredProperties ];
    dict['@Capabilities.FilterRestrictions.FilterExpressionRestrictions'] = [ mapFilterRestrictions ];

    // respect flattened anntotation $value
    Object.keys(dict).forEach(k => dict[k+'.$value'] = dict[k]);

    return dict;
  }
}

// Assign but not overwrite annotation
function assignAnnotation(node, name, value) {
  if(value !== undefined &&
      name !== undefined && name[0] === '@' &&
      (node[name] === undefined ||
      node[name] && node[name] === null)) {
    node[name] = value;
  }
}

// Set non enumerable property if it doesn't exist yet
function assignProp(obj, prop, value) {
  if(obj[prop] === undefined) {
    setProp(obj, prop, value);
  }
}

module.exports = {
  initializeModel,
}
