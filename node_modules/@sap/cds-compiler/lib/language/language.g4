// ANTLR4 grammar to generate Parser and Lexer for CDS-Language

// To be built the parser by hand, install Java, download the ANTLR4 tool, then
//   antlr4 -no-listener -o ../gen language.g4
// Alternatively, install Java, and use
//   npm run download && npm run gen
//
// To test the parser in the REPL, see file './lib/language/antlrParser.js'.

// This grammar is built according to the following guidelines:
//
//  * Do not express every syntactical restriction by grammar rules, and do
//    not define a grammar which allows every nonsense.  We might specify
//    syntactical restrictions in a certain form inside actions or semantic
//    predicates to have them directly available for IDE code completion.
//
//  * Keep the number of token types small.  Thus, do not define different
//    token types for things which are not distinguished in the parser.
//    Examples: one token type for numbers (have a check if you just want to
//    allow integers at certain places), one token type for non-quoted and
//    quoted identifiers.
//
//  * Keep the number of keywords as small as possibile.  Thus, built-ins is a
//    topic for the semantic analysis, not the grammar.  Examples: no keywords
//    for built-in types or built-in SQL functions.  This also avoids noise in
//    the grammar and a huge/slow generated parser.
//  ┌─────────────────────────────────────────────────────────────────────────┐
//    For our adapted ANTLR error strategy concerning (non-reserved) keywords,
//    make sure to define non-reserved keywords between the lexer rule `Number`
//    and `Identifier`.  The latter must be the second last rule, the last is
//    `IllegalToken`.  Do not rename these three rules.  Add each new
//    non-reserved keyword to rule `ident`, but check for ambiguities!
//  └─────────────────────────────────────────────────────────────────────────┘
//
//  * Left-factor the parser grammar if the same initial part covers more than
//    one or two tokens.  ANTLRs adaptive predication allows to write "natural"
//    rules, but slows down parsing, especially if a long lookahead is need to
//    solve an LLk ambiguity.  Therefore, try to avoid it in rules which are
//    called often.  Unfortunately, we cannot use ANTLR3's grammar and subrule
//    option 'k' (lookahead depth) anymore...  Therefore...
//  ┌─────────────────────────────────────────────────────────────────────────┐
//    Before each alternative with LL1 ambiguities (looking at the next token
//    is not enough for a decision), write a comment starting with `#ATN:`
//    which describes the ambiguity.  Additionally, put a comment `/* #ATN n
//    */` INSIDE an (`@after`) action of a rule if the corresponding function
//    in '../gen/langageParser.js' contains `n` occurrences of
//    `adaptivePredict` calls.  This is checked in 'test/testCompiler.js',
//    which also counts the total number of `adaptivePredict` occurrences.
//  └─────────────────────────────────────────────────────────────────────────┘
//
//  * For fast parsing and lower memory consumption, we use ANTLR4 with SLL
//    prediction-mode only.  That means that ANTLR does not use the actual call
//    stack when deciding which alternative to choose in a rule.  You might
//    need to copy a rule manually to get less ambiguities - this might be a
//    good idea anyway to avoid calls to `adaptivePredict`, see the rules
//    starting with `annotationAssignment_`.
//
//  * Do not use actions in the lexer.  Examples: de-quote string literals not
//    in the lexer, but in the parser; do not throw errors, but produce error
//    tokens if necessary.
//
//  * Use actions in the parser to produce a Augmented CSN model.  To have it
//    also in the case of syntax errors, produce it by adding sub-nodes to a
//    parent node, not by returning the nodes (the latter is fine for secondary
//    attachments).
//
//  * Action code should be a one-liner (<100 chars); usually, just one action
//    is called per alternative (plus the @after action which sets the AST
//    location).  For more complicated code, define a method in file
//    './genericAntlrParser.js'.
//
//  * Do not write lexer rules for tokens like ';', use ';' directly in the
//    parser rule.  Advantage: better error messages; taste: more or less
//    readable grammar; disadvantage: debugging in generated code.
//
//  * Use all-upper token names for keywords (e.g. CONTEXT), capitalized ones
//    (e.g. Number) for others - EOF is the exception (is ANTLR-builtin).
//    Remember: parser rule names in ANTLR start with a lower-case letter.
//
//  * No useless parentheses in the grammar.  There are just two binary grammar
//    operators: alternative (`|`) and sequence.  It should not be too hard to
//    remember that sequence binds stronger than alternative.
//
//  * Use the following indentation rules:
//     - rule header: indentation 0 + 2* parentheses/braces depth
//     - rule colon (':' separating header & body): 2
//     - rule body: 4 + 2* parentheses/braces depth, -2 for certain chars at
//       beginning of line: '|', ')', ']' or '}'
//     - inside action: as for the action language, e.g. function argument
//       alignment
//     - rule semicolon (';' ending body, before exceptions): 2
//     - rule exceptions (not used): 2 + 2* parentheses/braces depth

// Some practical info:
//
//  * The end location for the match of a rule is just available in the @after
//    action.  Use method `attachLocation` there on the produced AST.
//
//  * Be careful with the rule names: the methods in antlr4.Parser, the methods
//    in `./antlrParser' and the parser rule names share the same namespace.
//    Any shadowing lead to an exception when running 'test/testCompiler.js'.
//
//  * Be careful with names for rule arguments, returns, locals and rule
//    reference labels: the names `parser`, `parent` and `invokingState` cannot
//    be used (these are added by the generator).

grammar language;
options {
  language = JavaScript;
  superClass = genericAntlrParser;
}
tokens {
  HideAlternatives,             // hide alternative tokens (no token seq!)
  DOTbeforeBRACE,               // via token rewrite
  COMPOSITIONofBRACE            // via token rewrite in rule typeAssociationBase
}

// Top-Level -----------------------------------------------------------------

start returns [ source = { kind: 'source' } ] locals [ _sync = 'recover' ]
  :
    usingDeclaration[$source]*
    (
      namespaceDeclaration[$source]
      ( usingDeclaration[$source] | artifactDef[$source] )*
    |
      artifactDef[$source]
      ( usingDeclaration[$source] | artifactDef[$source] )*
    )?
    EOF
  ;

queryEOF returns [ query ]
  :
    q=queryExpression { $query = $q.query; } EOF
  ;

conditionEOF returns [ cond ]
  :
    c=condition { $cond = $c.cond; } EOF
  ;

namespaceDeclaration[ source ] locals[ decl = {} ]
@after { $source.namespace = this.attachLocation($decl); }
  :
    NAMESPACE simplePath[ $decl, 'Namespace' ] ';'
    { if (this.options.hanaFlavor) { $decl.dcPath = $decl.path; delete $decl.path; } }
  ;

usingDeclaration[ source ] locals[ decl ]
@after { if ($decl) this.attachLocation($decl); }
  :
    USING
    (
      FROM str=String
       {
         if (!$source.dependencies) $source.dependencies = [];
         $source.dependencies.push( this.quotedLiteral( $str, 'string' ) );
      }
    |
      path=externalPath
      { $decl = this.addItem( $source, 'usings', 'using', [], { extern: $path.extern } ); }
      ( AS name=ident['Using'] { $decl.name = $name.id; }
      | { this.classifyImplicitName( 'Using' ); }
      )
      ( FROM str=String
        {
          if (!$source.dependencies) $source.dependencies = [];
          $source.dependencies.push( $decl.fileDep = this.quotedLiteral( $str, 'string' ) );
        }
      )?
    |
      { $decl = this.addItem( $source, 'usings', 'using', [] ); }
      // We could just create "independent" USING declaration, but if we want
      // to have some check in the future whether the external artifacts are
      // really in the FROM source...
      '{'
      innerUsing[ $decl ]
      ( ',' { if (this.isStraightBefore('}')) break; } // allow ',' before '}'
        innerUsing[ $decl ] )*
      '}'
      ( FROM str=String
        {
          if (!$source.dependencies) $source.dependencies = [];
          $source.dependencies.push( $decl.fileDep = this.quotedLiteral( $str, 'string' ) );
        }
      )?
    )
    ';'
  ;

innerUsing[ using ] locals[ decl ]
@after { if ($decl) this.attachLocation($decl); }
  :
    path=externalPath
    { $decl = this.addItem( $using, 'usings', 'using', null, { extern: $path.extern } ); }
    ( AS name=ident['Using'] { $decl.name = $name.id; }
    | { this.classifyImplicitName( 'Using' ); }
    )
  ;

externalPath returns [ extern = {} ]
  :
    simplePath[ $extern, 'global' ]
    ( '::' { $extern.dcPath = $extern.path; delete $extern.path; }
      simplePath[ $extern, 'global' ]
    )?
  ;

// We have two versions of the annotation assignment rule, because we do not
// want to let the ambiguity in select items (solution: "either" possibility)
// creep into all annotation assignments:
//   const value = 3
//   view V as select from E {    // either: anno value 3, select item -x
//     @anno :value - x as x;     // or: anno value true, select item 3-x
//   }

annotationAssignment_1[ annos ] locals[ assignment = { name: {} } ]
@after { $annos.push( this.attachLocation($assignment) ); }
  :
    simplePath[ $assignment.name, 'anno' ]
    ( '#' variant=ident['variant'] { $assignment.name.variant = $variant.id; } )?
    ( ':' val=value { $assignment.value = $val.val; } )?
  ;

annotationAssignment_paren[ annos ]
  :
    '('
    // allow completely useless `@()` with a warning, do not offer it for completion
    {
      if (this.isStraightBefore(')')) {
        this.message( 'syntax-anno-useless',
                      this.tokenLocation( this._input.LT(-2), this.getCurrentToken() ),
                      { code: '@()' },
                      'Warning', 'Ignored useless $(CODE)' );
        this.matchWildcard();   // we know it is the ')' - we do not reach the final match
        return $ctx;
      }
    }
    annotationAssignment_1[ $annos ]
    ( ',' { if (this.isStraightBefore(')')) break; } // allow ',' before ')'
      annotationAssignment_1[ $annos ]
    )*
    ')'
  ;

annotationAssignment_fix[ annos ] locals[ assignment ]
// no variant or value outside @(...)
@after {
  if ($assignment) {
    $annos.push( this.attachLocation($assignment) );
    this.docComment( $annos );
  }
} :
    '@'
    (
      annotationAssignment_paren[ annos ]
    |
      { $assignment = { name: {} }; }
      simplePath[ $assignment.name, 'anno' ]
      ( '#' variant=ident['variant']
        { $assignment.name.variant = $variant.id;
          if ($variant.id) $assignment.name.location.end = $variant.id.location.end; } )?
      {
        var t = this.getCurrentToken();
        if (t.text === ':')
          this.message( 'syntax-anno-short', $assignment.name.location,
                        { code: '@(...)' },
                        'Warning', 'Better use $(CODE) for annotation assignments here' );
      }
    )
  ;

annotationAssignment_ll1[ annos ] locals[ assignment ]
@after {
  if ($assignment) {
    $annos.push( this.attachLocation($assignment) );
    this.docComment( $annos );
  }
} :
    '@'
    (
      annotationAssignment_paren[ annos ]
    |
      { $assignment = { name: {} }; }
      simplePath[ $assignment.name, 'anno' ]
      ( '#' variant=ident['variant'] { $assignment.name.variant = $variant.id; } )?
      ( ':' val=value { $assignment.value = $val.val; } )?
    )
  ;

annotationAssignment_atn[ annos ] locals[ assignment ]
@after { /* #ATN 2 */
  if ($assignment) {
    $annos.push( this.attachLocation($assignment) );
    this.docComment( $annos );
  }
} :
    '@'
    (
      annotationAssignment_paren[ annos ]
    |
      { $assignment = { name: {} }; }
      simplePath[ $assignment.name, 'anno' ]
      // #ATN: '#' can also start enum value, which can start an expression
      ( '#' variant=ident['variant'] { $assignment.name.variant = $variant.id; } )?
      // #ATN: ':' is optional continuation, ':' can follow from valuePath
      ( ':' val=value { $assignment.value = $val.val; } )?
    )
  ;

// Main artifact definitions -------------------------------------------------

requiredSemi
  : ';'
  | { return $ctx; }            // do not actually parse the closing brace
    '}'
  ;

optionalSemi
  : { this.noAssignmentInSameLine(); } // issue warning for } @Anno \n? NextDef
    ';'?
  ;

artifactDef[ outer, defOnly = false ] locals[ annos = [] ] // cannot use `parent` as parameter name!
@after{ /* #ATN 2 */ }
  :
    { this.docComment( $annos ); }
    annotationAssignment_ll1[ $annos ]*
    (
      DEFINE?
      ( contextDef[ $outer, this.startLocation(), $annos, defOnly ]
      | entityDef[ $outer, this.startLocation(), $annos ]
      | typeDef[ $outer, this.startLocation(), $annos ]
      | aspectDef[ $outer, this.startLocation(), $annos ]
      | annotationDef[ $outer, this.startLocation(), $annos ]
      | constDef[ $outer, this.startLocation(), $annos ]
      | viewDef[ $outer, this.startLocation(), $annos ]
      | eventDef[ $outer, this.startLocation(), $annos ]
      | actionFunctionMainDef[ $outer, this.startLocation(), $annos ]
      )
    |
      extend=EXTEND
      { if (defOnly) // this is a syntax restriction which is ensured in CSN in
                     // another way
          this.message( 'syntax-extend-context', $extend,
                        { code: 'EXTEND artifact', kind: defOnly },
                        'Error', 'No $(CODE) within $(KIND) extensions' ); }
      // #ATN: EXTEND elem, while CONTEXT, ENTITY etc are not reserved
      ( extendContext[ $outer, this.startLocation(), $annos ]
      | extendEntity[ $outer, this.startLocation(), $annos ]
      | extendProjection[ $outer, this.startLocation(), $annos ]
      | extendType[ $outer, this.startLocation(), $annos ]
      | extendAnnotation[ $outer, this.startLocation(), $annos ]
      | extendConst[ $outer, this.startLocation(), $annos ]
      | extendView[ $outer, this.startLocation(), $annos ]
        // TODO: what about extendAction
      | extendArtifact[ $outer, this.startLocation(), $annos ]
      )
    |
      annotate=ANNOTATE
      { if (defOnly) // this is a syntax restriction which is ensured in CSN in
                     // another way
          this.message( 'syntax-extend-context', $annotate,
                        { code: 'ANNOTATE artifact', kind: defOnly },
                        'Error', 'No $(CODE) within $(KIND) extensions' ); }
      annotateArtifact[ $outer, this.startLocation(), $annos ] // not kind-specific
    )
  ;

contextDef[ outer, loc, annos, defOnly = false ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    ( CONTEXT | abs=ABSTRACT? service=SERVICE ) simplePath[ $name, $service ? 'Service' : 'Context' ]
    // TODO: remove ABSTRACT SERVICE
    { $art = this.addDef( $outer, 'artifacts', $service ? 'service' : 'context', $name, $annos,
                          { abstract: $abs }, $loc );
      this.docComment( $annos ); }
    annotationAssignment_fix[ $annos ]*
    (
      ':'
      includeRef[ $art ]
      ( ',' { if (this.isStraightBefore('{')) break; } // allow ',' before '{'
        includeRef[ $art ]
      )*
    )?
    (
      '{' artifactDef[ $art, defOnly ]* '}'
      optionalSemi
    |
      requiredSemi
    )
  ;

extendContext[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    ( CONTEXT | service=SERVICE ) simplePath[ $name, $service ? 'Service' : 'Context' ] // not 'Extend' here
    { $art = this.addItem( $outer, 'extensions', 'extend', $annos,
                           { name: $name, expectedKind: $service ? 'service' : 'context' },
                           $loc );  }
    ( WITH { this.noSemicolonHere(); } )?
    { this.docComment( $annos ); }
    annotationAssignment_ll1[ $annos ]*
    (
      '{'
      artifactDef[ $art, $service ? 'SERVICE' : 'CONTEXT' ]*
      '}'
      optionalSemi
    |
      requiredSemi
    )
  ;

entityDef[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    tmp=TEMPORARY? abs=ABSTRACT? ENTITY simplePath[ $name, 'Entity' ]
    { $art = this.addDef( $outer, 'artifacts', 'entity', $name, $annos,
                          { abstract: $abs }, $loc );
      this.hanaFlavorOnly( $tmp );
      this.docComment( $annos ); }
    annotationAssignment_fix[ $annos ]*
    entityParameters[ $art ]?
    (
      ( ':'
        includeRef[ $art ]
        ( ',' { if (this.isStraightBefore('{')) break; } // allow ',' before '{'
          includeRef[ $art ]
        )*
      )?
      '{'
      { $art.elements = Object.create(null); } // better for include and annotate
      (
        elementDef[ $art ]+
        // In HANA CDS, we had SERIES(...) - if we reintroduce it, do a token
        // rewrite and match SERIESbeforePAREN to avoid adaptive prediction
      )?
      '}'
      // TODO: action definitions in a specific section?
      ( ACTIONS '{' actionFunctionDef[ $art ]+ '}' )?
      technicalConfiguration[ $art ]?     // defined in a section below
      optionalSemi
    |
      AS
      ( qe=queryExpression
        { $art.query = $qe.query; $art.kind = 'view'; $art['$'+'syntax'] = 'entity' }
        ( ACTIONS '{' actionFunctionDef[ $art ]+ '}' optionalSemi
        | requiredSemi
        )
      | qp=projectionSpec
        { $art.query = $qp.query; $art.projection = {}; $art['$'+'syntax'] = 'projection' } // TODO: remove `projection`
        ( ACTIONS '{' actionFunctionDef[ $art ]+ '}' )?
        optionalSemi
      )
    )
  ;

projectionSpec returns[ query ] locals[ src = {} ]
@after { this.attachLocation($query); }
  :
    proj=PROJECTION ON               // FIXME: First draft only, details unclear/unspecified
    // now a simplified `tableTerm`:
    { $query = { op: this.tokenLocation( $proj, undefined, 'query' ), from: [ $src ] }; }
    simplePath[ $src, 'artref' ]
    ( AS aliasName=ident['FromAlias'] { $src.name = $aliasName.id } )?
    (
      '{'
      { $query.columns = []; }  // set it early to avoid "wildcard" errors
      ( star='*'
        {
          $query.columns = [ { location: this.tokenLocation($star), val: '*', literal: 'token' } ];
        }
      |
        projectionWithOptAlias[ $query ]
      )
      ( ',' { if (this.isStraightBefore('}')) break; } // allow ',' before '}'
        projectionWithOptAlias[ $query ]
      )*
      '}'
    )?
    (
      // syntax is less than ideal - EXCLUDING is only useful for `*` - with
      // this syntax, people wonder what happens with explicit select items
      EXCLUDING
      '{'
      projectionExclusion[ $query ]
      ( ',' { if (this.isStraightBefore('}')) break; } // allow ',' before '}'
        projectionExclusion[ $query ]
      )*
      '}'
    )?
  ;

projectionExclusion[ outer ] locals[ art ]
@after { this.attachLocation($art); }
  :
    name=ident['ref']
    { $art = this.addDef( $outer, 'exclude', '', $name.id ); }
  ;

// TODO: restriction in comparison to `selectItemDef` completly unclear
projectionWithOptAlias[ outer ] locals[ art, alias, annos = [], item = {} ]
@after { this.attachLocation($art); }
  :
    { this.docComment( $annos ); }
    annotationAssignment_ll1[ $annos ]*
    key=KEY?
    simplePath[ $item, 'ref' ]
    { $art = this.addItem( $outer, 'columns', null, $annos, { value: $item, key: $key }); }
    ( AS aident=ident['Item'] { $art.name = $aident.id }
    | { this.classifyImplicitName( 'Item', $item ); }
    )
    { this.docComment( $annos ); }
    annotationAssignment_fix[ $annos ]*
    ( ':' re=REDIRECTED to=TO
      { $art.redirected = this.tokenLocation($re,$to,true); $art.target = {}; }
      simplePath[ $art.target, 'artref' ] // TODO: probably disallow in parseToCqn()
      { this.docComment( $annos ); }
      annotationAssignment_ll1[ $annos ]*
    )?
  ;

extendEntity[ outer, loc, annos ] locals[ art, name = {} ]
@after { /* #ATN 1 */ this.attachLocation($art); }
  :
    ENTITY simplePath[ $name, 'Extend' ]
    { $art = this.addItem( $outer, 'extensions', 'extend', $annos,
                           { name: $name, expectedKind: 'entity' }, $loc );  }
    (
      WITH { this.noSemicolonHere(); this.docComment( $annos ); }
      annotationAssignment_ll1[ $annos ]*
      // ATN: the ref can start with ACTIONS
      (
        includeRef[ $art ]
        requiredSemi
      |
        extendForEntity[ $art ]
      )
    |
      { this.docComment( $annos ); }
      annotationAssignment_ll1[ $annos ]*
      extendForEntity[ $art ]
    )
  ;

extendForEntity[ art ]
  :
    '{'
    elementDefOrExtend[ $art ]*
    '}'
    ( ACTIONS '{' actionFunctionDef[ $art ]* '}' )?
    technicalConfiguration[ $art ]?
    optionalSemi
  |
    ACTIONS '{' actionFunctionDef[ $art ]* '}'
    technicalConfiguration[ $art ]?
    optionalSemi
  |
    technicalConfiguration[ $art ]
    optionalSemi
  |
    requiredSemi
  ;

extendProjection[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    expected=PROJECTION simplePath[ $name, 'Extend' ]
    {
      $art = this.addItem( $outer, 'extensions', 'extend', $annos,
                           { name: $name, expectedKind: 'entity' }, // or 'projection'?
                           $loc );  }
    ( WITH { this.noSemicolonHere(); } )?
    { this.docComment( $annos ); }
    annotationAssignment_ll1[ $annos ]*
    (
      '{'
      projectionWithOptAlias[ $art ]
      ( ',' { if (this.isStraightBefore('}')) break; } // allow ',' before '}'
        projectionWithOptAlias[ $art ]
      )*
      '}'
      ( ACTIONS '{' actionFunctionDef[ $art ]+ '}' )?
      optionalSemi
    |
      ACTIONS '{' actionFunctionDef[ $art ]+ '}'
      optionalSemi
    |
      requiredSemi
    )
  ;

// TODO: no action extension?
actionFunctionDef[ outer ] locals[ art, annos = [] ]
@after { this.attachLocation($art); }
  :
    { this.docComment( $annos ); }
    annotationAssignment_ll1[ $annos ]*
    (
      ACTION name=ident['BoundAction']
      { $art = this.addDef( $outer, 'actions', 'action', $name.id, $annos );
        this.docComment( $annos ); }
      annotationAssignment_fix[ $annos ]*
      parameterListDef[ $art ]
      ( returnTypeSpec[ $art, $annos ] | requiredSemi )
    |
      FUNCTION name=ident['BoundAction']
      { $art = this.addDef( $outer, 'actions', 'function', $name.id, $annos );
        this.docComment( $annos ); }
      annotationAssignment_fix[ $annos ]*
      parameterListDef[ $art ]
      returnTypeSpec[ $art, $annos ]
    )
  ;

actionFunctionMainDef[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    ACTION simplePath[ $name, 'Action' ]
    { $art = this.addDef( $outer, 'artifacts', 'action', $name, $annos, {}, $loc );
      this.docComment( $annos ); }
    annotationAssignment_fix[ $annos ]*
    parameterListDef[ $art ]
    ( returnTypeSpec[ $art, $annos ] | requiredSemi )
  |
    FUNCTION simplePath[ $name, 'Action' ]
    { $art = this.addDef( $outer, 'artifacts', 'function', $name, $annos, {}, $loc );
      this.docComment( $annos ); }
    annotationAssignment_fix[ $annos ]*
    parameterListDef[ $art ]
    returnTypeSpec[ $art, $annos ]
  ;

eventDef[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    EVENT simplePath[ $name, 'Event' ]
    { $art = this.addDef( $outer, 'artifacts', 'event', $name, $annos, {}, $loc );
      this.docComment( $annos ); }
    annotationAssignment_fix[ $annos ]*
    ':'?
    typeStruct[ $art ]
    optionalSemi
  ;

aspectDef[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    ASPECT simplePath[ $name, 'Type' ]
    { $art = this.addDef( $outer, 'artifacts', 'type', $name, $annos, { ['$'+'syntax']: 'aspect' }, $loc );
      this.docComment( $annos ); }
    annotationAssignment_fix[ $annos ]*
    typeSpecSemi[ $art, $annos ]
    {
      if (!$art.elements)
        this.message( null, $art.name.location, {},
                      'Error', 'An aspect definition must have elements' );
    }
  ;

typeDef[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    ( TYPE | db=TABLE TYPE ) simplePath[ $name, 'Type' ]
    { $art = this.addDef( $outer, 'artifacts', 'type', $name, $annos, { dbType: $db }, $loc );
      this.docComment( $annos ); }
    annotationAssignment_fix[ $annos ]*
    typeSpecSemi[ $art, $annos ]
  ;

extendType[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    TYPE simplePath[ $name, 'Extend' ]
    { $art = this.addItem( $outer, 'extensions', 'extend', $annos,
                           { name: $name, expectedKind: 'type' },
                           $loc );  }
    extendWithOptElements[ $art, $annos ]
  ;

annotationDef[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    ANNOTATION simplePath[ $name, 'AnnoDef' ]
    { $art = this.addDef( $outer, 'artifacts', 'annotation', $name, $annos, {}, $loc );
      this.docComment( $annos ); }
    annotationAssignment_fix[ $annos ]*
    typeSpecSemi[ $art, $annos ] // also 'includes'...
  ;

extendAnnotation[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    ANNOTATION simplePath[ $name, 'Extend' ]
    { $art = this.addItem( $outer, 'extensions', 'extend', $annos,
                           { name: $name, expectedKind: 'annotation' },
                           $loc );  }
    extendWithOptElements[ $art, $annos ]
  ;

extendArtifact[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    simplePath[ $name, 'Extend' ]
    { $art = this.addItem( $outer, 'extensions', 'extend', $annos,
                           { name: $name }, $loc );  }
    extendWithOptElements[ $art, $annos ]
  ;

extendWithOptElements[ art, annos ]
  :
    WITH { this.noSemicolonHere(); this.docComment( $annos ); }
    annotationAssignment_ll1[ $annos ]*
    (
      includeRef[ $art ]
      requiredSemi
    |
      '{'
      elementDefOrExtend[ $art ]*
      '}'
      optionalSemi
    |
      requiredSemi
    )
  |
    { this.docComment( $annos ); }
    annotationAssignment_ll1[ $annos ]*
    (
      '{'
      elementDefOrExtend[ $art ]*
      '}'
      optionalSemi
    |
      requiredSemi
    )
  ;

annotateArtifact[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    simplePath[ $name, 'Annotate' ]
    { $art = this.addItem( $outer, 'extensions', 'annotate', $annos, { name: $name }, $loc ); }
    ( WITH { this.noSemicolonHere(); } )?
    { this.docComment( $annos ); }
    annotationAssignment_ll1[ $annos ]*
    (
      '{'
      annotateElement[ $art ]*
      '}'
      (
        ACTIONS
        '{'
        annotateAction[ $art ]*
        '}'
      )?
      optionalSemi
    |
      ACTIONS
      '{'
      annotateAction[ $art ]*
      '}'
      optionalSemi
    |
      '('
      annotateParam[ $art ]
      ( ',' { if (this.isStraightBefore(')')) break; } // allow ',' before ')'
        annotateParam[ $art ]
      )*
      ')'
      (
        RETURNS '{'
        annotateElement[ $art ]*
        '}'
        optionalSemi
      |
        requiredSemi
      )
    |
      RETURNS '{'
      annotateElement[ $art ]*
      '}'
      optionalSemi

    |
      requiredSemi
    )
  ;

annotateElement[ outer ] locals[ art, annos = [] ]
@after{ this.attachLocation($art); }
  :
    { this.docComment( $annos ); }
    annotationAssignment_ll1[ $annos ]*
    name=ident['Element']
    { $art = this.addDef( $outer, 'elements', 'annotate', $name.id, $annos );
      this.docComment( $annos ); }
    annotationAssignment_ll1[ $annos ]*
    (
      '{'
      annotateElement[ $art ]*
      '}'
      optionalSemi
    |
      requiredSemi
    )
  ;

annotateAction [ outer ] locals [ art, annos = [] ]
@after{ this.attachLocation($art); }
  :
    { this.docComment( $annos ); }
    annotationAssignment_ll1[ $annos ]*
    name=ident['BoundAction']
    { $art = this.addDef( $outer, 'actions', 'annotate', $name.id, $annos );
      this.docComment( $annos ); }
    annotationAssignment_ll1[ $annos ]*
    (
      '('
      annotateParam[ $art ]
      ( ',' { if (this.isStraightBefore(')')) break; } // allow ',' before ')'
        annotateParam[ $art ]
      )*
      ')'
    )?
    (
      RETURNS '{'
      annotateElement[ $art ]*
      '}'
      optionalSemi
    |
      requiredSemi
    )
  ;

annotateParam [ outer ] locals [ art, annos = [] ]
@after{ this.attachLocation($art); }
  :
    { this.docComment( $annos ); }
    annotationAssignment_ll1[ $annos ]*
    param=ident['Param']
    { $art = this.addDef( $outer, 'params', 'annotate', $param.id, $annos );
      this.docComment( $annos ); }
    annotationAssignment_ll1[ $annos ]*
  ;

// Constant and Element definition and its helpers ---------------------------

constDef[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    c=CONST simplePath[ $name, 'Constant' ]
    { this.hanaFlavorOnly( $c );
      $art = this.addDef( $outer, 'artifacts', 'const', $name, $annos, {}, $loc );
      this.docComment( $annos ); }
    annotationAssignment_fix[ $annos ]*
    typeSpec[ $art ]?
    '=' expression
    requiredSemi
  ;

extendConst[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    CONST simplePath[ $name, 'Extend' ]
    { $art = this.addItem( $outer, 'extensions', 'extend', $annos,
                           { name: $name, expectedKind: 'const' },
                           $loc );  }
    ( WITH { this.noSemicolonHere(); } )?
    { this.docComment( $annos ); }
    annotationAssignment_ll1[ $annos ]*
    requiredSemi
  ;

enumSymbolDef[ outer ] locals[ art, annos = [] ]
@after { this.attachLocation($art); }
  :
    { this.docComment( $annos ); }
    annotationAssignment_ll1[ $annos ]*
    name=ident['Enum']
    { $art = this.addDef( $outer, 'enum', 'enum', $name.id, $annos );
      this.docComment( $annos ); }
    annotationAssignment_ll1[ $annos ]*
    ( '='
      { this.excludeExpected( ['Boolean', 'QuotedLiteral', "'#'", 'NULL'] ); }
      val=literalValue
      { $art.value = $val.val; this.docComment( $annos ); }
      annotationAssignment_ll1[ $annos ]*
    )?
    requiredSemi
  ;

elementDefOrExtend[ outer ] locals[ annos = [] ]
@after { /* #ATN 1 */ if ($ctx.art) this.attachLocation($art.art); }
// tool complains if I test for ($art)
  :
    { this.docComment( $annos ); }
    annotationAssignment_ll1[ $annos ]*
    // #ATN: element name for definition can be EXTEND
    (
      EXTEND
      extendElement[ $outer, this.startLocation(), $annos ]
    |
      art = elementDefInner[ $outer, this.startLocation(), $annos, true ]
    )
  ;

elementDef[ outer ] locals[ annos = [] ]
@after { this.attachLocation($art.art); }
  :
    { this.docComment( $annos ); }
    annotationAssignment_ll1[ $annos ]*
    art = elementDefInner[ $outer, this.startLocation(), $annos, false ]
  ;

// Actually, this is a subset if elementDefInner...
// TODO: the corresponding restrictions must also be checked in the core
// compiler, as the mixin element could come via CSN
mixinElementDef[ outer ] locals[ art ]
@after { /* #ATN 2 */ this.attachLocation($art); }
  :
    name=ident['Mixin']
    { $art = this.addDef( $outer, 'mixin', 'element', $name.id ); }
    (
      ':'
      // #ATN: referenced type name can be ASSOCIATION or COMPOSITION
      (
        typeAssociationBase[ $art, false ]
        // #ATN: path could start with MANY or ONE - make sure a token follows in same rule!
        ( typeToMany[ $art ] | typeToOne[ $art ] | simplePath[ $art.target, 'artref' ] )
        typeAssociationCont[ $art ]?
      |
        typeRefOptArgs[ $art ]
        ( as='=' expression
          { this.hanaFlavorOnly( 'Calculated fields are not supported yet', $as ); }
        )?
      )
    |
      as='=' expression
      { this.hanaFlavorOnly( 'Calculated fields are not supported yet', $as ); }
    )
    requiredSemi
  ;

misplacedAnnotations[ annos, messageId ]
  :
    annotationAssignment_ll1[ $annos ]+
    { if ($messageId)           // issue Warning (is standard severity)
        this.message( messageId, this.tokenLocation( $ctx.start, this.getCurrentToken() ) );
    }
  ;

elementDefInner[ outer, loc, annos, allowEq ] returns[ art ]
@after{ /* #ATN 6 */ }
  :
    // TODO: it would be excellent to remove ELEMENT...
    // or have a special ident rule without the ELEMENT
    // Reason: it would be good for error recover to start a major block without LL1 ambiguity
    // #ATN: element name can be VIRTUAL, MASKED or ELEMENT (3x)
    virtual=VIRTUAL? key=KEY? masked=MASKED?    // TODO: order?
    ELEMENT?
    name=ident['Element']
    { $art = this.addDef( $outer, 'elements', 'element', $name.id, $annos,
                          { virtual: $virtual, key: $key, masked: $masked },
                          $loc );
      this.docComment( $annos ); }
    annotationAssignment_fix[ $annos ]*
    // TODO: we can think of making the typeSpec optional and do checks instead:
    // type optional with '=', type required otherwise
    (
      typeStruct[ $art ]
      ( nullability[ $art ]
        requiredSemi
      | optionalSemi            // NOT and NULL are reserved...
      )
    |
      ':'
      // #ATN: referenced type name can be ASSOCIATION or ARRAY or TYPE or LOCALIZED
      (
        typeStruct[ $art ]
        nullability[ $art ]?
        misplacedAnnotations[ $annos, 'syntax-anno-after-struct' ]?
        requiredSemi
      |
        typeAssociationBase[ $art, true ]
        // #ATN: path could start with MANY or ONE - make sure a token follows in same rule!
        (
          // { this.setMaxCardinality( $art, this.getCurrentToken(), { literal: 'string', val: '*' }, 'type-composition' ); }
          typeStruct[ $art.target, true ] optionalSemi
        |
          one=ONE
          { this.setMaxCardinality( $art, $one, this.numberLiteral( $one, null, '1' ) ); }
          typeCompoStruct[ $art.target ] optionalSemi
        |
          many=MANY
          { this.setMaxCardinality( $art, $many, { literal: 'string', val: '*' } ); }
          typeCompoStruct[ $art.target ] optionalSemi
        |
          // we do not support `Composition of many { e }` - ambiguity ad-hoc target versus foreign keys!
          typeToMany[ $art ] typeAssociationElementCont[ $art, $annos ]
        |
          typeToOne[ $art ] typeAssociationElementCont[ $art, $annos ]
        |
          simplePath[ $art.target, 'artref' ] typeAssociationElementCont[ $art, $annos ]
        )
      |
        (
          array=ARRAY of=OF 
          { $art.items = { location: this.tokenLocation( $array, $of ) }; }
        | many=MANY
          { $art.items = { location: this.tokenLocation( $many ) };}
        )
        // #ATN: typeRefOptArgs can start with TYPE
        ( typeStruct[ $art.items ]
          misplacedAnnotations[ $annos, 'syntax-anno-after-struct' ]?
        | typeTypeOf[ $art.items ]
          { this.docComment( $annos ); }
          annotationAssignment_ll1[ $annos ]*
        | typeRefOptArgs[ $art.items ]
          { this.docComment( $annos ); }
          annotationAssignment_ll1[ $annos ]*
          ( ENUM '{' enumSymbolDef[ $art.items ]+ '}'
            misplacedAnnotations[ $annos, 'syntax-anno-after-enum' ]?
          )?
        )
        requiredSemi                     // also req after struct/enum
      |
        typeTypeOf[ $art ] elementProperties[ $art ]?
        { this.docComment( $annos ); }
        annotationAssignment_ll1[ $annos ]*
        requiredSemi                     // also req after foreign key spec
      |
        l=LOCALIZED { $art.localized = this.tokenLocation( $l, undefined, true ); }
        typeRefOptArgs[ $art ]
        { this.docComment( $annos ); }
        annotationAssignment_ll1[ $annos ]*
        ( elementProperties[ $art ]
          { this.docComment( $annos ); }
          annotationAssignment_ll1[ $annos ]*
        )?
        requiredSemi
      |
        typeRefOptArgs[ $art ]
        { this.docComment( $annos ); }
        annotationAssignment_ll1[ $annos ]*
        ( ENUM '{' enumSymbolDef[ $art ]+ '}'
          elementProperties[ $art ]?
          misplacedAnnotations[ $annos, 'syntax-anno-after-enum' ]?
        | elementProperties[ $art ]
          { this.docComment( $annos ); }
          annotationAssignment_ll1[ $annos ]*
        )?
        requiredSemi                     // also req after enum spec
      )
    |
      // this is also called for enum symbols (in EXTEND)
      ( as=AS | eq='=' ) e=expression
      {
        if ($as || !$allowEq || $e.expr && !$e.expr.literal )
          this.hanaFlavorOnly( 'Calculated fields are not supported yet', $as || $eq );
        else if ($e.expr)
          $art.value = $e.expr;
      }
      { this.docComment( $annos ); }
      annotationAssignment_ll1[ $annos ]* // for enum symbol def via EXTEND
      requiredSemi
    )
  ;

extendElement[ outer, loc, annos ] locals[ art ]
@after{ /* #ATN 1 */ this.attachLocation($art); }
  :
    // #ATN: element name can be ELEMENT
    expected=ELEMENT? name=ident['Element']
    { $art = this.addDef( $outer, 'elements', 'extend', $name.id, $annos,
                          { expectedKind: $expected && 'element' },
                          $loc ); }
    extendWithOptElements[ $art, $annos ]
  ;


selectItemDef[ outer ] locals[ art = {}, alias, annos = [], item = {} ] // AnnotatedQLSelectItem
@after{ /* #ATN 1 */ this.attachLocation($art); }
  :
    { this.docComment( $annos ); }
    annotationAssignment_atn[ $annos ]*
    key=KEY?
    (
      e=expression
      { $art = this.addItem( $outer, 'columns', null, $annos, { value: $e.expr, key: $key }); }
      ( AS n1=ident['Item'] { $art.name = $n1.id }
      | n2=ident['Item'] { $art.name = $n2.id }
      | { this.classifyImplicitName( 'Item', $e.expr ); }
      )
      // path as p1 { x as x1 }  // is utterly wrong - if allowed, only:
      // path { x as x1 } as p1
      (
        // TODO: only after simple path in expression
        selectItemInline        // "expand"
      |
        // TODO: only after simple path in expression, complain if AS had been used
        DOTbeforeBRACE selectItemInline // "inline"
      )?
    |
      selectItemInline
      ( AS n1=ident['Item'] { $alias=$n1.id } | n2=ident['Item'] { $alias=$n2.id } )
      {
        $art = this.addItem( $outer, 'columns', null,
                             $annos, { name: $alias, key: $key });
      }
    )
    { this.docComment( $annos ); }
    annotationAssignment_fix[ $annos ]*
    ( ':'
      // #ATN: typeRefOptArgs can start with TYPE
      ( re=REDIRECTED to=TO
        { $art.redirected = this.tokenLocation($re,$to,true); $art.target = {}; }
        simplePath[ $art.target, 'artref' ]
        typeAssociationCont[ $art ]?
      | typeTypeOf[ $art ]
      | typeRefOptArgs[ $art ]         // TODO: annos here?
      )
      {
        $art._typeIsExplicit = true; // FIXME: We probably need to deal with explicit vs. propagated in more places
      }
    )?
  ;

parameterListDef[ art ]
  :
    '('
    // also empty param list (we might do some hacking later to allow reserved words)
    // see annotationAssignment_paren
    (
      parameterDef[ $art ]
      ( ',' { if (this.isStraightBefore(')')) break; } // allow ',' before ')'
        parameterDef[ $art ]
      )*
    )?
    ')'
  ;

parameterDef[ outer ] locals[ art, annos = [] ]
@after { this.attachLocation($art); }
  :
    { this.docComment( $annos ); }
    annotationAssignment_ll1[ $annos ]*
    name=ident['Param']
    { $art = this.addDef( $outer, 'params', 'param', $name.id, $annos );
      this.docComment( $annos ); }
    annotationAssignment_fix[ $annos ]*
    typeSpec[ $art ]
    nullability[ $art ]?
    annotationAssignment_ll1[ $annos ]*
  ;

entityParameters[ art ]
  :
    '('
    // also empty param list (we might do some hacking later to allow reserved words)
    // see annotationAssignment_paren
    (
      entityParameterDef[ $art ]
      ( ',' { if (this.isStraightBefore(')')) break; } // allow ',' before ')'
        entityParameterDef[ $art ]
      )*
    )?
    ')'
  ;

entityParameterDef[ outer ] locals[ art, annos = [] ]
@after { this.attachLocation($art); }
  :
    { this.docComment( $annos ); }
    annotationAssignment_ll1[ $annos ]*
    name=ident['Param']
    { $art = this.addDef( $outer, 'params', 'param', $name.id, $annos );
      this.docComment( $annos ); }
    annotationAssignment_fix[ $annos ]*
    typeSpec[ $art ]
    // ( DEFAULT expr=expression { $art.default = $expr.expr; } )?
  ;

nullability[ art ]
  :
    not=NOT n1=NULL
    { $art.notNull = this.tokenLocation($not,$n1,true); }
  |
    n2=NULL
    { $art.notNull = this.tokenLocation($n2,undefined,false); }
  ;

elementProperties[ elem ]
@after{ /* #ATN 1 */ }
  :
    nullability[$elem]
    (
      DEFAULT expr=expression
      { $elem.default = $expr.expr; }
    )?
  |
    (
      DEFAULT expr=expression
      { $elem.default = $expr.expr; }
    )
    nullability[$elem]?
  |
    gen=GENERATED
    { this.hanaFlavorOnly( $gen ); }
    (
      ALWAYS AS
      // #ATN: expression can start with IDENTITY
      ( IDENTITY sequenceOptions[$elem]?
      | expression
      )
    |
      BY DEFAULT AS IDENTITY sequenceOptions[$elem]?
    )
  |
    ( as=AS | eq='=' )
    { this.hanaFlavorOnly( 'Calculated fields are not supported yet', $as || $eq ); }
    expression
  ;

sequenceOptions[ elem ] locals[ opts = {} ]
@after { $elem.sequenceOptions = this.attachLocation($opts); }
  :
    '('
    (
      tok=START swith=WITH swNum=value
      { this.setOnce( $opts, 'startWith', $swNum.val, $tok, $swith ); }
    |
      inc=INCREMENT by=BY ibNum=value
      { this.setOnce( $opts, 'incrementBy', $ibNum.val, $inc, $by ); }
    |
      min=MINVALUE minNum=value
      { this.setOnce( $opts, 'minvalue', $minNum.val, $min ); }
    |
      max=MAXVALUE maxNum=value
      { this.setOnce( $opts, 'maxvalue', $maxNum.val, $max ); }
    |
      cache=CACHE cacheNum=value
      { this.setOnce( $opts, 'cache', $cacheNum.val, $cache ); }
    |
      cycle=CYCLE
      { this.setOnce( $opts, 'cycle', true, $cycle ); }
    |
      no=NO
      ( nmin=MINVALUE { this.setOnce( $opts, 'minvalue', false, $no, $nmin ); }
      | nmax=MAXVALUE { this.setOnce( $opts, 'maxvalue', false, $no, $nmax ); }
      | ncache=CACHE { this.setOnce( $opts, 'cache', false, $no, $ncache ); }
      | ncycle=CYCLE { this.setOnce( $opts, 'cycle', false, $no, $ncycle ); }
      )
    )*
    (
      // Not the best idea to allow RESET BY query (without parens) also before
      // the other sequence options... now also done in HANA CDS
      reset=RESET rby=BY queryExpression//[ $opts, 'resetBy' ]
    )?
    ')'
  ;

// View definitions ----------------------------------------------------------

viewDef[ outer, loc, annos ] locals[ art, name = {} ]
@after { this.attachLocation($art); }
  :
    v=VIEW simplePath[ $name, 'Entity' ]
    { $art = this.addDef( $outer, 'artifacts', 'view', $name, $annos, { ['$'+'syntax']: 'view' }, $loc );
      this.docComment( $annos ); }
    annotationAssignment_fix[ $annos ]*
    (
      entityParameters[ $art ]
    |
      ( HideAlternatives | WITH ) PARAMETERS
      entityParameterDef[ $art ]
      ( ',' entityParameterDef[ $art ] )* // no optional final ',' here
    )?
    AS qe=queryExpression { $art.query = $qe.query; } // beta-mode test now in definer
    // TODO check ANTLR: bad msg with 'view V as'<eof> but 'view V as FOO' is fine
    requiredSemi
  ;

// Currently, EXTEND is not reserved
//   extend view V { @SomeAnno extend item; }
// Possibility 1: extend existing select item `item` with anno
// Possibility 2: define new select item `item` selecting path `extend`
// Solution: reserve EXTEND (at least at that place)

// if we say that <kind> is optional after EXTEND, what is
//   extend V { element item: Integer; }
// Possibility 1: V is type/entity -> new element `item`
// Possibility 2: V is view -> new select item `item` selecting path `element`
// Solution 1: VIEW is not optional for EXTEND VIEW
// Solution 2: reserve ELEMENT
// Solution 3: drop (optional) ELEMENT from syntax
// Solution 4: resolve ambuity by special rule, e.g. is element def

extendView[ outer, loc, annos ] locals [o = {}, art = {}]
  :
    v=VIEW simplePath[ $art, 'Extend' ]
    { this.hanaFlavorOnly( 'EXTEND VIEW is not supported', $v ); }
    ( WITH? '{'
      selectItemDef[$o]
      ( ',' { if (this.isStraightBefore('}')) break; } // allow ',' before '}'
        selectItemDef[$o]
      )*
      '}'
    )?
    requiredSemi
  ;

// Technical Configuration -----------------------------------------------------------

/*
TODO: If TCs for other DBMS than HANA shall be supported, split into sub rules
 */
technicalConfiguration[ outer ] locals [ tc = {} ]
@after { this.attachLocation($tc); }
  :
    t=TECHNICAL? backend=HANA? CONFIGURATION
    {
      if ($backend.text)
        $tc.backend = this.tokenLocation($backend, undefined, $backend.text.toLowerCase() );
      else
        $tc.backend = { val: 'hana', calculated: true };
      $outer.technicalConfig = $tc;
    }
    '{'
    (
      migration[ $tc ]
    | storeType[ $tc ]
    | usingExtendedStorage[ $tc ]
    | index[ $tc, this.startLocation() ]
    | fullTextIndex[ $tc, this.startLocation() ]
    | fuzzyIndex[ $tc, this.startLocation() ]
    | partition[ $tc, this.startLocation() ]
    | tableGroup[ $tc ]
    | unloadPriority[ $tc ]
    | autoMerge[ $tc ]
    )*
    '}'
  ;

migration[ tc ]
  :
    mi=MIGRATION ed=(ENABLED|DISABLED)
    { this.setOnce( $tc, 'migration', this.tokenLocation( $ed, undefined, $ed.text.toLowerCase()), $mi ); }
    requiredSemi
  ;

storeType[ tc ]
  :
    type=(ROW|COLUMN) store=STORE
    { this.setOnce( $tc, 'storeType', this.tokenLocation( $type, undefined, $type.text.toLowerCase() ), $type, $store ); }
    requiredSemi
  ;

usingExtendedStorage[ tc ]
  :
    u=USING e=EXTENDED s=STORAGE requiredSemi
    { this.setOnce( $tc, 'extendedStorage', this.tokenLocation($u, $s, true), $u, $e, $s ); }
  ;

index[ tc, loc ] locals [ idx, props = { columns: [] }, name = {}, annos = [] ]
@after { this.attachLocation($idx); }
  :
    ( u=UNIQUE { $props.unique = this.tokenLocation($u, undefined, true); } )?
    /*
    (   'BTREE'   { index->type = QPC_INDEX_BTREE; }
      | 'CPBTREE' { index->type = QPC_INDEX_CPBTREE; }
    )?
    */
    INDEX idxName=ident['Index'] ON '(' simplePath[ $name, 'ref' ]
    ( o1=ascDesc { $name.sort = $o1.order; } )?
    { $props.columns.push($name); }
    (
      ',' { if (this.isStraightBefore(')')) break; } // allow ',' before ')'
      { $name = {}; }
      simplePath[ $name, 'ref' ]
      ( on=ascDesc { $name.sort = $on.order; } )?
      { $props.columns.push($name); }
    )*
    ')'
    ( og=ascDesc { $props.sort = $og.order } )?
    requiredSemi
    { $idx = this.addDef( $tc, 'indexes', 'index',
                          $idxName.id, $annos,
                          $props, $loc );
      delete $idx.annotationAssignments;
    }
  ;

ascDesc returns [ order ]
  :
    ad=(ASC|DESC)
    { $order = this.tokenLocation( $ad, undefined, $ad.text.toLowerCase() ); }
  ;

fullTextIndex[ tc, loc ] locals [ fti, props = { columns: [] }, name = {} ]
@after { this.attachLocation($fti); }
  :
    FULLTEXT INDEX ftiName=ident['Index'] ON '(' simplePath[ $name, 'ref' ] ')'
    { $props.columns.push($name);
      $fti = this.addDef( $tc, 'indexes', 'fulltextindex',
                          $ftiName.id, false,
                          $props, $loc );
    }
    fulltextIndexParameters[ $fti ]* requiredSemi
  ;

fulltextIndexParameters[ fti ] locals [ name = {}, val ]
  :
    l=LANGUAGE
    { if (!$fti.language) $fti.language = {}; }
    (
      c=COLUMN simplePath[ $name, 'ref' ]
      { this.setOnce( $fti.language, 'column', $name, $l, $c ); }
    | d=DETECTION
      { this.setOnce( $fti.language, 'detection',[], $l, $d ); }
      '(' s1=String
      { $fti.language.detection.push( this.quotedLiteral( $s1, 'string' ) ); }
      ( ',' { if (this.isStraightBefore(')')) break; } // allow ',' before ')'
        sn=String
        { $fti.language.detection.push( this.quotedLiteral( $sn, 'string' ) ); }
      )*
      ')'
    )
  | m=MIME t=TYPE
    ( c=COLUMN simplePath[ $name, 'ref' ]
      { this.setOnce( $fti, 'mimeTypeColumn', $name, $m, $t, $c ); }
    | str=String
      { this.setOnce( $fti, 'mimeType', this.quotedLiteral( $str, 'string' ), $m, $t ); }
    )
  | f=FUZZY s=SEARCH i=INDEX sw=onOff
    { this.setOnce( $fti, 'fuzzySearchIndex', $sw.val, $f, $s, $i ); }
  | p=PHRASE i=INDEX r=RATIO tok=Number
    { this.setOnce( $fti, 'phraseIndexRatio', this.numberLiteral($tok,''), $p, $i, $r ); }
  | c=CONFIGURATION str=String
    { this.setOnce( $fti, 'configuration', this.quotedLiteral($str, 'string'), $c ); }
  | s=SEARCH o=ONLY sw=onOff
    { this.setOnce( $fti, 'searchOnly', $sw.val, $s, $o ); }
  | f=FAST p=PREPROCESS sw=onOff
    { this.setOnce( $fti, 'fastPreprocess', $sw.val, $f, $p ); }
  | t=TOKEN s=SEPARATORS str=String
    { this.setOnce( $fti, 'tokenSeparators', this.quotedLiteral( $str, 'string' ), $t, $s ); }
  | t=TEXT
    (
      a=ANALYSIS sw=onOff
      { this.setOnce( $fti, 'textAnalysis', $sw.val, $t, $a ); }
    |
      m=MINING
      { if (!$fti.textMining) $fti.textMining = {}; }
      ( sw=onOff
        { this.setOnce( $fti.textMining, 'state', $sw.val, $t, $m ); }
      | c=CONFIGURATION o=OVERLAY? s=String
        { if (!$o)
          this.setOnce( $fti.textMining, 'config', this.quotedLiteral( $s, 'string' ), $t, $m, $c );
          else
            this.setOnce( $fti.textMining, 'overlay', this.quotedLiteral( $s, 'string' ), $t, $m, $c, $o );
      }
      )
    )
  | fullTextChangeTracking[ $fti ]
  ;

onOff returns [ val ]
  :
    tok=(ON|OFF)
    { $val = this.tokenLocation( $tok, undefined, $tok.text.toLowerCase() ); }
  ;

fullTextChangeTracking[ fti ] locals [ ct = {} ]
  :
    tok=(SYNC|SYNCHRONOUS)
    {
      // copy token and rewrite text for setOnce()
      $ct = Object.assign({}, $tok);
      $ct.text = 'change tracking';
      this.setOnce( $fti, 'changeTracking',
                    { mode: this.tokenLocation( $tok, undefined, $tok.text.toLowerCase() ) }, $ct );
    }
  | tok=(ASYNC|ASYNCHRONOUS)
    {
      $ct = Object.assign({}, $tok);
      $ct.text = 'change tracking';
      this.setOnce( $fti, 'changeTracking',
                   { mode: this.tokenLocation( $tok, undefined, $tok.text.toLowerCase() ) }, $ct);
    }
    (
      spec=asyncSpec
      { $fti.changeTracking.asyncSpec = $spec.val; }
    )?
  ;

asyncSpec returns [ val ]
@init { $val = {}; }
  :
    FLUSH
    ( tok=QUEUE
      { $val.queue = this.tokenLocation( $tok, undefined, $tok.text.toLowerCase() ); }
    )?
    (
      EVERY min=Number MINUTES (OR AFTER doc=Number DOCUMENTS)?
      { if ($min) $val.minutes = this.numberLiteral($min,'');
        if ($doc) $val.documents = this.numberLiteral($doc);
      }
    | AFTER doc=Number DOCUMENTS
      { if ($doc) $val.documents = this.numberLiteral($doc); }
    )
  ;

fuzzyIndex[ tc, loc ] locals [ idx, name = {} ]
@init { if(!$tc.fzindexes)
  $tc.fzindexes = [];
}
@after { this.attachLocation($idx);
         $tc.fzindexes.push($idx);
}
  :
    FUZZY SEARCH INDEX ON '(' simplePath[ $name, 'ref' ] ')'
    { $idx = { columns: [ $name ], location: $loc };  }
    ( f=FUZZY SEARCH m=MODE
      { $idx.fuzzy = this.tokenLocation($f, $m, true); }
      (s=String
        { $idx.fuzzy.mode = this.quotedLiteral($s, 'string'); }
      )?
    )?
    requiredSemi
  ;

partition[ tc ]
  :
    p=PARTITION b=BY
    { this.setOnce( $tc, 'partition', { specs: [] }, $p, $b ); }
    (
      k=KEEPING e=EXISTING l=LAYOUT
      { $tc.partition.specs.push({ scheme: this.tokenLocation( $k, $l, 'keeping existing layout' ) }); }
    | ps1=partitionSpec
      { $tc.partition.specs.push($ps1.spec);
      }
      ( ',' psn=partitionSpec
        { $tc.partition.specs.push($psn.spec); }
      )?
    )
    ( WITH PARTITIONING ON ANY COLUMNS sw=onOff
      { $tc.partition.wpoac = $sw.val; }
    )?
    requiredSemi
  ;

partitionSpec returns [ spec ]
@init { $spec = {} }
  :
    roundRobinPartition[ $spec ]
  | hashPartition[ $spec ]
  | rangePartition[ $spec ]
  ;


roundRobinPartition [ spec ]
  :
    s=ROUNDROBIN p=PARTITIONS np=numberPartitions
    { $spec.scheme = this.tokenLocation( $s, undefined, $s.text.toLowerCase());
      $spec.partitions = $np.val;
    }
  ;

hashPartition [ spec ]
  :
    s=HASH '(' cols=partitionColumns ')' p=PARTITIONS np=numberPartitions
    { $spec.scheme = this.tokenLocation( $s, undefined, $s.text.toLowerCase());
      $spec.columns = $cols.val;
      $spec.partitions = $np.val;
    }
  ;

partitionColumns returns [ val ]
@init { $val = []; }
  :
    p1=partitionColumn
    { $val.push($p1.val); }
    ( ',' pn=partitionColumn
      { $val.push($pn.val); }
    )*
  ;

partitionColumn returns [ val ]
@init { $val = {} }
@after{ /* #ATN 1 */ }
  :
    // ATN: the path can start with identifier YEAR or MONTH
    simplePath[ $val, 'ref' ]
  | mod=(YEAR|MONTH) '(' simplePath[ $val, 'ref' ] ')'
    { $val.unit = this.tokenLocation( $mod, undefined, $mod.text.toLowerCase() ); }
  ;


rangePartition [ spec ]
  :
    s=RANGE '(' expr=partitionColumns ')'
    { $spec.scheme = this.tokenLocation( $s, undefined, $s.text.toLowerCase() );
      $spec.columns = $expr.val;
      $spec.ranges = [];
    }
    '('
    ( partitionRanges[ $spec.ranges, 'default' ]
    | storePartitionRanges[ $spec ]
    )
    ')'
  ;

storePartitionRanges[ spec ]
  :
    storePartitionSpec[ $spec ] storePartitionSpec[ $spec ]*
  ;

storePartitionSpec[ spec ]
@init { $spec.withStorageSpec = true; }
  :
    USING tok=(DEFAULT|EXTENDED)
    STORAGE '(' partitionRanges[ $spec.ranges, $tok.text.toLowerCase() ] ')'
  ;

partitionRanges [ ranges, store ]
  :
    r1=rangeSpec
    { $r1.val.store = $store;
      $ranges.push( $r1.val);
    }
    ( ',' rn=rangeSpec
      { $rn.val.store = $store;
        $ranges.push($rn.val);
      }
    )*
  ;

rangeSpec returns [ val = {} ]
@after { this.attachLocation($val); }
  :
    p=PARTITION
    (
      min=rangeValue '<=' VALUES '<' max=rangeValue
      { $val.min = $min.val; $val.max = $max.val; }
    |
      (VALUE | VALUES) '=' min=rangeValue
      { $val.min = $min.val; }
      (
        IS CURRENT
        { $val.isCurrent = true; }
      )?
    | tok=OTHERS
      { $val.others = this.tokenLocation($p, $tok, $tok.text.toLowerCase()); }
    )
  ;

rangeValue returns [ val ]
  :
  | n=Number  { $val = this.numberLiteral($n,''); }
  | s=String  { $val = this.quotedLiteral($s, 'string'); }
  | b=Boolean { $val = { literal: 'boolean', val: $b.text.toLowerCase() != 'false' }; }
  ;

numberPartitions returns [ val ]
  :
    n=Number { $val = this.numberLiteral($n); }
  | g=GETNUMSERVERS '(' cb=')' { $val = this.tokenLocation($g, $cb, 'get_num_servers()'); }
  ;

tableGroup[ tc ]
  :
    tableGroupSpec[ $tc ]+ requiredSemi
  ;

tableGroupSpec[ tc ]
  :
    g=GROUP
    {
      if(!$tc.group)
        $tc.group = {};
    }
    (
      n=NAME id=ident['unknown']
      { this.setOnce( $tc.group, 'name', $id.id, $g, $n ); }
    | t=TYPE id=ident['unknown']
      { this.setOnce( $tc.group, 'type', $id.id, $g, $t ); }
    | s=SUBTYPE id=ident['unknown']
      { this.setOnce( $tc.group, 'subType', $id.id, $g, $s ); }
    )
  ;

unloadPriority[ tc ]
  :
    u=UNLOAD p=PRIORITY num=Number requiredSemi
    {
      this.setOnce( $tc, 'unloadPrio', this.numberLiteral($num), $u, $p );
    }

  ;

autoMerge[ tc ] locals [ val ]
  :
    no=NO? a=AUTO m=MERGE requiredSemi
    { if ($no.text)
      $val = this.tokenLocation($no, undefined, false);
      else
        $val = this.tokenLocation($a, undefined, true);
      this.setOnce( $tc, 'autoMerge', $val, $a, $m);
    }
  ;

// Type references -----------------------------------------------------------

includeRef[ art ] locals[ incl = {} ]
  :
    simplePath[ $incl, 'artref' ]
    { if ($art.includes) $art.includes.push($incl); else $art.includes = [$incl]; }
  ;

typeSpec[ art ]                 // for CONST, params
@after{ /* #ATN 1 */ }
  :
    typeStruct[ $art ]
  |
    ':'
    // #ATN: typeSimple can start with ARRAY or TYPE
    ( typeStruct[ $art ]
    | typeArray[ $art ]
    | typeTypeOf[ $art ]
      // TODO: no LOCALIZED ?
    | typeRefOptArgs[ $art ]
      ( ENUM '{' enumSymbolDef[ $art ]+ '}' )?
    )
  ;

returnTypeSpec[ art, annos ]
@after{ /* #ATN 1 */ }
  :
    ret=RETURNS { $art.returns = { location: this.tokenLocation( $ret ) }; }
    // #ATN: typeSimple can start with ARRAY or TYPE
    ( typeStruct[ $art.returns ]
    | typeArray[ $art.returns ]
    | typeTypeOf[ $art.returns ]
      // TODO: no LOCALIZED ?
    | typeRefOptArgs[ $art.returns ]
      ( ENUM '{' enumSymbolDef[ $art.returns ]+ '}'
      | misplacedAnnotations[ $annos, 'syntax-anno-after-params' ]
      )?
    )
    requiredSemi // currently for all - might change if we get rid of the misplaced annos
  ;


typeSpecSemi[ art, annos ]      // with 'includes', for type and annotation defs
@after{ /* #ATN 3 */ }
  :
    typeStruct[ $art ]
    optionalSemi
  |
    ':'
    // #ATN: typeRefOptArgs can start with ARRAY or ASSOCIATION or TYPE or LOCALIZED
    (
      typeStruct[ $art ]
      optionalSemi
    |
      typeAssociationBase[ $art, false ]
      // #ATN: path could start with MANY or ONE - make sure a token follows in same rule!
      ( typeToMany[ $art ] | typeToOne[ $art ] | simplePath[ $art.target, 'artref' ] )
      typeAssociationCont[ $art ]?
      requiredSemi                       // and if its the ';'...
    |
        (
          array=ARRAY of=OF
          { $art.items = { location: this.tokenLocation( $array, $of ) }; }
          | many=MANY
          { $art.items = { location: this.tokenLocation( $many ) };}
        )
      // #ATN: typeRefOptArgs can start with TYPE
      ( typeStruct[ $art.items ] optionalSemi
      | typeTypeOf[ $art.items ]
        { this.docComment( $annos ); }
        annotationAssignment_ll1[ $annos ]* requiredSemi
      | typeRefOptArgs[ $art.items ]
        { this.docComment( $annos ); }
        annotationAssignment_ll1[ $annos ]*
        ( ENUM '{' enumSymbolDef[ $art.items ]+ '}' optionalSemi | requiredSemi )
      )
    |
      typeTypeOf[ $art ]
      { this.docComment( $annos ); }
      annotationAssignment_ll1[ $annos ]* requiredSemi
    |
      l=LOCALIZED { $art.localized = this.tokenLocation( $l, undefined, true ); }
      typeRefOptArgs[ $art ]
      { this.docComment( $annos ); }
      annotationAssignment_ll1[ $annos ]*
      requiredSemi
    |
      { $art.type = {}; }
      simplePath[ $art.type, 'artref' ]
      (
        '('
        head=Number
        { $art.typeArguments = [ this.numberLiteral( $head ) ]; }
        ( ',' { if (this.isStraightBefore(')')) break; } // allow ',' before ')'
          tail=Number
          { $art.typeArguments.push( this.numberLiteral( $tail ) ); }
        )*
        ')'
        { this.docComment( $annos ); }
        annotationAssignment_ll1[ $annos ]*
        ( ENUM '{' enumSymbolDef[ $art ]+ '}' optionalSemi| requiredSemi )
      |
        { this.docComment( $annos ); }
        annotationAssignment_ll1[ $annos ]*
        ( ENUM '{' enumSymbolDef[ $art ]+ '}' optionalSemi | requiredSemi )
      |
        // TODO: complain if used in anno def?
        { $art.includes = [ $art.type ]; delete $art.type; }
        ( ',' { if (this.isStraightBefore('{')) break; } // allow ',' before '{'
          includeRef[ $art ]
        )*
        typeStruct[ $art ]
        optionalSemi
      )
    )
  ;

typeStruct[ art, attachLoc = false ]
@after { if ($attachLoc) this.attachLocation($art); }
  :
    { $art.elements = Object.create(null); } // we allow empty structures
    '{' elementDef[ $art ]* '}'
  ;

typeCompoStruct[ art ]
@after { this.attachLocation($art); }
  :
    { $art.elements = Object.create(null); } // we allow empty structures
    COMPOSITIONofBRACE elementDef[ $art ]* '}'
  ;

typeArray[ art ]
@after { /* #ATN 1 */ }
  :
    (
      array=ARRAY of=OF
      { $art.items = { location: this.tokenLocation( $array, $of ) }; }
      | many=MANY
      { $art.items = { location: this.tokenLocation( $many ) };}
    )
    // #ATN: typeRefOptArgs can start with TYPE
    ( typeStruct[ $art.items ]
    | typeTypeOf[ $art.items ]
    | typeRefOptArgs[ $art.items ]
    ( ENUM '{' enumSymbolDef[ $art.items ]+ '}' )?
    )
  ;

typeAssociationBase[ art, handleTypeCompo ] // including Composition
  :
    (
      assoc=ASSOCIATION cardinality[$art]? TO
      {{
        let location = this.tokenLocation($assoc);
        $art.type = { path: [{ id: 'cds.Association', location }], scope: 'global', location };
        this.handleComposition( $art.cardinality, false );
      }}
    |
      compo=COMPOSITION cardinality[$art]? OF
      {{
        let location = this.tokenLocation($compo);
        $art.type = { path: [{ id: 'cds.Composition', location }], scope: 'global', location };
        this.handleComposition( $art.cardinality, handleTypeCompo );
      }}
    )
    { $art.target = {}; }
  ;

typeAssociationCont[ art ]
  :
    (
      '{'
      foreignKey[ $art ]
      ( ',' { if (this.isStraightBefore('}')) break; } // allow ',' before '}'
        foreignKey[ $art ]
      )*
      '}'
    |
      ON cond=condition
      // FIXME: 'art.onCond' is what we actually want, but for now, we also take the plain text of the whole condition (including whitespace) into 'art.on'
      { $art.onCond=$cond.cond; $art.on = this._ctx.parser._input.tokenSource._input.strdata.substring($cond.start.start, $cond.stop.stop + 1); }
    )
  ;

typeAssociationElementCont[ art, annos ] // including Composition
// optional NULL / NOT NULL for managed association only
  :
    (
      '{'
      foreignKey[ $art ]
      ( ',' { if (this.isStraightBefore('}')) break; } // allow ',' before '}'
        foreignKey[ $art ]
      )*
      '}'
      nullability[ $art ]?
    |
      ON cond=condition
      // FIXME: 'art.onCond' is what we actually want, but for now, we also take the plain text of the whole condition (including whitespace) into 'art.on'
      { $art.onCond=$cond.cond; $art.on = this._ctx.parser._input.tokenSource._input.strdata.substring($cond.start.start, $cond.stop.stop + 1); }
    |
      nullability[ $art ]
    )?
    { this.docComment( $annos ); }
    annotationAssignment_ll1[ $annos ]*
    requiredSemi                     // also req after foreign key spec
  ;

typeToOne[ art ]
  :
    one=ONE
    { this.setMaxCardinality( $art, $one, this.numberLiteral( $one, null, '1' ) ); }
    simplePath[ $art.target, 'artref' ]
  ;

typeToMany[ art ]
  :
    many=MANY
    { this.setMaxCardinality( $art, $many, { literal: 'string', val: '*' } ); }
    simplePath[ $art.target, 'artref' ]
  ;

cardinality[ art ] locals[ card = {} ]
@after { /* #ATN 2 */ $art.cardinality = this.attachLocation($card); }
  :
    lbrack='['
    { $card.targetMax = { literal: 'string', val: '*',
                          location: this.tokenLocation($lbrack) }; }
    (
      // #ATN: simple lookahead behind Number
      (
        srcMax=Number  ','
        { $card.sourceMax = this.numberLiteral( $srcMax ); }
      |
        srcMaxStar='*' ','
        { $card.sourceMax = { literal: 'string', val: '*',
                              location: this.tokenLocation($srcMaxStar) }; }
      )?
      // #ATN: simple lookahead behind Number
      (
        trgMin=Number '..'
        { $card.targetMin = this.numberLiteral( $trgMin ); }
      )?
      (
        trgMax=Number
        { $card.targetMax = this.numberLiteral( $trgMax ); }
      |
        trgMaxStar='*'
        { $card.targetMax = { literal: 'string', val: '*',
                              location: this.tokenLocation($trgMaxStar) }; }
      )
    )?
    ']'
  ;

foreignKey[ outer ] locals[ art = {}, elem = {} ]
@after { this.attachLocation($art); }
  :
    simplePath[ $elem, 'ref' ]
    ( AS name=ident['Key'] )?
    { $art = this.addDef( $outer, 'foreignKeys', 'key', ($ctx.name) ? $name.id : $elem.path,
                          undefined, { targetElement: $elem } ); }
  ;

typeTypeOf[ art ] locals[ _sync = 'nop' ]
@after { this.attachLocation($art.type); }
  :
    TYPE OF
    { $art.type = { scope: 'typeOf' }; }
    simplePath[ $art.type, 'ref' ]
    ( ':'
      // If we have too much time, we could set the category of the simple path
      // before to 'artref'
      { $art.type.scope = $art.type.path.length; }
      simplePath[ $art.type, 'ref']
    )?
  ;

typeRefOptArgs[ art ]
@init { $art.type = {}; }
  :
    simplePath[ $art.type, 'artref' ]
    ( '('
      head=Number
      { $art.typeArguments = [ this.numberLiteral( $head ) ]; }
      ( ',' { if (this.isStraightBefore(')')) break; } // allow ',' before ')'
        tail=Number
        { $art.typeArguments.push( this.numberLiteral( $tail ) ); }
      )*
      ')'
    )?
  ;

// Queries -------------------------------------------------------------------

queryExpression returns[ query ] locals[ op ] // QLSubqueryComplex, SubqueryComplex
@after{ this.attachLocation($query); }
  :
    qt1=queryTerm { $query = $qt1.query; }
    (
      ( un=UNION { $op = this.tokenLocation($un, undefined, 'union'); }
        ( DISTINCT | ALL { $op = this.tokenLocation($un, undefined, 'unionAll'); } )?
      | ex=EXCEPT DISTINCT ?    { $op = this.tokenLocation($ex, undefined, 'except'); }
      | mi=MINUS DISTINCT ?     { $op = this.tokenLocation($mi, undefined, 'except'); } // TODO: change to 'minus'
      )
      qt=queryTerm
      {
        $query = {
          op: $op, args: [$query, $qt.query],
          location: this.combinedLocation( $query, $qt.query) };
      }
    )*
    ( ob=ORDER BY
      {
        if ($query instanceof Array) // use 'subquery' as no-op operator
          $query = { op: this.tokenLocation( $ob, undefined, 'subquery' ), args: [$query], location: $query.location };
      }
      // TODO: create extra "nop" operator
      ob1=orderBySpec { $query.orderBy = [ $ob1.ob ]; }
      ( ',' obn=orderBySpec  { $query.orderBy.push( $obn.ob ); } )*
    )?
    ( limkw=LIMIT
      {
        if ($query instanceof Array) // use 'subquery' as no-op operator
          $query = { op: this.tokenLocation( $limkw, undefined, 'subquery' ), args: [$query], location: $query.location };
      }
      ( lim=Number   { $query.limit = this.numberLiteral( $lim, '' ); }
      | limnull=NULL { $query.limit = { literal: 'null', val: null, location: this.tokenLocation($limnull) }; }
      )
      ( OFFSET off=Number { $query.offset = this.numberLiteral( $off ); } )? // unsigned integer
    )?
  ;

orderBySpec returns[ ob ]
  :
    e=expression { $ob = { value: $e.expr }; }
    ( asc=ASC   { $ob.sort = this.tokenLocation( $asc, undefined, 'asc' ); }
    | desc=DESC { $ob.sort = this.tokenLocation( $desc, undefined, 'desc' ); }
    )?
    ( nb=NULLS ne=( FIRST | LAST )
      { $ob.nulls = this.tokenLocation( $nb, $ne, $ne.text.toLowerCase() ); }
    )?
  ;

queryTerm returns[ query ]
@after{ this.attachLocation($query); }
  :
    qt1=queryPrimary { $query = $qt1.query; }
    (
      intersect=INTERSECT DISTINCT ?
      qt=queryPrimary
      {
        $query = {
          op: this.tokenLocation( $intersect, undefined, 'intersect' ), args: [$query, $qt.query],
          location: this.combinedLocation( $query, $qt.query) };
      }
    )*
  ;

queryPrimary returns[ query = {} ]
@after { this.attachLocation($query); }
  :
    '(' qe=queryExpression ')'
    { $query = [$qe.query]; }
  |
    select=SELECT
    { $query = { op: this.tokenLocation( $select, undefined, 'query' ), location: this.startLocation() }; }
    (
      FROM
      t1=tableExpression { $query.from = [$t1.query]; }
      (
        ',' tn=tableExpression { $query.from.push( $tn.query ); }
      )*
      (
        mixin=MIXIN '{'
        mixinElementDef[ $query ]*
        '}' INTO
      )?
      ( top=TOP Number { this.hanaFlavorOnly( $top ); } )?
      ( ad=( ALL | DISTINCT )     // TODO: or directly after SELECT ?
      { $query.quantifier = this.tokenLocation( $ad, undefined, $ad.text.toLowerCase() ); }
      )?
      (
        '{'
        { $query.columns = []; }  // set it early to avoid "wildcard" errors
        ( star='*'
          {
            $query.columns = [ this.tokenLocation( $star, undefined, '*' ) ];
          }
        |
          selectItemDef[ $query ]
        )
        ( ',' { if (this.isStraightBefore('}')) break; } // allow ',' before '}'
          selectItemDef[ $query ]
        )*
        '}'
      )?
      (
        // syntax is less than ideal - EXCLUDING is only useful for `*` - with
        // this syntax, people wonder what happens with explicit select items
        EXCLUDING
        '{'
        projectionExclusion[ $query ]
        ( ',' { if (this.isStraightBefore('}')) break; } // allow ',' before '}'
          projectionExclusion[ $query ]
        )*
        '}'
      )?
    |
      // TOP would induce ambiguity -> reserved or ATN
      ( ad=( ALL | DISTINCT )     // TODO: or directly after SELECT ?
      { $query.quantifier = this.tokenLocation( $ad, undefined, $ad.text.toLowerCase() ); }
      )?
      { $query.columns = []; }  // set it early to avoid "wildcard" errors
      ( star='*'
        {
          $query.columns = [ this.tokenLocation( $star, undefined, '*' ) ];
        }
      |
        selectItemDef[ $query ]
      )
      ( ',' { if (this.isStraightBefore('}')) break; } // allow ',' before '}'
        selectItemDef[ $query ]
      )*
      FROM
      t1=tableExpression { $query.from = [$t1.query]; }
      (
        ',' tn=tableExpression { $query.from.push( $tn.query ); }
      )*
    )
    ( WHERE cond=condition { $query.where = $cond.cond; } )?
    (
      GROUP BY
      e1=expression { $query.groupBy = [ $e1.expr ]; }
      ( ',' en=expression { $query.groupBy.push( $en.expr ); } )*
    )?
    ( HAVING having=condition { $query.having = $having.cond; } )?
  ;

tableExpression returns[ query ] locals[ join, op ] // TableOrJoin
  :
    qt=tableTerm { $query = $qt.query; }
    (
      ( j=JOIN                  // double ;; (and after ')') is ANTLR bug workaround
        { $op = this.tokenLocation( $j, undefined, 'join' );; $join = 'inner'; }
      | i=INNER j=JOIN
        { $op = this.tokenLocation( $i, $j, 'join' );; $join = 'inner'; }
      | l=LEFT OUTER? j=JOIN
        { $op = this.tokenLocation( $l, $j, 'join' );; $join = 'leftOuter'; } // left
      | r=RIGHT OUTER? j=JOIN
        { $op = this.tokenLocation( $r, $j, 'join' );; $join = 'rightOuter'; } // right
      | f=FULL OUTER? j=JOIN
        { $op = this.tokenLocation( $f, $j, 'join' );; $join = 'fullOuter'; }  // full
      )
      te=tableExpression
      { $query = { op: $op, join: $join, args: [$query, $te.query] }; }
      ON cond=condition
      {
        $query.on = $cond.cond;
        $query.location = this.combinedLocation( $query.args[0], $cond.cond );
      }
    |
      crj=CROSS jn=JOIN tt=tableTerm
      {
        $query = {              // "," -> mit $ syntax:","
          op: this.tokenLocation( $crj, $jn, 'join' ), join: 'cross', args: [$query, $tt.query],
          location: this.combinedLocation( $query, $tt.query) };
      }
    )*
  ;

tableTerm returns [ query ]
@after{ /* #ATN 1 */ this.attachLocation($query); }
  :
    { $query = { path: [], scope: 0 }; }
    fromPath[ $query, 'artref']
    ( ':'
      { $query.scope = $query.path.length; }
      fromPath[ $query, 'ref']
    )?
    ( AS n1=ident['FromAlias'] { $query.name = $n1.id }
    | n2=identNoKeyword['FromAlias'] { $query.name = $n2.id }
    )?
  |
    '('
    // #ATN: The following alternative is not LL1, because both can start with
    // left-paren, but queryExpression has SELECT after initial left-parens
    (
      qe=queryExpression
      {
        $query = $qe.query;     // might be in array if in parens
        if ($query instanceof Array) // use 'subquery' as no-op operator
          $query = { op: this.tokenLocation( $query, undefined, 'subquery' ), args: [$query], location: $query.location };
      }
      ')'
      ( AS a1=ident['FromAlias'] { $query.name = $a1.id } // for defining table aliass
      | a2=identNoKeyword['FromAlias'] { $query.name = $a2.id }
      )?                        // TODO: really optional?
    |
      te=tableExpression { $query = [ $te.query ]; }
      ')'
    )
  ;

fromPath[ qp, idkind ]
@after{ this.attachLocation($qp); }
  :
    id=ident[$idkind] { if ($id.id) $qp.path.push($id.id); else $qp.path.broken = true; }
    ( fromArguments[ $id.id ] cardinalityAndFilter[ $id.id ]?
    | cardinalityAndFilter[ $id.id ]
    )?
    (
      '.' id=ident[$idkind] { if ($id.id) $qp.path.push($id.id); else $qp.path.broken = true; }
      ( fromArguments[ $id.id ] cardinalityAndFilter[ $id.id ]?
      | cardinalityAndFilter[ $id.id ]
      )?
    )*
  ;

// Conditions and expressions ------------------------------------------------

// With "separate" `condition` and `expression` rules, we have long LL
// ambiguities (not so with LALR used in Bison) with initial left parentheses:
//   ( ( ( a.b.c + d.e.f
//       )     // now we know: 3rd left-paren for expression
//       =     // now we know: 1st and 2nd left-paren for condition
//       3 ) ) )
//
// To avoid expensive parsing, we "combine" both rules, i.e. inside '('…')' of
// rule `expressionTerm`, we recursively refer to `condition`, not
// `expression`.  With that, the existence of relations/predicates in rule
// `conditionTerm` must be optional.  Correct conditions and expressions must
// be then ensured by code (either in actions of the grammar or in a check
// phase - to be discussed).
//
// ANTLR4s left-recursion feature cannot be used as we will have rule
// arguments.

condition returns [ cond ] locals [ args = [], orl = [] ]
@after{
  $cond = ($args.length == 1)
    ? $args[0]
    : this.attachLocation({ op: $orl[0], args: $args });
}
  :
    c1=conditionAnd { $args.push($c1.cond); }
    ( or=OR c2=conditionAnd { $args.push($c2.cond); $orl.push(this.tokenLocation( $or, undefined, 'or' ))} )*
  ;

conditionAnd returns [ cond ] locals [ args = [], andl = [] ]
@after{
  $cond = ($args.length == 1)
    ? $args[0]
    : this.attachLocation({ op: $andl[0], args: $args });
}
  :
    c1=conditionTerm { $args.push($c1.cond); }
    ( and=AND c2=conditionTerm { $args.push($c2.cond); $andl.push(this.tokenLocation( $and, undefined, 'and' )) } )*
  ;

conditionTerm returns [ cond ]
@after{
  if ($cond) { this.attachLocation($cond); } else { $cond = $expr.expr; }
}
  :
    nt=NOT ct=conditionTerm
    { $cond = { op: this.tokenLocation( $nt, undefined, 'not' ), args: [ $ct.cond ] }; }
  |
    ex=EXISTS '(' qe=queryExpression ')'
    { $cond = { op: this.tokenLocation( $ex, undefined, 'exists' ), args: [ $qe.query ] }; }
  |
    expr=expression             // see @after
    (
      rel=( '=' | '<>' | '>'  | '>=' | '<' | '<=' | '!=' )
      { $cond = { op: this.tokenLocation( $rel, undefined, $rel.text), args: [ $expr.expr ] }; }
      ( asa=( ANY | SOME | ALL )
        { $cond.quantifier = this.tokenLocation($asa, undefined, $asa.text.toLowerCase()); }
      )?
      e2=expression { $cond.args.push($e2.expr); }
    |
      IS ( inn=NOT NULL | innu=NULL )
      { $cond = { op: $inn ? this.tokenLocation( $inn, undefined, 'isNotNull' ) : this.tokenLocation( $innu, undefined, 'isNull' ), args: [ $expr.expr ] }; }
    |
      { $cond = { args: [ $expr.expr ] }; }
      NOT predicate[ $cond, true ]
    |
      { $cond = { args: [ $expr.expr ] }; }
      predicate[ $cond, false ]
    )?                          // optional: for conditions in parentheses
  ;

predicate[ cond, negated ]
// As an alternative, we could have a `negated` properties for the operations
// `isNull`(!), `in`, `between` and `like` (or produce the same AST as for
//    NOT (a BETWEEN b AND c)
  :
    ino=IN e1=expression        // including ExpressionList
    { $cond.op = this.tokenLocation( $ino, undefined, (negated) ? 'notIn' : 'in'); $cond.args.push( $e1.expr ); }
  |
    bw=BETWEEN e2=expression
    { $cond.op = this.tokenLocation( $bw, undefined, (negated) ? 'notBetween' : 'between' ); $cond.args.push( $e2.expr ); }
    AND e3=expression { $cond.args.push( $e3.expr ); }
  |
    lk=LIKE e4=expression
    { $cond.op = this.tokenLocation( $lk, undefined, (negated) ? 'notLike' : 'like' ); $cond.args.push( $e4.expr ); }
    ( ESCAPE e5=expression { $cond.args.push( $e5.expr ); } )?
  ;

expression returns [ expr ]
@after{ if ($expr) { this.attachLocation($expr); } else { $expr = this.attachLocation({});} }
  :
    e1=expressionSum { $expr = $e1.expr; }
    (
      or='||' e2=expressionSum
      {
        $expr = {
          op: this.tokenLocation( $or, undefined, '||' ), args: [$expr, $e2.expr],
          location: this.combinedLocation( $expr, $e2.expr ) };
      }
    )*
  ;

expressionSum returns [ expr ]
  :
    e1=expressionFactor { $expr = $e1.expr; }
    (
      op=( '+' | '-' ) e2=expressionFactor
      {
        $expr = {
          op: this.tokenLocation($op, undefined, $op.text), args: [$expr, $e2.expr],
          location: this.combinedLocation( $expr, $e2.expr ) };
      }
    )*
  ;

expressionFactor returns [ expr ]
  :
    e1=expressionTerm { $expr = $e1.expr; }
    (
      op=( '*' | '/' ) e2=expressionTerm
      {
        $expr = {
          op: this.tokenLocation($op, undefined, $op.text), args: [$expr, $e2.expr],
          location: this.combinedLocation( $expr, $e2.expr ) };
      }
    )*
  ;

expressionTerm returns [ expr ] locals [ op, args = [] ]
@after{ /* #ATN 1 */ this.attachLocation($expr); }
  :
    // unary +-
    unary=( '+' | '-' ) e1=expressionTerm
    { $expr = { op: this.tokenLocation($unary, undefined, $unary.text), args: [ $e1.expr ] }; }
  |
    (
      val=literalValue
      { $expr = $val.val; }
    |
      sf=specialFunction
      { $expr = $sf.ret; }
    |
      ca=CASE
      { $expr = { op : this.tokenLocation( $ca, undefined, 'case' ), args: [] }; }
      (
        e2=expression { $expr.args.push($e2.expr); }
        ( ow=WHEN ew=expression THEN e3=expression
          { $expr.args.push( this.createPrefixOp( $ow, [ $ew.expr, $e3.expr ] ) ); }
        )+
      |
        ( ow=WHEN c=condition THEN e3=expression
          { $expr.args.push( this.createPrefixOp( $ow, [ $c.cond, $e3.expr ] ) ); }
        )+
      )
      ( el=ELSE e4=expression
        { $expr.args.push( this.createPrefixOp( $el, [ $e4.expr ] ) ); }
      )?
      END
    |
      ne=NEW nqp=valuePath[ 'ref', null] // token rewrite for NEW
      // please note: there will be no compiler-supported code completion after NEW
      { $expr = { op: this.tokenLocation( $ne, undefined, 'new' ), args: [] };
        this.hanaFlavorOnly( $ne ); }
    |
      vp=valuePath[ 'ref', null]
      {
        let path = $vp.qp.path;
        if (path[0] && path[0].args) {
          let na = path[0].namedArgs; // TODO: XSN func path cleanup
          $expr = { op: { location: path[0].location, val: 'call' },
                    func: $vp.qp, [na?'namedArgs':'args']: na||path[0].args };
          if ($expr && path.length > 1 || path.slice(1).some( s => s && s.args ))
          { this.hanaFlavorOnly( 'Methods in expressions are not supported yet', $ctx.start ); }
        }
        else  $expr = $vp.qp;
      }
    |
      ':'
      ( vp=valuePath[ 'paramref', this.startLocation() ]
        { $expr = $vp.qp;; $expr.scope = 'param'; }
      | pp=Number
        { $expr = { param: this.numberLiteral( $pp ), scope: 'param' };
          this.csnParseOnly( 'Positional parameter ":' + $pp.text + '" is not supported', $pp );
        }
      )
    |
      qm='?'
      { $expr = { param: this.tokenLocation( $qm, undefined, '?' ), scope: 'param' };
        this.csnParseOnly( 'Dynamic parameter "?" is not supported', $qm );
      }
    |
      '('
      // #ATN: The following alternative is not LL1, because both can start with
      // left-paren, but queryExpression has SELECT after initial left-parens
      (
        qe=queryExpression { $expr = $qe.query; }
      |
        c1=condition { $expr = [ $c1.cond ]; }
        ( ',' { if (this.isStraightBefore(')') && $expr.length > 1) break; } // allow ',' before ')'
          cn=expression { $expr.push($cn.expr); }
        )*
      )
      ')'
    )
  ;

specialFunction returns [ ret = { } ] locals[ art = {} ]
@after{ /* #ATN 1 */ }
  :
    tr=TRIM '('
    { this.hanaFlavorOnly( $tr );
      $ret.op = this.tokenLocation( $tr, undefined, 'special' ); $ret.args = []; }
    // #ATN: we do not want to reserve these three optional keywords
    (
      ( LEADING | TRAILING | BOTH ) expression ?
      FROM expression
    |
      expression
      ( FROM expression )?
    )
    ')'
  |
    ex=EXTRACT '('
    { this.hanaFlavorOnly( $ex );
      $ret.op = this.tokenLocation( $ex, undefined, 'special' ); $ret.args = []; }
    ( YEAR | MONTH | DAY | HOUR | MINUTE | SECOND )
    FROM expression
    ')'
  |
    ca=CAST '('
    { this.hanaFlavorOnly( $ca );
      $ret.op = this.tokenLocation( $ca, undefined, 'special' ); $ret.args = []; }
    expression AS typeRefOptArgs[ $art ]
    ')'
  ;

// query path includes aggregation:
// ( COUNT | MIN | MAX | SUM | AVG | STDDEV | VAR )
// '(' ( '*' | expression | ALL expression | DISTINCT expression_list ) ')'

valuePath[ category, location = null ] returns[ qp = { path: [] } ] locals[ _sync = 'nop' ]
@init { $qp.location = location || this.startLocation(); }
@after{ this.attachLocation($qp); }
  :
    id=ident[ $category ]
    { if ($id.id) $qp.path.push($id.id); else $qp.path.broken = true; }
    ( pathArguments[ $id.id ] cardinalityAndFilter[ $id.id ]?
    | cardinalityAndFilter[ $id.id ]
    )?
    (
      '.' id=ident['ref']       // yes 'ref', not $category
      { if ($id.id) $qp.path.push($id.id); else $qp.path.broken = true; }
      ( pathArguments[ $id.id ] cardinalityAndFilter[ $id.id ]?
      | cardinalityAndFilter[ $id.id ]
      )?
    )*
  ;

fromArguments[ pathStep ]
  :
    paren='('
    namedExpression[ $pathStep ]
    ( ',' { if (this.isStraightBefore(')')) break; } // allow ',' before ')'
      namedExpression[ $pathStep ]
    )*
    ')'
  ;

pathArguments[ pathStep ]
@after{ /* #ATN 1 */ }
  :
    paren='('
    // ATN, LL2: Identifier can start both named arguments and the positional.
    // Make sure that we do not introduce A:B paths in expressions!
    (
      namedExpression[ $pathStep ]
      ( ',' { if (this.isStraightBefore(')')) break; } // allow ',' before ')'
        namedExpression[ $pathStep ]
      )*
    |
      { $pathStep.args = []; }  // TODO: XSN func path cleanup
      arrowedExpression[ $pathStep ]
      ( ',' { if (this.isStraightBefore(')')) break; } // allow ',' before ')'
        arrowedExpression[ $pathStep ]
      )*
    |
      e1=expression { $pathStep.args = [ $e1.expr ]; }
      ( ',' { if (this.isStraightBefore(')')) break; } // allow ',' before ')'
        e2=expression { $pathStep.args.push( $e2.expr ); }
      )*
    |
      a=ALL { $pathStep.quantifier = this.tokenLocation( $a, undefined, 'all' ); }
      e1=expression { $pathStep.args = [ $e1.expr ]; }
    |
      d=DISTINCT { $pathStep.quantifier = this.tokenLocation( $d, undefined, 'distinct' ); }
      e1=expression { $pathStep.args = [ $e1.expr ]; }
      ( ',' e2=expression { $pathStep.args.push( $e2.expr ); } )*
    |
      star='*'
      { $pathStep.args = [ { location: this.tokenLocation($star), val: '*', literal: 'token' } ]; }
    |
      { $pathStep.args = []; }
    )
    ')'
  ;

namedExpression[ pathStep ]
  :
    name=ident['paramname'] ':' elem=expression
    { if ($pathStep && $name.id) this.addDef( $pathStep, 'namedArgs', 0, $name.id, true,
                                 ($ctx.elem) ? $elem.expr : { location: $name.id.location } ); }
  ;

arrowedExpression[ pathStep ]
  :
    name=ident['paramname'] a='=>' elem=expression
    { if ($name.id) this.addDef( $pathStep, 'namedArgs', 0, $name.id, true,
                                 ($ctx.elem) ? $elem.expr : { location: $name.id.location } ); }
  ;

cardinalityAndFilter[ pathStep ] locals [ _sync = 'nop' ]
  :
    '['
    optionalCardinality[ pathStep ]?
    //{ $LeaveLoop = false; }
    optionalWhereForFilter
    co=condition { if ($pathStep) $pathStep.where = $co.cond; }
    ']'
  ;

optionalCardinality[ pathStep ]
@after { if ($pathStep && $pathStep.cardinality) this.attachLocation($pathStep.cardinality); }
  :
    // Make sure to test second token to allow expressions starting with Number
    // without introducing WHERE - that would be @options{k=2}.  The code
    // completion just produces `:`after having inserted a Number - TODO.
    { if (this._input.LT(2).text !== ':') return $ctx; }
    ( trgMax=Number ':'
      { if ($pathStep) $pathStep.cardinality = { targetMax: this.numberLiteral( $trgMax ) } }
    )
  ;

optionalWhereForFilter
  :
    // For ANTLR, WHERE is required, but we allow the generated parser skipping
    // the call of match(WHERE) except for the future (optional) clauses GROUP,
    // ORDER, LIMIT.  This hack requires that sync() at each state in the
    // calling rule does not throw an error if the current token does not match
    // one of the expected ones.
    {
      var text = this.getCurrentToken().text.toUpperCase();
      if (!['WHERE','GROUP','ORDER','LIMIT'].includes( text )) return;
      // TODO: should we somehow add those keywords to $(EXPECTED)?
    }
    WHERE
  ;

selectItemInline locals[ o = {} ]
  :
    cb='{' { this.hanaFlavorOnly( 'Inline select items are not supported yet', $cb ); }
    selectItemDef[$o] ( ',' selectItemDef[$o] )* // final ',' if we support that
    '}'
  ;

// Simple paths and values ---------------------------------------------------

value returns[ val ]
@after { this.attachLocation($val); }
  :
    { $val = { literal: 'struct', location: this.startLocation() }; }
    '{'
    namedValue[ $val ]
    (
      ',' { if (this.isStraightBefore('}')) break; } // allow ',' before ')'
      namedValue[ $val ]
    )*
    '}'
  |
    { $val = { literal: 'array', location: this.startLocation(), val: [] }; }
    '['
    (
      head=arrayValue { $val.val.push( $head.val ); }
      (
        ',' { if (this.isStraightBefore(']')) break; } // allow ',' before ']'
        tail=arrayValue { $val.val.push( $tail.val ); }
      )*
    )?
    ']'
  |
    v1=literalValue { $val = $v1.val; }
  |
    ( plus='+' | min='-' ) num=Number
    { $val = this.numberLiteral( $num, $plus||$min ); }
  |
    { $val = {}; }              // TODO: think about expression value representation
    simplePath[ $val, 'ref' ]
  ;

namedValue[ struct ] locals[ namedVal = { name: {} } ]
  :
    simplePath[ $namedVal.name, 'name' ]
    ( '#' variant=ident['variant'] { $namedVal.name.variant = $variant.id; } )?
    ( ':' elem=value )?
    { this.addItem( $struct, '_struct', null, true, // TODO: re-check _struct
                    ($ctx.elem) ? Object.assign($namedVal, $elem.val) : $namedVal ); }
  ;


arrayValue returns[ val ]
@after { this.attachLocation($val); }
  :
    { $val = { literal: 'struct', location: this.startLocation() }; }
    '{'
    namedValueInArray[ $val ]
    ( ',' { if (this.isStraightBefore('}')) break; } // allow ',' before '}'
      namedValueInArray[ $val ]
    )*
    '}'
  |
    { $val = { literal: 'array', location: this.startLocation(), val: [] }; }
    '['
    ( head=arrayValue { $val.val.push( $head.val ); }
      ( ',' { if (this.isStraightBefore(']')) break; } // allow ',' before ']'
        tail=arrayValue { $val.val.push( $tail.val ); }
      )*
    )?
    ']'
  |
    v1=literalValue { $val = $v1.val; }
  |
    ( plus='+' | min='-' ) num=Number
    { $val = this.numberLiteral( $num, $plus||$min ); }
  |
    { $val = {}; }              // TODO: think about expression value representation
    simplePath[ $val, 'ref' ]
  ;

namedValueInArray[ struct ]
  :
    name=ident['name'] ( ':' elem=arrayValue )? // $name.id can be null with parse error
    { if ($name.id) this.addDef( $struct, 'struct', null, $name.id, true,
                                 ($ctx.elem) ? $elem.val : { location: $name.id.location } ); }
  ;

literalValue returns[ val ] locals[ $tok ]
@init{ $tok = this.getCurrentToken(); }
@after { this.attachLocation($val); }
  :
    '#' name=ident['enumref']
    { $val = { literal: 'enum', symbol: $name.id } }
  |
    NULL
    { $val = { literal: 'null', val: null }; }
  |
    Boolean
    { $val = { literal: 'boolean', val: $tok.text.toLowerCase() != 'false' }; }
  |
    Number
    { $val = this.numberLiteral( $tok, '' ); } // allow float and large number
  |
    String
    { $val = this.quotedLiteral( $tok, 'string' ); }
  |
    QuotedLiteral               // x'12', date'...', time'...', timestamp'...'
    { $val = this.quotedLiteral( $tok ); }
  ;

simplePath[ art, category ] locals[ _sync = 'nop' ]
@after { this.attachLocation($art); }
// Due to error recovery, rule `ident` can return with value `null`.  Set the
// path as broken in this case.
  :
    head=ident[ $category ]
    { if ($art.path) $art.path.push ( $head.id ); else $art.path = [ $head.id ];
      if ($category === 'artref') $art.scope = 0;
      if (!$head.id) $art.path.broken = true;
    }
    (
      '.' tail=ident[ $category ]
      { $art.path.push ( $tail.id ); if (!$tail.id) $art.path.broken = true; }
    )*
  ;


// Identifier and non-reserved keywords --------------------------------------

identNoKeyword[ category ] returns[ id ]    // for aliases without AS
@after{ $id = this.identAst( $stop, $category ); }
  :
    Identifier
  ;

// The `ident` rule matches `Identifier` and all non-reserved keywords.  List
// all non-reserved keywords directly, do not use an indirection via a rule
// like `nonReservedKeywords`.
ident[ category ] returns[ id ]
@after{ $id = this.identAst( $stop, $category ); }
  :
    Identifier
  | ABSTRACT
  | ACTION
  | ACTIONS
  | AFTER
  | ALWAYS
  | ANALYSIS
  | AND
  | ANNOTATE
  | ANNOTATION
  | ARRAY
  | ASC
  | ASPECT
  | ASSOCIATION
  | ASYNC
  | ASYNCHRONOUS
  | AUTO
  | BETWEEN
  | BOTH
  | CACHE
  | COLUMN
  | COLUMNS
  | COMPOSITION
  | CONFIGURATION
  | CONST
  | CONTEXT
  | CURRENT
  | CROSS
  | CYCLE
  | DAY
  | DEFAULT
  | DEFINE
  | DEPENDS
  | DESC
  | DETECTION
  | DISABLED
  | DOCUMENTS
  | ELEMENT
  | ELSE
  | ENABLED
  | END
  | ENTITY
  | ENUM
  | ESCAPE
  | EVENT
  | EVERY
  | EXCEPT
  | EXCLUDING
  | EXISTING
  | EXTEND
  | EXTENDED
  | FAST
  | FIRST
  | FLUSH
  | FULL
  | FULLTEXT
  | FUNCTION
  | FUZZY
  | GENERATED
  | GETNUMSERVERS
  | GROUP
  | HANA
  | HASH
  | HAVING
  | HOUR
  | IDENTITY
  | INCREMENT
  | INDEX
  | INNER
  | INTERSECT
  | INTO
  | IS
  | JOIN
  | KEEPING
  | LANGUAGE
  | LAST
  | LAYOUT
  | LEADING
  | LEFT
  | LIKE
  | LIMIT
  | LOCALIZED
  | MANY
  | MASKED
  | MAXVALUE
  | MERGE
  | MIGRATION
  | MINING
  | MINUS
  | MINUTE
  | MINUTES
  | MINVALUE
  | MIME
  | MIXIN
  | MODE
  | MONTH
  | NAME
  | NAMESPACE
  | NO
  | NULLS
  | OFF
  | OFFSET
  | ONE
  | ONLY
  | OR
  | ORDER
  | OTHERS
  | OUTER
  | OVERLAY
  | QUEUE
  | PARAMETERS
  | PARTITION
  | PARTITIONING
  | PARTITIONS
  | PHRASE
  | PREPROCESS
  | PRIORITY
  | PROJECTION
  | RANGE
  | RATIO
  | REDIRECTED
  | RESET
  | RETURNS
  | RIGHT
  | ROUNDROBIN
  | ROW
  | SEARCH
  | SECOND
  | SEPARATORS
  | SERVICE
  | START
  | STORAGE
  | STORE
  | SUBTYPE
  | SYNC
  | SYNCHRONOUS
  | TABLE
  | TECHNICAL
  | TEMPORARY
  | TEXT
  | THEN
  | TOKEN
  | TOP
  | TRAILING
  | UNION
  | UNIQUE
  | UNLOAD
  | TO
  | TYPE
  | USING
  | VALUE
  | VALUES
  | VIEW
  | VIRTUAL
  | YEAR
  ;

//----------------------------------------------------------------------------

WhiteSpace                      // like \s in JavaScript RegExp
  :                             // LineTerminator | [\t\f\v\u00A0\uFEFF] | Zs
    [\r\n\u2028\u2029 \t\f\u000B\u00A0\u1680\u180e\u2000-\u200A\u202F\u205F\u3000\uFEFF]+
    -> skip ;

DocComment : '/**' .*? '*/' -> channel(HIDDEN);

Comment : '/*' .*? '*/' -> channel(HIDDEN);

LineComment : '//' ~[\r\n\u2028\u2029]* -> channel(HIDDEN);

// Values --------------------------------------------------------------------

String
  :
    ( '\'' ~[\u0027\n\r\u2028\u2029]* '\'' )+ // \u0027 = '\''
  ;

QuotedLiteral
  :
    ( [xX] | [dD][aA][tT][eE] | [tT][iI][mM][eE] ( [sS][tT][aA][mM][pP] )? )
    ( '\'' ~[\u0027\n\r\u2028\u2029]* '\'' )+ // \u0027 = '\''
  ;

UnterminatedLiteral
  :
    ( [xX] | [dD][aA][tT][eE] | [tT][iI][mM][eE] ( [sS][tT][aA][mM][pP] )? )?
    '\'' ~[\u0027\n\r\u2028\u2029]* // \u0027 = '\''
  ;

UnterminatedDelimitedIdentifier
  :
    '"' ~[\u0022\n\r\u2028\u2029]* ('""' ~[\u0022\n\r\u2028\u2029]*)* // \u0022 = '"'
  | '![' ~[\u005d\n\r\u2028\u2029]* // \u005d = ']'
  ;

Boolean                         // TMP?
  : [tT][rR][uU][eE] | [fF][aA][lL][sS][eE]
  ;

// Reserved keywords (are case-insensitive): ---------------------------------

ALL : [aA][lL][lL] ;
ANY : [aA][nN][yY] ;
AS : [aA][sS] ;
BY : [bB][yY] ;
CASE : [cC][aA][sS][eE] ;
CAST : [cC][aA][sS][tT] ;
DISTINCT : [dD][iI][sS][tT][iI][nN][cC][tT] ;
EXISTS : [eE][xX][iI][sS][tT][sS] ;
EXTRACT : [eE][xX][tT][rR][aA][cC][tT] ;
// FALSE: see Boolean
FROM : [fF][rR][oO][mM] ;
IN : [iI][nN] ;
KEY : [kK][eE][yY] ;
NEW : [nN][eE][wW] ;            // token rewrite for NEW -> not reserved (also not in SQL)
NOT : [nN][oO][tT] ;
NULL : [nN][uU][lL][lL] ;
OF : [oO][fF] ;
ON : [oO][nN] ;
SELECT : [sS][eE][lL][eE][cC][tT] ;
SOME : [sS][oO][mM][eE] ;
WHEN : [wW][hH][eE][nN] ;
TRIM : [tT][rR][iI][mM] ;
// TRUE: see Boolean
WHERE : [wW][hH][eE][rR][eE] ;
WITH : [wW][iI][tT][hH] ;

// Fixed Token which is defined DIRECTLY BEFORE the unreserved keywords ------

Number                          // DO NOT RENAME OR MOVE THIS RULE !!!
  : [0-9]+                      // no initial sign
    ( '.' [0-9]+ )?
    ( [eE] ('+'|'-')? [0-9]+ )?
  ;

// Unreserved keywords (are case-insensitive): -------------------------------

ABSTRACT : [aA][bB][sS][tT][rR][aA][cC][tT] ;
ACTION : [aA][cC][tT][iI][oO][nN] ;
ACTIONS : [aA][cC][tT][iI][oO][nN][sS] ;
AFTER : [aA][fF][tT][eE][rR] ;
ALWAYS : [aA][lL][wW][aA][yY][sS] ;
ANALYSIS : [aA][nN][aA][lL][yY][sS][iI][sS] ;
AND : [aA][nN][dD] ;
ANNOTATE : [aA][nN][nN][oO][tT][aA][tT][eE] ;
ANNOTATION : [aA][nN][nN][oO][tT][aA][tT][iI][oO][nN] ;
ARRAY : [aA][rR][rR][aA][yY] ;
ASC : [aA][sS][cC] ;
ASPECT : [aA][sS][pP][eE][cC][tT] ;
ASSOCIATION : [aA][sS][sS][oO][cC][iI][aA][tT][iI][oO][nN] ;
ASYNC : [aA][sS][yY][nN][cC] ;
ASYNCHRONOUS : [aA][sS][yY][nN][cC][hH][rR][oO][nN][oO][uU][sS] ;
AUTO : [aA][uU][tT][oO] ;
BETWEEN : [bB][eE][tT][wW][eE][eE][nN] ;
BOTH : [bB][oO][tT][hH] ;
CACHE : [cC][aA][cC][hH][eE] ;
COLUMN: [cC][oO][lL][uU][mM][nN] ;
COLUMNS: [cC][oO][lL][uU][mM][nN][sS] ;
COMPOSITION : [cC][oO][mM][pP][oO][sS][iI][tT][iI][oO][nN] ;
CONFIGURATION : [cC][oO][nN][fF][iI][gG][uU][rR][aA][tT][iI][oO][nN] ;
CONST : [cC][oO][nN][sS][tT] ;
CONTEXT : [cC][oO][nN][tT][eE][xX][tT] ;
CROSS : [cC][rR][oO][sS][sS] ;
CURRENT : [cC][uU][rR][rR][eE][nN][tT] ;
CYCLE : [cC][yY][cC][lL][eE] ;
DAY : [dD][aA][yY] ;
DEFAULT : [dD][eE][fF][aA][uU][lL][tT] ;
DEFINE : [dD][eE][fF][iI][nN][eE] ;
DEPENDS : [dD][eE][pP][eE][nN][dD][sS] ;
DESC : [dD][eE][sS][cC] ;
DETECTION: [dD][eE][tT][eE][cC][tT][iI][oO][nN] ;
DISABLED : [dD][iI][sS][aA][bB][lL][eE][dD] ;
DOCUMENTS : [dD][oO][cC][uU][mM][eE][nN][tT][sS] ;
ELEMENT : [eE][lL][eE][mM][eE][nN][tT] ;
ELSE : [eE][lL][sS][eE] ;
ENABLED : [eE][nN][aA][bB][lL][eE][dD] ;
END : [eE][nN][dD] ;
ENTITY : [eE][nN][tT][iI][tT][yY] ;
ENUM : [eE][nN][uU][mM] ;
EVENT : [eE][vV][eE][nN][tT] ;
EVERY : [eE][vV][eE][rR][yY] ;
ESCAPE : [eE][sS][cC][aA][pP][eE] ;
EXCEPT : [eE][xX][cC][eE][pP][tT] ;
EXCLUDING : [eE][xX][cC][lL][uU][dD][iI][nN][gG] ;
EXISTING : [eE][xX][iI][sS][tT][iI][nN][gG] ;
EXTEND : [eE][xX][tT][eE][nN][dD] ;
EXTENDED : [eE][xX][tT][eE][nN][dD][eE][dD] ;
FAST : [fF][aA][sS][tT] ;
FIRST : [fF][iI][rR][sS][tT] ;
FLUSH : [fF][lL][uU][sS][hH] ;
FULL : [fF][uU][lL][lL] ;
FULLTEXT : [fF][uU][lL][lL][tT][eE][xX][tT] ;
FUNCTION : [fF][uU][nN][cC][tT][iI][oO][nN] ;
FUZZY : [fF][uU][zZ][zZ][yY] ;
GENERATED : [gG][eE][nN][eE][rR][aA][tT][eE][dD] ;
GETNUMSERVERS : [gG][eE][tT][_][nN][uU][mM][_][sS][eE][rR][vV][eE][rR][sS] ;
GROUP : [gG][rR][oO][uU][pP] ;
HANA : [hH][aA][nN][aA] ;
HASH : [hH][aA][sS][hH] ;
HAVING : [hH][aA][vV][iI][nN][gG] ;
HOUR : [hH][oO][uU][rR] ;
IDENTITY : [iI][dD][eE][nN][tT][iI][tT][yY] ;
INCREMENT : [iI][nN][cC][rR][eE][mM][eE][nN][tT] ;
INDEX : [iI][nN][dD][eE][xX] ;
INNER : [iI][nN][nN][eE][rR] ;
INTERSECT : [iI][nN][tT][eE][rR][sS][eE][cC][tT] ;
INTO : [iI][nN][tT][oO] ;
IS : [iI][sS] ;
JOIN : [jJ][oO][iI][nN] ;
KEEPING : [kK][eE][eE][pP][iI][nN][gG] ;
LANGUAGE : [lL][aA][nN][gG][uU][aA][gG][eE];
LAST : [lL][aA][sS][tT] ;
LAYOUT : [lL][aA][yY][oO][uU][tT] ;
LEADING : [lL][eE][aA][dD][iI][nN][gG] ;
LEFT : [lL][eE][fF][tT] ;
LIKE : [lL][iI][kK][eE] ;
LIMIT : [lL][iI][mM][iI][tT] ;
LOCALIZED: [lL][oO][cC][aA][lL][iI][zZ][eE][dD];
MANY : [mM][aA][nN][yY] ;
MASKED : [mM][aA][sS][kK][eE][dD] ;
MAXVALUE : [mM][aA][xX][vV][aA][lL][uU][eE] ;
MERGE : [mM][eE][rR][gG][eE] ;
MIGRATION: [mM][iI][gG][rR][aA][tT][iI][oO][nN] ;
MINING : [mM][iI][nN][iI][nN][gG] ;
MINUS : [mM][iI][nN][uU][sS] ;
MINUTE : [mM][iI][nN][uU][tT][eE] ;
MINUTES : [mM][iI][nN][uU][tT][eE][sS] ;
MINVALUE : [mM][iI][nN][vV][aA][lL][uU][eE] ;
MIME : [mM][iI][mM][eE] ;
MIXIN : [mM][iI][xX][iI][nN] ;
MODE : [mM][oO][dD][eE] ;
MONTH : [mM][oO][nN][tT][hH] ;
NAME : [nN][aA][mM][eE] ;
NAMESPACE : [nN][aA][mM][eE][sS][pP][aA][cC][eE] ;
NO : [nN][oO] ;                 // or make reserved? (is in SQL-92)
NULLS : [nN][uU][lL][lL][sS] ;
OFF : [oO][fF][fF] ;
OFFSET : [oO][fF][fF][sS][eE][tT] ;
ONE : [oO][nN][eE] ;
ONLY : [oO][nN][lL][yY] ;
OR : [oO][rR] ;
ORDER : [oO][rR][dD][eE][rR] ;
OTHERS : [oO][tT][hH][eE][rR][sS] ;
OUTER : [oO][uU][tT][eE][rR] ;
OVERLAY : [oO][vV][eE][rR][lL][aA][yY] ;
QUEUE : [qQ][uU][eE][uU][eE] ;
PARAMETERS : [pP][aA][rR][aA][mM][eE][tT][eE][rR][sS] ;
PARTITION : [pP][aA][rR][tT][iI][tT][iI][oO][nN] ;
PARTITIONING : [pP][aA][rR][tT][iI][tT][iI][oO][nN][iI][nN][gG] ;
PARTITIONS : [pP][aA][rR][tT][iI][tT][iI][oO][nN][sS] ;
PHRASE : [pP][hH][rR][aA][sS][eE] ;
PREPROCESS : [pP][rR][eE][pP][rR][oO][cC][eE][sS][sS] ;
PRIORITY: [pP][rR][iI][oO][rR][iI][tT][yY] ;
PROJECTION : [pP][rR][oO][jJ][eE][cC][tT][iI][oO][nN] ;
RANGE : [rR][aA][nN][gG][eE] ;
RATIO : [rR][aA][tT][iI][oO] ;
REDIRECTED : [rR][eE][dD][iI][rR][eE][cC][tT][eE][dD] ;
RESET : [rR][eE][sS][eE][tT] ;
RETURNS : [rR][eE][tT][uU][rR][nN][sS] ;
RIGHT : [rR][iI][gG][hH][tT] ;
ROUNDROBIN : [rR][oO][uU][nN][dD][rR][oO][bB][iI][nN] ;
ROW : [rR][oO][wW] ;
SEARCH : [sS][eE][aA][rR][cC][hH] ;
SECOND : [sS][eE][cC][oO][nN][dD] ;
SEPARATORS : [sS][eE][pP][aA][rR][aA][tT][oO][rR][sS] ;
SERVICE : [sS][eE][rR][vV][iI][cC][eE] ;
START : [sS][tT][aA][rR][tT] ;
STORAGE : [sS][tT][oO][rR][aA][gG][eE] ;
STORE : [sS][tT][oO][rR][eE] ;
SUBTYPE : [sS][uU][bB][tT][yY][pP][eE] ;
SYNC : [sS][yY][nN][cC] ;
SYNCHRONOUS : [sS][yY][nN][cC][hH][rR][oO][nN][oO][uU][sS] ;
TABLE : [tT][aA][bB][lL][eE] ;
TECHNICAL : [tT][eE][cC][hH][nN][iI][cC][aA][lL] ;
TEMPORARY : [tT][eE][mM][pP][oO][rR][aA][rR][yY] ;
TEXT : [tT][eE][xX][tT] ;
THEN : [tT][hH][eE][nN] ;
TOKEN : [tT][oO][kK][eE][nN] ;
TOP : [tT][oO][pP] ;
TRAILING : [tT][rR][aA][iI][lL][iI][nN][gG] ;
TO : [tT][oO] ;                 // or make reserved? (is in SQL-92)
TYPE : [tT][yY][pP][eE] ;
UNION : [uU][nN][iI][oO][nN] ;
UNIQUE : [uU][nN][iI][qQ][uU][eE] ;
UNLOAD : [uU][nN][lL][oO][aA][dD] ;
USING : [uU][sS][iI][nN][gG] ;
VALUE : [vV][aA][lL][uU][eE] ;
VALUES : [vV][aA][lL][uU][eE][sS] ;
VIEW : [vV][iI][eE][wW] ;
VIRTUAL: [vV][iI][rR][tT][uU][aA][lL] ;
YEAR : [yY][eE][aA][rR] ;

// Identifiers, must BE LAST, DIRECTLY AFTER the unreserved keywords ---------

Identifier                      // DO NOT RENAME OR MOVE THIS RULE !!!
  : [$_a-zA-Z][$_a-zA-Z0-9]*    // i.e. including $param
  | ( '"' ~[\u0022\n\r\u2028\u2029]* '"' )+ // \u0022 = '"'
  | ( '![' ~[\u005d\n\r\u2028\u2029]* ']' ) // \u005d = ']'
  ;

IllegalToken : . ;

// Local Variables:
// c-basic-offset: 2
// End:
