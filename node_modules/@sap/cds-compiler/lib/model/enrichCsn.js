// For testing: reveal non-enumerable properties in CSN, display result of csnRefs

// Running `cdsc -E`, short for `cdsc --enrich-csn` displays additional
// information within the CSN, which might be useful for testing.

// An enumerable property `$location` appears in the JSON with the following value:

// * `File.cds:3:5` if the original CSN has a non-enumerable `$location` property
//   with value `{file: "File.cds", line: 3, col: 5}`.
// * `File.cds:3:5-1` if the original CSN has _no_ `$location` property, for an
//   inferred member of a main artifact or member with `$location: `File.cds:3:5`;
//   the number of digits in the `-1` suffix is the member depth.

// Other enumerable properties in the JSON for non-enumerable properties in the
// original CSN:

// * `$env` for the non-enumerable `$env` property in the original CSN.
// * `$elements` for a non-enumerable `elements` property for sub queries.

// The following properties in the JSON represent the result of the CSN API
// functions:

// * `_type`, `_includes` and `_targets` have as values the `$locations` of the
//   referred artifacts which are returned by function `artifactRef`.
// * `_links`, `_art` and `_scope` as sibling properties of `ref` have as values
//   the `$locations` of the artifacts/members returned by function `inspectRef`.

'use strict'

const csnRefs = require('./csnRefs');
const { locationString } = require('../base/messages');

function enrichCsn( csn, options = {} ) {
  const transformers = {
    $env: reveal,
    elements: dictionary,
    definitions: dictionary,
    actions: dictionary,
    params: dictionary,
    enum: dictionary,
    payload: dictionary,
    ref: pathRef,
    type: simpleRef,
    target: simpleRef,
    includes: simpleRef,
  }
  setLocations( csn, false, null );
  const { inspectRef, artifactRef } = csnRefs( csn );
  const csnPath = [];
  if (csn.definitions)
    dictionary( csn, 'definitions', csn.definitions );
  return csn;

  function standard( parent, prop, node ) {
    if (!node || typeof node !== 'object' || !{}.propertyIsEnumerable.call( parent, prop ) || (typeof prop === 'string' && prop.startsWith('@')))
      return;

    csnPath.push( prop );
    if (node instanceof Array) {
      node.forEach( (n, i) => standard( node, i, n ) );
    }
    else {
      for (let name of Object.getOwnPropertyNames( node )) {
        const trans = transformers[name] || standard;
        trans( node, name, node[name] );
      }
    }
    csnPath.pop();
  }

  function dictionary( node, prop, dict ) {
    csnPath.push( prop );
    for (let name of Object.getOwnPropertyNames( dict )) {
      standard( dict, name, dict[name] );
    }
    if (!Object.prototype.propertyIsEnumerable.call( node, prop ))
      node['$'+prop] = dict;
    csnPath.pop();
  }

  function refLocation( art ) {
    return (!art) ? '<illegal link>' : art.$location || '<no location>';
  }

  function simpleRef( node, prop ) {
    const notFound = (options.testMode) ? undefined : null;
    const ref = node[prop];
    if (Array.isArray( ref )) {
      node['_' + prop] = ref.map( r => refLocation( artifactRef( r, notFound ) ) );
    }
    else if (typeof ref !== 'string' || !ref.startsWith( 'cds.')) {
      node['_' + prop] = refLocation( artifactRef( ref, notFound ) );
    }
  // catch (e) {
  //     node['_' + prop] = e.toString();
  // }
  }

  function pathRef( node, prop, path ) {
    const { links, art, scope } = (() => {
      if (options.testMode)
        return inspectRef( csnPath );
      else {
        try {
          return inspectRef( csnPath );
        }
        catch (e) {
          return { scope: e.toString() };
        }
      }
    } )();
    if (links)
      node._links = links.map( l => refLocation( l.art ) );
    if (links && links[links.length-1].art !== art)
      node._art = refLocation( art );
    node._scope = scope;

    csnPath.push( prop );
    path.forEach( function step( s, i ) {
      if (s && typeof s === 'object') {
        csnPath.push( i );
        if (s.args)
          standard( s, 'args', s.args );
        if (s.where)
          standard( s, 'where', s.where );
        csnPath.pop();
      }
    } );
    csnPath.pop();
  }
}

function reveal( node, prop, value ) {
  Object.defineProperty( node, prop, {
    value,
    configurable: true,
    writable: true,
    enumerable: true,
  } );
}

function setLocations( node, prop, loc ) {
  if (!node || typeof node !== 'object')
    return;
  const isMember = csnRefs.artifactProperties.includes( prop );
  if (!isMember && node.$location) {
    const value = locationString( node.$location );
    reveal( node, '$location', value );
    loc = value + '-';
  }
  else if (prop === true) {
    loc += '1';
    node.$location = loc;
  }
  if (Array.isArray( node )) {
    for (const item of node)
      setLocations( item, isMember, loc );
  }
  else {
    for (const name of Object.getOwnPropertyNames( node ))
      setLocations( node[name], isMember || name, loc );
  }
}

module.exports = enrichCsn;
