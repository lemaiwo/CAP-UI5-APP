'use strict';

const { forEachDefinition, forEachGeneric, forEachMemberRecursively, setProp } = require('../base/model');
const deepCopy = require('../base/deepCopy');
const { CompilationError, hasErrors, sortMessages } = require('../base/messages');
const { isManagedAssociationElement, isStructuredElement, isAssociation, isAssocOrComposition, isElementWithType,
        renameAnnotation, addBoolAnnotationTo, addStringAnnotationTo, addEnumAnnotationTo, addRefAnnotationTo, copyAnnotations,
        foreachPath, hasBoolAnnotation, getElementDatabaseNameOf, getArtifactDatabaseNameOf } = require('../model/modelUtils');
const transformUtils = require('./transformUtils');
const { mergeOptions } = require('../model/modelUtils');
const alerts = require('../base/alerts');
const { isEdmPropertyRendered } = require('../model/csnUtils');

// Transformation for ODATA. Expects an augmented 'inputModel', processes it for ODATA.
// The result should be suitable for consumption by EDMX processors (annotations and metadata)
// and also as a final CSN output for the ODATA runtime (when compacted).
// Performs the following transformations:
// - Flatten structured elements (and foreign keys of managed associations pointing to
//   keys that are themselves managed associations).
// - Generate foreign key fields for entities with managed associations (annotated with
//   '@odata.foreignKey4'). Propagate along projections accordingly. Names are built using
//   <assoc>_<key>, conflicts are checked.
// - Complete the 'foreignKeys' property for all managed associations, so that there
//   is always a 'generatedFieldName' for the corresponding generated foreign key field.
// - Implicitly redirect associations based on exposure
// - Check that exposed associations do not point to non-exposed targets
// - Add an attribute '_service' to all artifacts that are exposed in a service (pointing to
//   the service artifact). This should be used by EDMX processors to detect exposed artifacts.
// - Unravel derived type chains, propagating annotations upwards.
// - Rename annotations according to a fixed list of short-hands
// Returns an (augmented) copy of 'inputModel' with the transformation applied. Does not change the original inputModel.
// Throws a CompilationError on errors. Warnings are stored in the result model.
function transform4odata(inputModel, options) {
  const { error, warning, info, signal } = alerts(inputModel);
  let model;


  model  = deepCopy(inputModel);

  model.messages = inputModel.messages;
  options = mergeOptions(inputModel.options, options);
  model.options = options;

  const { flattenForeignKeys, createForeignKeyElement, checkForeignKeys,
          flattenStructuredElement, flattenStructStepsInPath,
          checkExposedAssoc, toFinalBaseType,
          createAndAddDraftAdminDataProjection,
          createScalarElement, createAssociationElement, createAssociationPathComparison,
          addElement, createAction, addAction, copyAndAddElement,
          extractValidFromToKeyElement, checkAssignment, checkMultipleAssignments } = transformUtils.getTransformers(model, '_');

  // semantic checks before flattening
  forEachDefinition(model, artifact => {
    // Gather all elements with @cds.valid.from/to/key
    let validFrom = [], validTo = [], validKey = [];
    forEachMemberRecursively(artifact, member => {
      let [f, t, k] = extractValidFromToKeyElement(member);
      validFrom.push(...f);
      validTo.push(...t);
      validKey.push(...k);


    });
    // Check that @cds.valid.from/to/key is only in valid places
    validFrom.forEach(e => checkAssignment('@cds.valid.from', e, artifact));
    validTo.forEach(e => checkAssignment('@cds.valid.to', e, artifact));
    validKey.forEach(e => checkAssignment('@cds.valid.key', e, artifact));
    checkMultipleAssignments(validFrom, '@cds.valid.from', artifact);
    checkMultipleAssignments(validTo, '@cds.valid.to', artifact);
    checkMultipleAssignments(validKey, '@cds.valid.key', artifact);
    if(validKey.length && !(validFrom.length && validTo.length)){
      signal(error`@cds.valid.key was used but @cds.valid.from and @cds.valid.to are missing`, artifact.location);
    }
  });


  // Second walk: Flatten structs, unravel derived types, deal with annotations
  forEachDefinition(model, (artifact) => {
    // For entities and views only
    if (artifact.kind === 'entity' || artifact.kind === 'view') {
      // Flatten structs (might result in new elements)
      for (let elemName in artifact.elements) {
        let elem = artifact.elements[elemName];
        if (isStructuredElement(elem)) {
          // Remove the structured element, replace it by its flattened form
          delete artifact.elements[elemName];
          let flatElems = flattenStructuredElement(elem);
          for (let flatElemName in flatElems) {
            if (artifact.elements[flatElemName]) {
              signal(error`"${artifact.name.absolute}.${elemName}": Flattened struct element name conflicts with existing element: "${flatElemName}"`, elem.location);
            }
            artifact.elements[flatElemName] = flatElems[flatElemName];
             // FIXME: Should also adapt indexNo of the newly added elements and all subsequent ones
          }
        }
        if (artifact._service && !isElementWithType(elem)) {
          signal(error`Element "${artifact.name.absolute}.${elemName}" does not have a type: Elements of ODATA entities must have a type`, elem.location);
        }
      }
    }
    // Expose (named or anonymous) structured types used in structured types
    else if (artifact._service && artifact.kind === 'type') {
      for (let elemName in artifact.elements) {
        let elem = artifact.elements[elemName];
        // Expose structured types used in exposed structured types
        exposeStructTypeOf(elem, artifact._service, `__${artifact.name.absolute.replace(/\./g, '_')}_${elemName}`);
      }
    }
    forEachMemberRecursively(artifact, (member) => {
      // Unravel derived type chains for elements, actions, action parameters (propagating annotations)
      toFinalBaseType(member);
      toFinalBaseType(member.items);
      toFinalBaseType(member.returns);
      toFinalBaseType(member.returns && member.returns.items);
      // Mark fields with @odata.on.insert/update as @Core.Computed
      annotateCoreComputed(member);
      // Resolve annotation shorthands for elements, actions, action parameters
      renameShorthandAnnotations(member);
      // check annotations
      checkAnnotations(member);

      // Entities and views only: Flatten structs used in paths
      if (artifact.kind === 'entity' || artifact.kind === 'view') {
        foreachPath(member, (path, pathOwner) => {
          pathOwner.path = flattenStructStepsInPath(path);
        });
      }
    });
    // Unravel derived type chains for types and annotations (propagating annotations)
    if (artifact.kind !== 'entity') {
      toFinalBaseType(artifact);
      toFinalBaseType(artifact.items);
      toFinalBaseType(artifact.returns);
      toFinalBaseType(artifact.returns && artifact.returns.items);
    }
    // If the artifact is a derived structured type, unravel that as well
    if (artifact.kind === 'type' && artifact.type && artifact.type._artifact.elements) {
      // Take the final type's elements
      // FIXME: Actually, we should deep-copy here and adapt _parent, _main, name , ...
      artifact.elements = artifact.type._artifact.elements;
      // The artifact's type is now 'cds.struct', which is not shown
      delete artifact.type;
    }
    // Resolve annotation shorthands for entities, types, annotations, ...
    renameShorthandAnnotations(artifact);
    // check annotations
    checkAnnotations(artifact);
  });

  // For exposed actions and functions that use non-exposed or anonymous structured types, create
  // artificial exposing types
  forEachDefinition(model, (artifact) => {
    if (artifact._service) {
      if (artifact.kind === 'action' || artifact.kind === 'function') {
        exposeStructTypesForAction(artifact, artifact._service);
      }

      for (let actionName in artifact.actions || {}) {
        exposeStructTypesForAction(artifact.actions[actionName], artifact._service);
      }
    }
  });

  // Third walk: Generate foreign key fields for managed associations (must be done
  // after struct flattening, otherwise we might encounter already generated foreign
  // key fields in types we have already processed.
  // Check that each service has max one draft root
  // This must be done before draft processing, since all composition targets
  // are annotated with @odata.draft.enabled in that step
  forEachDefinition(model, (artifact) => {
    forEachMemberRecursively(artifact, (member) => {
      // Generate foreign key elements for managed associations
      if (isManagedAssociationElement(member) && !member._ignore) {
        // Flatten foreign keys (replacing foreign keys that are managed associations by their respective foreign keys)
        member.foreignKeys = flattenForeignKeys(member.foreignKeys);
        // Generate foreign key elements
        for (let name in member.foreignKeys) {
          let foreignKeyElement = createForeignKeyElement(member, member.foreignKeys[name], artifact);
          toFinalBaseType(foreignKeyElement);
          // Propagate the association's annotations to the foreign key element
          // (Overwriting because they should win over the derived type unraveling)
          copyAnnotations(member, foreignKeyElement, true);
        }
        // If the managed association is NOT NULL, we give it a target min cardinality of 1
        // if it didn't already have an explicitly specified min cardinality.
        // (No need to check again for min <= max cardinality, because max has already been checked to be > 0)
        if (member.notNull && member.notNull.val===true) {
          if (!member.cardinality) {
            member.cardinality = {};
          }
          if (!member.cardinality.targetMin) {
            member.cardinality.targetMin = {
              literal: 'number',
              val: 1,
            }
          }
        }
      }
    });
  });

  // Fourth walk through the model: Now all artificially generated things are in place
  let visitedArtifacts = {};
  forEachDefinition(model, artifact => {
    if (artifact.kind === 'entity' || artifact.kind === 'view') {
      // Generate artificial draft fields if requested
      // Note that this needs to happen after implicit redirection has been performed, because it checks
      // for all draft nodes (additional artifacts reachable via compositions) to be part of a service.
      // This is typically achieved only by means of implicit redirection.
      if (hasBoolAnnotation(artifact, '@odata.draft.enabled')) {
        // Ignore if not part of a service
        let location = artifact['@odata.draft.enabled'].name && artifact['@odata.draft.enabled'].name.location;
        if (!artifact._service) {
          signal(warning`Ignoring annotation "@odata.draft.enabled" - artifact "${artifact.name.absolute}" is not part of a service`, location);
        }
        else {
          generateDraftForOdata(artifact, artifact, visitedArtifacts);
        }
      }

      for (let elemName in artifact.elements) {
        let elem = artifact.elements[elemName];
        // Check for valid foreign keys
        if (isAssocOrComposition(elem.type)) {
          checkForeignKeys(elem);
        }

        // Remove '$projection' from paths in the element's ON-condition
        // FIXME: Hack - should actually be done by the compiler, and should only
        // affect the element itself, not the various other places sharing the same
        // ON-condition object, e.g. the MIXIN and the query (there, the ON-condition
        // should actually retain its '$projection').
        foreachPath(elem.onCond || {}, (path, node) => {
          if (path[0].id === '$projection') {
            node.path = node.path.slice(1);
          }
        });
      }
      visitedArtifacts[artifact.name.absolute] = true;
    }
    forEachMemberRecursively(artifact, (member, memberName) => {
      if (artifact._service) {
        if (isAssocOrComposition(member.type)) {
          // Check that exposed associations do not point to non-exposed targets
          checkExposedAssoc(artifact, member);

          // CDXCORE-457
          if (artifact.kind === 'type' && options.toOdata.version === 'v2') {
            signal(warning`"${artifact.name.absolute}.${memberName}": Structured types must not contain associations for OData V2`, member.location);
          }
        }
        // CDXCORE-458
        else if (member.kind === 'element' && member.items) {
          if(options.toOdata.version === 'v2') {
            signal(error`"${artifact.name.absolute}.${memberName}": Element must not be an "array of" for OData V2`, member.location);
          }
          else if(['entity', 'view'].includes(artifact.kind)) {
            if(member.items.elements && !member.items.type) {
              signal(error`"${artifact.name.absolute}.${memberName}": Element must not be an "array of anonymous type"`, member.location);
            }
            if(!member.items.elements && member.items.type && !member.items.type._artifact.builtin && member.items.type._service != artifact._service) {
              signal(error`${artifact.name.absolute}.${memberName}": Array type "${member.items.type._artifact.name.absolute}" is not member of service`, member.location);
            }
          }
        }


        // If the association target is annotated with @cds.odata.valuelist, annotate the
        // association with @Common.ValueList.viaAssociation (but only for service member artifacts
        // to avoid CSN bloating). The propatation of the @Common.ValueList.viaAssociation annotation
        // to the foreign keys is done very late in edmPreprocessor.initializeAssociation()
        addCommonValueListviaAssociation(member);

        // https://github.wdf.sap.corp/cdx/cds-compiler/issues/837
        // add check here for @Analytics.Measure and @Aggregation.default
        // @Analytics has scope element
        if (member.kind && member.kind === 'element'
          && member['@Analytics.Measure'] && !member['@Aggregation.default']) {
          signal(
            info`'@Analytics.Measure' expects '@Aggregation.default' to be assigned as well in element '${member.name.absolute}.${member.name.id}'`,
            member.location
          );
        }
      }
    });
  });

  // Fourth walk through the model: Check media type and key-ness (requires that containers have been
  // identified in pass 3), annotate DB names
  var illV2Prefix = RegExp('^(_|[0-9])');
  forEachDefinition(model, artifact => {
    // Annotate artifacts, elements, foreign keys, parameters etc with their DB names if requested
    if (options.toOdata.names) {
      // Skip artifacts that have no DB equivalent anyway
      if (!['service', 'context', 'namespace', 'annotation', 'action', 'function'].includes(artifact.kind)) {
        addStringAnnotationTo('@cds.persistence.name', getArtifactDatabaseNameOf(artifact.name.absolute, options.toOdata.names, model), artifact);
      }
      forEachMemberRecursively(artifact, (member, memberName) => {
        // Only these are actually required and don't annotate virtual elements in entities or types
        // as the have no DB representation (although in views)
        if (['element', 'key', 'param'].includes(member.kind) && (!member.virtual || artifact.query)) {
          // If we have a 'preserved dotted name' (i.e. we are a result of flattening), use that for the @cds.persistence.name annotation
          if (member._flatElementNameWithDots) {
            memberName = member._flatElementNameWithDots;
          }
          addStringAnnotationTo('@cds.persistence.name', getElementDatabaseNameOf(memberName, options.toOdata.names), member);
        }
      });
    }

    // Perform checks for exposed non-abstract entities and views
    if (artifact._service && !artifact.abstract && (artifact.kind === 'entity' || artifact.kind === 'view')) {
      let keyCount = 0;
      let mediaTypes = [];
      // Walk the elements
      let eltCount = 0;
      for (let elemName in artifact.elements) {
        let elem = artifact.elements[elemName];

        // For ODATA V2, element names must not start with digit or '_'
        if (options.toOdata.version === 'v2') {
          if (illV2Prefix.test(elemName)) {
            signal(error`"${artifact.name.absolute}.${elemName}: Element name must not begin with '${elemName[0]}' for OData V2`, elem.location);
          }
        }

        // Count keys and elements annotated with @Core.MediaType
        let ignore = hasBoolAnnotation(elem, '@cds.api.ignore', true);
        if(!elem._ignore) {
          eltCount++;
          if (elem.key && elem.key.val && !ignore) {
            keyCount++;
          }
        }
        if (elem['@Core.MediaType']) {
          mediaTypes.push([elemName, elem]);
        }
      }

      if(eltCount == 0) {
        signal(error`Entity "${artifact.name.absolute}" must have at least one element`, artifact.location);
      }
      // Exposed non-abstract entities must have a key
      if (keyCount == 0) {
        signal(error`Entity "${artifact.name.absolute}" does not have a key: ODATA entities must have a key`, artifact.location);
      }

      // Additional checks for ODATA V2 regarding remaining keys
      if (options.toOdata.version === 'v2') {
        // Elements that are annotated with @Core.HasStream are removed from the entity type.
        // If these are all keys then this would end up with a key-less EntityType wich is illegal in V2
        let mtkeys = mediaTypes.filter(e=>e[1].key && e[1].key.val);
        if (mtkeys.length > 0 && keyCount == mtkeys.length) {
          signal(error`"${artifact.name.absolute}: Key elements [${mtkeys.map(e=>e[0]).join(', ')}] annotated with '@Core.MediaType' are removed from Odata V2 resulting in keyless EntityType`, artifact.location);
        }
        // Today only one MediaType is allowed in V2
        if (mediaTypes.length > 1) {
          signal(error`"${artifact.name.absolute}: Elements [${mediaTypes.map(e=>e[0]).join(', ')}] annotated with '@Core.MediaType', OData V2 allows only one`, artifact.location);
        }
      }

      // Check media type compatibility for all OData versions
      let allowedTypes = ['cds.String', 'cds.Binary', 'cds.LargeBinary'];
      mediaTypes.forEach(e => {
        if (!allowedTypes.includes(e[1]._finalType.type._artifact.name.absolute)) {
          signal(error`"${artifact.name.absolute}.${e[0]}": Element annoted with '@Core.MediaType' must be of either type "${allowedTypes.join(', ')}"`, e[1].location);
        }
      });
    }
  });

  /**
   * Check if any warnings were raised in earlier steps that need to be reclassified - i.e. as errors
   *
   * @param {any} model The model
   * @returns {Array} Reclassified messages-Array
   */
  function reclassifyWarnings(model){
    return model.messages.map(message => {
      switch(message.messageId){
        case 'empty-entity':
        case 'empty-type':
          message.severity = 'Error';
          break;
      }
      return message;
    });
  }

  // Throw exception in case of errors
  if (hasErrors(model.messages)) {
    model.messages = reclassifyWarnings(model);
    throw new CompilationError(sortMessages(model.messages), model);
  }
  return model;

  // Rename shorthand annotations within artifact or element 'node' according to a builtin
  // list.
  function renameShorthandAnnotations(node) {
    // FIXME: Verify this list - are they all still required? Do we need any more?
    const mappings = {
      '@label': '@Common.Label',
      '@title': '@Common.Label',
      '@description': '@Core.Description',
      '@ValueList.entity': '@Common.ValueList.entity',
      '@ValueList.type': '@Common.ValueList.type',
      '@Capabilities.Deletable': '@Capabilities.DeleteRestrictions.Deletable',
      '@Capabilities.Insertable': '@Capabilities.InsertRestrictions.Insertable',
      '@Capabilities.Updatable': '@Capabilities.UpdateRestrictions.Updatable',
    }

    let rewriteCapabilities = true;
    if(hasBoolAnnotation(node, '@readonly') && hasBoolAnnotation(node, '@insertonly') && ['entity', 'view'].includes(node.kind)) {
      rewriteCapabilities = false;
      signal(warning`"@readonly" and "@insertonly" cannot be assigned in combination`, node.location);
    }
    for (let name in node) {
      // Rename according to map above
      if (mappings[name] != undefined) {
        renameAnnotation(node, name, mappings[name]);
      }

      // Special case: '@important: [true|false]' becomes '@UI.Importance: [#High|#Low]'
      if (name === '@important') {
        renameAnnotation(node, name, '@UI.Importance');
        let annotation = node['@UI.Importance'];
        annotation.literal = 'enum';
        annotation.symbol = {
          // Note that an original '@important' without ': true' shows up as undefined value here!!
          id: (annotation.val == undefined || annotation.val == true) ? 'High' : 'Low',
        };
        // FIXME: Strangely, enum-valued annotations have no value
        delete annotation.val;
      }

      // Special case: '@readonly' becomes a triplet of capability restrictions for entities,
      // but '@Core.Immutable' for everything else.
      if(rewriteCapabilities) {
        if (name === '@readonly') {
          if (node.kind === 'entity' || node.kind === 'view') {
            addBoolAnnotationTo('@Capabilities.DeleteRestrictions.Deletable', false, node);
            addBoolAnnotationTo('@Capabilities.InsertRestrictions.Insertable', false, node);
            addBoolAnnotationTo('@Capabilities.UpdateRestrictions.Updatable', false, node);
          }
          else {
            renameAnnotation(node, name, '@Core.Computed');
          }
        }
        // @insertonly is effective on entities/queries only
        else if (name === '@insertonly') {
          if (node.kind === 'entity' || node.kind === 'view') {
            addBoolAnnotationTo('@Capabilities.DeleteRestrictions.Deletable', false, node);
            addBoolAnnotationTo('@Capabilities.ReadRestrictions.Readable', false, node);
            addBoolAnnotationTo('@Capabilities.UpdateRestrictions.Updatable', false, node);
          }
        }
      }
      // Only on element level: translate @mandatory
      if(name === '@mandatory' && node.kind === 'element' && node['@Common.FieldControl'] === undefined) {
        addEnumAnnotationTo('@Common.FieldControl', 'Mandatory', node);
      }
    }
  }

  // Apply checks to all annotations in the model
  // node: artifact/element/action/function/parameter/... that carries the annotations
  function checkAnnotations(node) {
    // currently there is only one check: annotations @sap:... must have a string or boolean value
    //   or no value (as shorcut for boolean value true)
    let annoNames = Object.keys(node).filter(x => x.startsWith('@sap.'));
    for (let name of annoNames) {
      if (node[name].path ||
          !(node[name].literal == undefined || node[name].literal === 'boolean' || node[name].literal === 'string')) {
        signal(warning`Annotation "${name}" must have a string or boolean value`, node[name].location);
      }
    }
  }

  // Generate all that is required in ODATA for draft enablement of 'artifact' into the artifact,
  // into its transitively reachable composition targets, and into the model.
  // 'rootArtifact' is the root artifact where composition traversal started.

  // Constraints
  // Draft Root: Exactly one PK of type UUID
  // Draft Node: One PK of type UUID + 0..1 PK of another type
  // Draft Node: Must not be reachable from multiple draft roots
  function generateDraftForOdata(artifact, rootArtifact, visitedArtifacts) {
    // Sanity check
    if (!artifact._service) {
      throw new Error('Expecting artifact to be part of a service: ' + JSON.stringify(artifact));
    }

    // Nothing to do if already draft-enabled (composition traversal may have circles)
    if ((artifact['@Common.DraftRoot.PreparationAction'] || artifact['@Common.DraftNode.PreparationAction'])
        && artifact.actions && artifact.actions.draftPrepare) {
      return;
    }

    // extract EDM exposed keys for UUID inspection
    let keys = [];
    forEachGeneric(artifact, 'elements', elt => {
      if(elt.key && elt.key.val && isEdmPropertyRendered(elt, options))
        keys.push(elt);
    });

    // A draft enabled entity should *expose* exactly one primary key of type cds.UUID in the EDM document
    if (keys.length !== 1) {
      signal(warning`"${artifact.name.absolute}": "@odata.draft.enabled" - Entity should expose exactly one key element`, artifact.location);
    }

    let uuidCount = keys.reduce((uuidCount, k) => {
      return((k._finalType.name.absolute === 'cds.UUID' && k._finalType.name.$renamed === 'cds.UUID') ? ++uuidCount : uuidCount);
    }, 0);
    if (uuidCount === 0) {
      signal(warning`"${artifact.name.absolute}": "@odata.draft.enabled" - Entity key element should be of type "cds.UUID"`, artifact.location);
    }

    // Generate the DraftAdministrativeData projection into the service, unless there is already one
    let draftAdminDataProjectionName = artifact._service.name.absolute + '.' + 'DraftAdministrativeData';
    let draftAdminDataProjection = model.definitions[draftAdminDataProjectionName];
    if (!draftAdminDataProjection) {
      draftAdminDataProjection = createAndAddDraftAdminDataProjection(artifact._service);
    }
    // Barf if it is not an entity or not what we expect
    if (draftAdminDataProjection.kind !== 'entity' || !draftAdminDataProjection.elements['DraftUUID']) {
      signal(error`Generated entity "${draftAdminDataProjectionName}" conflicts with existing artifact`, draftAdminDataProjection.location);
    }

    // Generate the annotations describing the draft actions (only draft roots can be activated/edited)
    if (artifact == rootArtifact) {
      addStringAnnotationTo('@Common.DraftRoot.PreparationAction', 'draftPrepare', artifact);
      addStringAnnotationTo('@Common.DraftRoot.ActivationAction', 'draftActivate', artifact);
      addStringAnnotationTo('@Common.DraftRoot.EditAction', 'draftEdit', artifact);
    } else {
      addStringAnnotationTo('@Common.DraftNode.PreparationAction', 'draftPrepare', artifact);
    }

    for (let elemName in artifact.elements) {
      let elem = artifact.elements[elemName];
      // Make all non-key elements nullable
      if (elem.notNull && elem.notNull.val===true && !(elem.key && elem.key.val)) {
        delete elem.notNull;
      }
    }

    // Generate the additional elements into the draft-enabled artifact

    // key IsActiveEntity : Boolean default true
    let isActiveEntity = createScalarElement('IsActiveEntity', 'cds.Boolean', true, true, false);
    addBoolAnnotationTo('@UI.Hidden', true, isActiveEntity);
    addElement(isActiveEntity, artifact);

    // HasActiveEntity : Boolean default false
    let hasActiveEntity = createScalarElement('HasActiveEntity', 'cds.Boolean', false, false, true);
    addBoolAnnotationTo('@UI.Hidden', true, hasActiveEntity);
    addElement(hasActiveEntity, artifact);

    // HasDraftEntity : Boolean default false;
    let hasDraftEntity = createScalarElement('HasDraftEntity', 'cds.Boolean', false, false, true);
    addBoolAnnotationTo('@UI.Hidden', true, hasDraftEntity);
    addElement(hasDraftEntity, artifact);

    // @odata.contained: true
    // DraftAdministrativeData : Association to one DraftAdministrativeData;
    let draftAdministrativeData = createAssociationElement('DraftAdministrativeData', draftAdminDataProjection, true);
    draftAdministrativeData.cardinality = {
      targetMax: {
        literal: 'number',
        val: 1,
      },
    };
    addBoolAnnotationTo('@odata.contained', true, draftAdministrativeData);
    addBoolAnnotationTo('@UI.Hidden', true, draftAdministrativeData);
    addElement(draftAdministrativeData, artifact);
    // Note that we need to do the ODATA transformation steps for managed associations
    // (foreign key field generation, generatedFieldName) by hand, because the corresponding
    // transformation steps have already been done on all artifacts when we come here)
    if (draftAdministrativeData.foreignKeys['DraftUUID']) {
      let foreignKeyElement = createForeignKeyElement(draftAdministrativeData, draftAdministrativeData.foreignKeys['DraftUUID'], artifact);
      addBoolAnnotationTo('@odata.contained', true, foreignKeyElement);
      addBoolAnnotationTo('@UI.Hidden', true, foreignKeyElement);
    }
    // SiblingEntity : Association to one <artifact> on (... IsActiveEntity unequal, all other key fields equal ...)
    let siblingEntity = createAssociationElement('SiblingEntity', artifact, false);
    siblingEntity.cardinality = {
      targetMax: {
        literal: 'number',
        val: 1,
      },
    };
    addElement(siblingEntity, artifact);
    // ... on SiblingEntity.IsActiveEntity != IsActiveEntity ...
    siblingEntity.onCond = createAssociationPathComparison(siblingEntity, isActiveEntity, '!=', isActiveEntity);

    // Iterate elements
    for (let elemName in artifact.elements) {
      let elem = artifact.elements[elemName];
      if (elemName !== 'IsActiveEntity' && elem.key) {
        // Amend the ON-condition above:
        // ... and SiblingEntity.<keyfield> = <keyfield> ... (for all key fields except 'IsActiveEntity')
        siblingEntity.onCond = {
          op: {
            val: 'and',
          },
          args: [
            createAssociationPathComparison(siblingEntity, elem, '=', elem),
            siblingEntity.onCond,
          ]
        }
      }

      // Draft-enable the targets of composition elements (draft nodes), too
      if (elem.target && elem._finalType.type && elem._finalType.type._artifact.name.absolute === 'cds.Composition') {
        let draftNode = elem.target._artifact;
        // Ignore if that is our own draft root
        if (draftNode != rootArtifact) {
          // Barf if the draft node has @odata.draft.enabled itself
          if (hasBoolAnnotation(draftNode, '@odata.draft.enabled')) {
            signal(error`"${elem.name.absolute}.${elem.name.element}": Composition in draft-enabled entity cannot lead to another entity with "@odata.draft.enabled"`, elem.location);
          }
          // Ignore composition if not part of a service
          else if (!draftNode._service) {
            signal(warning`Target "${draftNode.name.absolute}" of composition "${elem.name.absolute}.${elem.name.element}" cannot be a draft node because it is not part of a service`, elem.location);
            continue;
          }
          // if odata.draft.enabled is explicitly set to false, we ignore it when linked via composition
          else if (hasBoolAnnotation(draftNode, '@odata.draft.enabled', false)) {
            continue;
          }
          else {
            // Generate draft stuff into the target
            generateDraftForOdata(draftNode, rootArtifact, visitedArtifacts);
          }
        }
      }
    }

    // Generate the actions into the draft-enabled artifact (only draft roots can be activated/edited)

    // action draftPrepare (SideEffectsQualifier: String) return <artifact>;
    let draftPrepare = createAction('draftPrepare', artifact, 'SideEffectsQualifier', 'cds.String');
    addAction(draftPrepare, artifact);

    if (artifact == rootArtifact) {
      // action draftActivate() return <artifact>;
      let draftActivate = createAction('draftActivate', artifact);
      addAction(draftActivate, artifact);

      // action draftEdit (PreserveChanges: Boolean) return <artifact>;
      let draftEdit = createAction('draftEdit', artifact, 'PreserveChanges', 'cds.Boolean');
      addAction(draftEdit, artifact);
    }
  }

  // If 'action' uses structured types as parameters or return values that are not exposed in 'service'
  // (because the types are anonymous or have a definition outside of 'service'), create equivalent types
  // in 'service' and make 'action' use them instead
  function exposeStructTypesForAction(action, service) {
    exposeStructTypeOf(action.returns, service, `__return_${actionNameNoDots(action)}`);
    for (let paramName in action.params || {}) {
      exposeStructTypeOf(action.params[paramName], service, `__param_${actionNameNoDots(action)}_${paramName}`);
    }
  }

  // Return the absolute name of an action/function, with all dots replaced by underscores
  function actionNameNoDots(action) {
    return action.name.absolute.replace(/\./g, '_') + (action.name.action ? `_${action.name.action}` : '');
  }

  // If 'node' exists and has a structured type that is not exposed in 'service', (because the type is
  // anonymous or has a definition outside of 'service'), create an equivalent type in 'service', either
  // using the type's name or (if anonymous) 'artificialName', and make 'node' use that type instead.
  // If there is an error, complain on 'node.location'.
  function exposeStructTypeOf(node, service, artificialName) {
    if (!node) {
      return;
    }
    if (node.items) {
      exposeStructTypeOf(node.items, service, artificialName);
    }
    if ((node._finalType || node.type).elements && (!node.type || node.type._artifact._service != service)) {
      let typeId = node.type ? `__${node.type._artifact.name.absolute.replace(/\./g, '_')}`
                             : artificialName;
      let type = exposeStructType(typeId, node._finalType.elements, service, node.location);
      if (!type) {
        // Error already reported
        return;
      }
      // Recurse into elements of 'type' (if any)
      for (let elemName in type.elements) {
        exposeStructTypeOf(type.elements[elemName], service, `${typeId}_${elemName}`);
      }
      // Use newly created 'type' for 'node'
      node.type = {
        path : [ { id: type.name.absolute } ],
      };
      setProp(node.type, '_artifact', type);
      setProp(node.type.path[0], '_artifact', type);
      setProp(node, '_finalType', type);
    }
  }

  // Expose an artificial structured type with ID 'typeId' with 'elements' in 'service' (reusing such a type
  // if it already exists).
  // Return the exposed type. Report any errors on 'location'
  function exposeStructType(typeId, elements, service, location) {
    let typeName = `${service.name.absolute}.${typeId}`;
    // If type already exists, reuse it (complain if not created here)
    let type = model.definitions[typeName];
    if (type) {
      if (type.$inferred === 'actionType') {
        return type;
      } else {
        signal(error`Cannot create artificial type "${typeName}" for an action or function because the name is already used`, location);
        return null;
      }
    }
    // Create type with empty elements
    type = {
      name: {
        path: [ { id: typeName }],
        id: typeId,
        absolute: typeName,
      },
      kind: 'type',
      elements: Object.create(null),
      $inferred: 'actionType',
    };
    // Duplicate the type's elements
    for (let elemName in elements) {
      copyAndAddElement(elements[elemName], type, elemName);
    }
    setProp(type, '_finalType', type);
    service.artifacts[typeId] = type;
    setProp(type, '_parent', service);
    model.definitions[typeName] = type;
    return type;
  }
}

/**
 * Mark elements that are annotated with @odata.on.insert/update with the annotation @Core.Computed.
 *
 * Implements: CDXCORE-62
 *
 * @param {any} node The node to check
 */
function annotateCoreComputed(node){
  // If @Core.Computed is explicitly set, don't overwrite it!
  if (node['@Core.Computed'] || node.kind !== 'element')
    return;
  // For @odata.on.insert/update, also add @Core.Computed
  if(node['@odata.on.insert'] || node['@odata.on.update']){
    addBoolAnnotationTo('@Core.Computed', true, node);
  }
}

  //
/**
 * Mark association whose target has @cds.odata.valuelist with @Common.ValueList.viaAssociation
 * => This must be done before foreign keys are calculated and the annotations are propagated
 *    to them. This will make sure that association and all its foreing keys are annotated with
 *    Common.ValueList in the final EDM.
 *
 * Do this only if the association is navigable and the enclosing artifact is
 * a service member (don't pollute the CSN with unnecessary annotations).
 *
 * Implements: CDXCORE-481
 *
 */
function addCommonValueListviaAssociation(member) {
  let vlAnno = '@Common.ValueList.viaAssociation';
  if(isAssociation(member.type)) {
    let navigable = hasBoolAnnotation(member, '@odata.navigable') !== false;
    if(navigable && member.target._artifact['@cds.odata.valuelist'] &&  !member[vlAnno]) {
      addRefAnnotationTo(vlAnno, [ { id: member.name.id } ], member);
    }
  }
}

// Return an array of non-abstract service names contained in (augmented or compacted) 'model''
function getServiceNames(model) {
  let resultDict = Object.create(null);
  forEachDefinition(model, (artifact, artifactName) => {
    if (artifact.kind === 'service' && !artifact.abstract) {
      resultDict[artifactName] = artifact;
    }
  });
  return Object.keys(resultDict);
}

module.exports = {
  transform4odata,
  getServiceNames
}
