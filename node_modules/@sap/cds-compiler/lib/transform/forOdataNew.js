'use strict';

const alerts = require('../base/alerts');
const { handleMessages } = require('../base/messages');
const { setProp } = require('../base/model');
const transformUtils = require('./transformUtilsNew');
const { mergeOptions, copyAnnotations, getElementDatabaseNameOf } = require('../model/modelUtils');
const { getUtils,
        cloneCsn,
        forEachGeneric,
        forEachDefinition,
        forEachMemberRecursively,
        forEachRef,
        isEdmPropertyRendered } = require('../model/csnUtils');
const { checkCSNVersion } = require('../json/csnVersion');

// Transformation for ODATA. Expects a CSN 'inputModel', processes it for ODATA.
// The twin of forOdata.js
// The result should be suitable for consumption by EDMX processors (annotations and metadata)
// and also as a final CSN output for the ODATA runtime (when compacted).
// Performs the following transformations:
//
//   (0) Semantic checks before flattening regarding temporal data
//   (1.1) Flatten structured elements (and foreign keys of managed associations pointing to
//       keys that are themselves managed associations).
//       TODO: probably only for OData V2?
//   (1.2) Expose (named or anonymous) structured types used in structured types
//   (1.3) Unravel derived types for elements, actions, action parameters, types and
//       annotations (propagating annotations)
//   (1.4) Mark fields with @odata.on.insert/update as @Core.Computed
//   (1.5) Rename shorthand annotations according to a builtin list.
//       e.g. @label -> @Common.Label or @important: [true|false] -> @UI.Importance: [#High|#Low]
//   (1.6) Check annotations. If annotation starts with '@sap...' it must have a string or boolean value
//  Transformations (1.1), (1.2), (1.3), (1.4), (1.5) and (1.6) are executed during the first walk through the model
//
//   (2.1) For exposed actions and functions that use non-exposed or anonymous structured types,
//       create artificial exposing types
//  Transformation (2.1) is a second walk through the definitions
//
//   (3.1) Generate foreign key fields for managed associations, depends on (1.1) in V4 or flatten case
//   (3.2) Flatten/normalize on-conditions in unmanaged associations
//   (3.3) Check that each service has max one draft root
//  Step (3.1) is in the third walk of the model
//
//   (4.1) Generate artificial draft fields if requested
//   (4.3) Check associations for:
//        - exposed associations do not point to non-exposed targets
//        - structured types must not contain associations for OData V2
//   (4.4) Element must not be an 'array of' for OData V2
//   (4.5) If the association target is annotated with @cds.odata.valuelist, annotate the
//        association with @Common.ValueList.viaAssociation
//   (4.6) Check for @Analytics.Measure and @Aggregation.default
//  Fourth loop: (4.1) to (4.6)
//
//   (5.1) Annotate artifacts, elements, foreign keys, parameters etc with their DB names if requested
//   (5.2) Perform checks for exposed non-abstract entities and views - check media type and
//        key-ness (requires that containers have been identified in the fourth pass (4.2))
//  Fifth walk through the model with (5.1) and (5.2)

module.exports = { transform4odataWithCsn, getServiceNames };

function transform4odataWithCsn(inputModel, options) {

  if (options.messages) reclassifyWarnings(options);
  else if (inputModel.messages) reclassifyWarnings(inputModel);

  // Throw exception in case of errors
  handleMessages(inputModel, options);

  // copy the model as we don't want to change the input model
  // TODO: set protos to null here -> call the function from lib/json/nullprotos3.js
  let csn = cloneCsn(inputModel);


  options = mergeOptions(inputModel.options, options);
  setProp(csn, 'options', options);

  const { error, warning, info, signal } = alerts(csn, options);

  // the new transformer works only with new CSN
  checkCSNVersion(csn, options);

  const {
    flattenForeignKeys, createForeignKeyElement,
    flattenStructuredElement,
    flattenOnCond,
    checkExposedAssoc, toFinalBaseType,
    createAndAddDraftAdminDataProjection, createScalarElement,
    createAssociationElement, createAssociationPathComparison,
    addElement, createAction,
    addAction, copyAndAddElement,
    checkForeignKeys, extractValidFromToKeyElement,
    checkAssignment, checkMultipleAssignments,
    recurseElements,
    setAnnotation,
    renameAnnotation
  } = transformUtils.getTransformers(csn, options, '_');

  const {
    getArtifactDatabaseNameOf,
    getCsnDef,
    getFinalType,
    getFinalTypeDef,
    getNamespaceOfArtifact,
    getServiceName,
    hasBoolAnnotation,
    isAssocOrComposition,
    isAssociation,
    isBuiltinType,
    isManagedAssociationElement,
    isStructured,
    inspectRef,
    artifactRef
  } = getUtils(csn);

  // are we working with structured OData or not
  const structuredOData = options.toOdata.odataFormat === 'structured' && options.toOdata.version === 'v4';

  // exposed struct types (see function exposeStructType)
  // They have to be memorized to know if a given type is exposed or if there is a name clash
  let exposedStructTypes = {};

  // collect all declared non-abstract services from the model
  // use the array when there is a need to identify if an artifact is in a service or not
  let services = getServiceNames(csn);

  //handles reference flattening
  let referenceFlattener;
  if(!structuredOData) {
    let ReferenceFlattener =  require('./referenceFlattener');
    referenceFlattener = new ReferenceFlattener();
    referenceFlattener.attachPaths(csn);
    referenceFlattener.resolveAllReferences(csn, inspectRef, isStructured);
  }

  // (0) Semantic checks before flattening regarding temporal data and array of
  forEachDefinition(csn, (artifact, artifactName, propertyName, path) => {
    // Gather all element names with @cds.valid.from/to/key
    let validFrom = [], validTo = [], validKey = [];
    recurseElements(artifact, ['definitions', artifactName], (member, path) => {
      let [f, t, k] = extractValidFromToKeyElement(member, path);
      validFrom.push(...f);
      validTo.push(...t);
      validKey.push(...k);
    });
    // Check that @cds.valid.from/to/key is only in valid places
    validFrom.forEach(obj => checkAssignment('@cds.valid.from', obj.element, obj.path, artifact));
    validTo.forEach(obj => checkAssignment('@cds.valid.to', obj.element, obj.path, artifact));
    validKey.forEach(obj => checkAssignment('@cds.valid.key', obj.element, obj.path, artifact));
    checkMultipleAssignments(validFrom, '@cds.valid.from', artifact, artifactName);
    checkMultipleAssignments(validTo, '@cds.valid.to', artifact, artifactName);
    checkMultipleAssignments(validKey, '@cds.valid.key', artifact, artifactName);
    if (validKey.length && !(validFrom.length && validTo.length)) {
      signal(error`@cds.valid.key was used but @cds.valid.from and @cds.valid.to are missing`, path);
    }
  });

  // (1.1) Unravel derived type chains to final one for elements, actions, action parameters (propagating annotations)
  forEachDefinition(csn, (def, defName) => {
    forEachMemberRecursively(def, (member) => {
      if (!member.elements && !member.items) // structured does not have final base type and arrays are covered on the next line
        toFinalBaseType(member);
      if (member.type && member.type.ref && member.elements) // type of was already expanded and we can delete the reference to the type
        delete member.type;
      toFinalBaseType(member.items);
      toFinalBaseType(member.returns);
      toFinalBaseType(member.returns && member.returns.items);
    }, ['definitions', defName]);
  });

  // (1.1) Unravel derived type chains for types and annotations (propagating annotations)
  forEachDefinition(csn, (def, defName) => {
    if (def.kind !== 'entity') {
      let finalTypeDef = def;
      if(def.type && def.type.ref) {
        finalTypeDef = artifactRef(def.type);
        if(!finalTypeDef.type) {
          signal(error`"${defName}" has no final type`, ['definitions', defName]);
          return;
        }
      }
      if (!isStructured(finalTypeDef)) {
        try {
          toFinalBaseType(def);
        } catch(ex) {
          signal(error`"${defName}" final base type not found`, ['definitions', defName]);
          return
        }
      }
      toFinalBaseType(def.items);
      toFinalBaseType(def.returns);
      toFinalBaseType(def.returns && def.returns.items);
    }
    // If the definition('def' variable) is a type definition and the assigned type of this very same definition('def' variable)
    // is structured type, e.g.:
    //
    // type Struct1 {
    //    a : Integer;
    //    b : Integer;
    //  };
    // type Struct2: Struct1;
    // after compilation the csn looks like this:
    // ...
    // "S.Struct1": {
    //   "kind": "type",
    //   "elements": {
    //     "a": { "type": "cds.Integer" },
    //     "b": { "type": "cds.Integer" }
    //   } },
    // "S.Struct2": {
    //   "kind": "type",
    //   "type": "S.Struct1",
    //   "elements": {
    //     "a": { "type": "cds.Integer" },
    //     "b": { "type": "cds.Integer" }
    //   } } ...
    //
    // "S.Struct2" should looks just like "S.Struct1" => the "type": "S.Struct1" property has to be removed
    if (def.kind === 'type' && def.type && !isBuiltinType(def.type) && !def.type.ref) {
      // elements are already there -> do not show the type
      delete def.type;
    }
    // In case we have in the model something like:
    // type Foo: array of Bar; type Bar: { qux: Integer };
    // In the type Foo we expand the first level of elements of the items or
    // type Foo: array of { qux: Integer };
    if (def.kind === 'type' && def.items && isArtifactInSomeService(defName, services))
      expandFirstLevelOfArrayed(def);
  });

  // (1.2) Mark fields with @odata.on.insert/update as @Core.Computed
  // (1.3) Resolve annotation shorthands,
  // (1.4) Check @cds... annotations
  // (1.5) Flatten structs
  // (1.6) Expose (named or anonymous) structured types used in structured types
  // TODO: only for V2 or via special option???
  forEachDefinition(csn, (def, defName, propertyName, path) => {

    // (1.5) Flatten structs - for entities and views only (might result in new elements)
    if (def.kind === 'entity' || def.kind === 'view') {
      for (let elemName in def.elements) {
        let elem = def.elements[elemName];
        if (isStructured(elem)) {
          if (structuredOData) {
            if (!isArtifactInSomeService(defName, services)) return;
            let serviceName = getServiceName(defName);
            exposeStructTypeOf(elem, serviceName, `${defNameWithoutServiceName(defName, serviceName).replace(/\./g, '_')}_${elemName}`, elemName);
          } else {
            // Remove the structured element, replace it by its flattened form
            delete def.elements[elemName];
            let ipath = path.concat('elements', elemName)
            let flatElems = flattenStructuredElement(elem, elemName, [], ipath, (flatPath) => {
              if (referenceFlattener)
                referenceFlattener.registerFlattenedElement(flatPath)
            });
            for (let flatElemName in flatElems) {
              if (def.elements[flatElemName]) {
                signal(error`"${defName}.${elemName}": Flattened struct element name conflicts with existing element: "${flatElemName}"`, path.concat(['elements', flatElemName]));
              }
              def.elements[flatElemName] = flatElems[flatElemName];
            }
          }
        }
        if (getServiceName(defName) && !elem.type && !elem.items && !elem.elements) {
          signal(error`Element "${defName}.${elemName}" does not have a type: Elements of ODATA entities must have a type`, path.concat(['elements', elemName]));
        }
      }
    }
    // (1.6) Expose (named or anonymous) structured types used in structured types
    else if (isArtifactInSomeService(defName, services) && def.kind === 'type') {
      for (let elemName in def.elements) {
        let elem = def.elements[elemName];
        // Expose structured types used in exposed structured types
        exposeStructTypeOf(elem, getServiceOfArtifact(defName, services), `${defName.replace(/\./g, '_')}_${elemName}`, `${defName}.${elemName}`);
      }
    }
  });

  // flatten references, attach new paths
  if(referenceFlattener) {
    referenceFlattener.flattenAllReferences(csn);
    referenceFlattener.attachPaths(csn);
  }

  // Second walk: Only through definitions
  // (2.1) For exposed actions and functions that use non-exposed or anonymous structured types, create
  // artificial exposing types
  forEachDefinition(csn, (def, defName) => {
    let service = getServiceOfArtifact(defName, services);
    if (service) {
      if (def.kind === 'action' || def.kind === 'function') {
        exposeTypesForAction(def, defName, service);
      }

      for (let actionName in def.actions || {}) {
        exposeTypesForAction(def.actions[actionName], `${defName}_${actionName}`, service);
      }

      if (def.kind === 'entity' || def.kind === 'view') {
        let isAction = false;
        // If a member is of type 'array of T' where T is either user defined structured type outside of the service or anonymous type,
        // then expose T and assign it do the member.
        forEachMemberRecursively(def, (member, memberName, propertyName, path) => {
          // we do not apply array of exposure logic on actions/functions
          // and on params and returns of action/function
          if (member.kind === 'action' || member.kind === 'function') isAction = true;

          // anonymous defined "array of"
          if (member.items || (member.type && getFinalTypeDef(member.type).items)) {
            if (structuredOData)
              exposeArrayOfTypeOf(member, service, `${defNameWithoutServiceName(defName, service)}_${memberName}`, memberName);
            else if (!isAction) signal(error`"${memberName}": Element must not be an "array of" in flat mode`, path);
          }
        }, ['definitions', defName]);
      }
    }
  });

  // Third walk: Process associations
  // (3.1) Generate foreign key fields for managed associations (must be done
  // after struct flattening, otherwise we might encounter already generated foreign
  // key fields in types we have already processed)
  // (3.2) Flatten on-conditions in unmanaged associations
  // This must be done before 4.1, since all composition targets are annotated with @odata.draft.enabled in this step

  let sortByAssociationDependency = require('./sortByAssociationDependency');
  let sortedArtifactNames = sortByAssociationDependency(csn);

  let flattenedKeyArts = Object.create(null);
  sortedArtifactNames.forEach(defName => {
    let def = csn.definitions[defName];
    flattenForeignKeysForArt(def, defName, flattenedKeyArts);
  })

  // Fourth walk through the model: Now all artificially generated things are in place
  // (4.1) Generate artificial draft fields if requested
  // TODO: should be done by the compiler - Check associations for valid foreign keys
  // TODO: checkif needed at all: Remove '$projection' from paths in the element's ON-condition
  // (4.2) Check associations for:
  //        - exposed associations do not point to non-exposed targets
  //        - structured types must not contain associations for OData V2
  // (4.3) Element must not be an 'array of' for OData V2
  // (4.4) If the association target is annotated with @cds.odata.valuelist, annotate the
  //      association with @Common.ValueList.viaAssociation
  // (4.5) Check for @Analytics.Measure and @Aggregation.default
  let visitedArtifacts = {};
  forEachDefinition(csn, (def, defName) => {
    if (def.kind === 'entity' || def.kind === 'view') {
      // (4.1) Generate artificial draft fields if requested
      if (def['@odata.draft.enabled']) {
        // Ignore if not part of a service
        if (!isArtifactInSomeService(defName, services)) {
          signal(warning`Ignoring annotation "@odata.draft.enabled" - artifact "${defName}" is not part of a service`, ['definitions', defName]);
        }
        else {
          generateDraftForOdata(def, defName, def, visitedArtifacts);
        }
      }

      for (let elemName in def.elements) {
        let elem = def.elements[elemName];
        // Check for valid foreign keys
        if (isAssocOrComposition(elem.type)) {
          checkForeignKeys(elem, elemName, defName, options);
        }
      }
    }
    forEachMemberRecursively(def, (member, memberName, propertyName, path) => {
      if (isArtifactInSomeService(defName, services) || isLocalizedArtifactInService(defName, services)) {
        let service = getServiceOfArtifact(defName, services);
        // (4.2) Check associations
        if (isAssocOrComposition(member.type)) {
          // Check that exposed associations do not point to non-exposed targets
          checkExposedAssoc(defName, member, memberName, service);

          // CDXCORE-457
          if (def.kind === 'type' && options.toOdata.version === 'v2') {
            signal(warning`"${defName}.${memberName}": Structured types must not contain associations for OData V2`, path);
          }
        }
        // (4.3) CDXCORE-458
        else if (propertyName === 'elements' && member.items) {
          if (options.toOdata.version === 'v2') {
            signal(error`"${defName}.${memberName}": Element must not be an "array of" for OData V2`, path);
          }
          else if (['entity', 'view'].includes(def.kind)) {
            // array of <anonymous type> is not allowed
            // array of T is allowed, if T is in defining service or in namespace 'cds'
            if (member.items.elements && !member.items.type) {
              signal(error`"${defName}.${memberName}": Element must not be an "array of anonymous type"`, path);
            }
          }
        }

        // (4.4) If the member is an association and the target is annotated with @cds.odata.valuelist,
        // annotate the association with @Common.ValueList.viaAssociation (but only for service member artifacts
        // to avoid CSN bloating). The propagation of the @Common.ValueList.viaAssociation annotation
        // to the foreign keys is done very late in edmPreprocessor.initializeAssociation()
        addCommonValueListviaAssociation(member, memberName);

        // (4.5) https://github.wdf.sap.corp/cdx/cds-compiler/issues/837
        // add check here for @Analytics.Measure and @Aggregation.default
        // @Analytics has scope element
        if (member['@Analytics.Measure'] && !member['@Aggregation.default']) {
          signal(
            info`'@Analytics.Measure' expects '@Aggregation.default' to be assigned as well in element '${defName}.${memberName}'`,
            // ['definitions', defName, 'elements', memberName]
            path
          );
        }
      }
      visitedArtifacts[defName] = true;
    }, ['definitions', defName]);
  });

  // Fifth walk through the model:
  // (5.1) Annotate artifacts, elements, foreign keys, parameters etc with their DB names if requested
  // (5.2) Perform checks for exposed non-abstract entities and views - check media type and
  //      key-ness (requires that containers have been identified in the fourth pass (4.2))
  let illV2Prefix = RegExp('^(_|[0-9])');
  forEachDefinition(csn, (def, defName) => {
    // (5.1) Annotate artifacts, elements, foreign keys, parameters etc with their DB names if requested
    if (options.toOdata.names) {
      // Skip artifacts that have no DB equivalent anyway
      if (!['service', 'context', 'namespace', 'annotation', 'action', 'function'].includes(def.kind)) {
        def['@cds.persistence.name'] = getArtifactDatabaseNameOf(defName, options.toOdata.names, getNamespaceOfArtifact(defName));
      }
      forEachMemberRecursively(def, (member, memberName, prop) => {
        // Only these are actually required and don't annotate virtual elements in entities or types
        // as they have no DB representation (although in views)
        if (typeof member === 'object' && !['action', 'function'].includes(member.kind) && prop !== 'enum' && (!member.virtual || def.query)) {
          // If we have a 'preserved dotted name' (i.e. we are a result of flattening), use that for the @cds.persistence.name annotation
          if (member._flatElementNameWithDots) {
            memberName = member._flatElementNameWithDots;
          }
          member['@cds.persistence.name'] = getElementDatabaseNameOf(memberName, options.toOdata.names);
        }
      });
    }

    // (5.2) Perform checks for exposed non-abstract entities and views
    if (isArtifactInSomeService(defName, services) && !def.abstract && (def.kind === 'entity' || def.kind === 'view')) {
      let keyCount = 0;
      /** @type {[string, CSN.Element][]} */
      let mediaTypes = [];
      // Walk the elements
      let eltCount = 0;
      for (let elemName in def.elements) {
        let elem = def.elements[elemName];

        // For ODATA V2, element names must not start with digit or '_'
        if (options.toOdata.version === 'v2') {
          if (illV2Prefix.test(elemName)) {
            signal(error`"${defName}.${elemName}: Element name must not begin with '${elemName[0]}' for OData V2`, ['definitions', defName, 'elements', elemName]);
          }
        }

        // Count keys and elements annotated with @Core.MediaType
        let ignore = elem['@cds.api.ignore'];
        eltCount++;
        if (elem.key && !ignore) {
          keyCount++;
        }
        if (elem['@Core.MediaType']) {
          mediaTypes.push([elemName, elem]);
        }
      }

      if (eltCount == 0) {
        signal(error`Entity "${defName}" must have at least one element`, ['definitions', defName]);
      }
      // Exposed non-abstract entities must have a key
      if (keyCount == 0) {
        signal(error`Entity "${defName}" does not have a key: ODATA entities must have a key`, ['definitions', defName]);
      }

      // Additional checks for ODATA V2 regarding remaining keys
      if (options.toOdata.version === 'v2') {
        // Elements that are annotated with @Core.HasStream are removed from the entity type.
        // If these are all keys then this would end up with a key-less EntityType wich is illegal in V2
        let mtkeys = mediaTypes.filter(e => e[1].key);
        if (mtkeys.length > 0 && keyCount == mtkeys.length) {
          signal(error`"${defName}: Key elements [${mtkeys.map(e => e[0]).join(', ')}] annotated with '@Core.MediaType' are removed from Odata V2 resulting in keyless EntityType`, ['definitions', defName]);
        }
        // Today only one MediaType is allowed in V2
        if (mediaTypes.length > 1) {
          signal(error`"${defName}: Elements [${mediaTypes.map(e => e[0]).join(', ')}] annotated with '@Core.MediaType', OData V2 allows only one`, ['definitions', defName]);
        }
      }

      // Check media type compatibility for all OData versions
      let allowedTypes = ['cds.String', 'cds.Binary', 'cds.LargeBinary'];
      mediaTypes.forEach(e => {
        if (!allowedTypes.includes(e[1].type)) {
          signal(error`"${defName}.${e[0]}": Element annoted with '@Core.MediaType' must be of either type "${allowedTypes.join(', ')}"`, ['definitions', defName, 'elements', e[0]]);
        }
      });
    }
  });

  // Deal with all kind of annotations manipulations here
  forEachDefinition(csn, (def, defName, propertyName, path) => {
    // (1.5) Resolve annotation shorthands for entities, types, annotations, ...
    renameShorthandAnnotations(def, path);
    // (1.6) check annotations
    checkAnnotations(def, ['definitions', defName]);

    forEachMemberRecursively(def, (member, memberName, propertyName, path) => {
      // (1.2) Mark fields with @odata.on.insert/update as @Core.Computed
      annotateCoreComputed(member);

      // (1.3) Resolve annotation shorthands for elements, actions, action parameters
      renameShorthandAnnotations(member, path);

      // (1.4) check annotations
      checkAnnotations(member, path);
    }, ['definitions', defName]);
  })

  /**
 * Check if any warnings were raised in earlier steps that need to be reclassified - i.e. as errors
 *
 * @param {any} csn The csn
 * @returns {Array} Reclassified messages-Array
 */
  function reclassifyWarnings(csn) {
    return csn.messages.map(message => {
      switch (message.messageId) {
        case 'enum-value-ref':
        case 'empty-entity':
        case 'empty-type':
        case 'check-proper-type-of':
          message.severity = 'Error';
          break;
      }
      return message;
    });
  }

  // Throw exception in case of errors
  handleMessages(csn, options);

  if (options.messages) setProp(csn, 'messages', options.messages);
  return csn;

  // (1.4) Mark elements that are annotated with @odata.on.insert/update with the annotation @Core.Computed.
  // Implements: CDXCORE-62
  function annotateCoreComputed(node) {
    // If @Core.Computed is explicitly set, don't overwrite it!
    if (node['@Core.Computed']) return;

    // For @odata.on.insert/update, also add @Core.Computed
    if (node['@odata.on.insert'] || node['@odata.on.update'])
      node['@Core.Computed'] = true;
  }

  // (1.5) Rename shorthand annotations within artifact or element 'node' according to a builtin
  // list.
  function renameShorthandAnnotations(node, path) {
    // FIXME: Verify this list - are they all still required? Do we need any more?
    const mappings = {
      '@label': '@Common.Label',
      '@title': '@Common.Label',
      '@description': '@Core.Description',
      '@ValueList.entity': '@Common.ValueList.entity',
      '@ValueList.type': '@Common.ValueList.type',
      '@Capabilities.Deletable': '@Capabilities.DeleteRestrictions.Deletable',
      '@Capabilities.Insertable': '@Capabilities.InsertRestrictions.Insertable',
      '@Capabilities.Updatable': '@Capabilities.UpdateRestrictions.Updatable',
    }

    let rewriteCapabilities = true;
    if (node['@readonly'] && node['@insertonly'] && ['entity', 'view'].includes(node.kind)) {
      rewriteCapabilities = false;
      signal(warning`"@readonly" and "@insertonly" cannot be assigned in combination`, path);
    }
    for (let name in node) {
      // Rename according to map above
      if (mappings[name] != undefined)
        renameAnnotation(node, name, mappings[name]);

      // Special case: '@important: [true|false]' becomes '@UI.Importance: [#High|#Low]'
      if (name === '@important') {
        renameAnnotation(node, name, '@UI.Importance');
        let annotation = node['@UI.Importance'];
        node['@UI.Importance'] = { '#': annotation ? 'High' : 'Low' }
      }

      // Special case: '@readonly' becomes a triplet of capability restrictions for entities,
      // but '@Core.Immutable' for everything else.
      if(rewriteCapabilities) {
        if (name === '@readonly') {
          if (node.kind === 'entity' || node.kind === 'view') {
            setAnnotation(node, '@Capabilities.DeleteRestrictions.Deletable', false);
            setAnnotation(node, '@Capabilities.InsertRestrictions.Insertable', false);
            setAnnotation(node, '@Capabilities.UpdateRestrictions.Updatable', false);
          } else {
            renameAnnotation(node, name, '@Core.Computed');
          }
        }
        // @insertonly is effective on entities/queries only
        else if (name === '@insertonly') {
          if (node.kind === 'entity' || node.kind === 'view') {
            setAnnotation(node, '@Capabilities.DeleteRestrictions.Deletable', false);
            setAnnotation(node, '@Capabilities.ReadRestrictions.Readable', false);
            setAnnotation(node, '@Capabilities.UpdateRestrictions.Updatable', false);
          }
        }
      }
      // Only on element level: translate @mandatory
      if (name === '@mandatory' && node.kind === undefined && node['@Common.FieldControl'] === undefined) {
        setAnnotation(node, '@Common.FieldControl', { '#': 'Mandatory' });
      }
    }
  }

  // (1.6) Apply checks to all annotations in the model
  // node: artifact/element/action/function/parameter/... that carries the annotations
  function checkAnnotations(node, defPath) {
    // currently there is only one check: annotations @sap:... must have a string or boolean value
    //   or no value (as shorcut for boolean value true)
    let annoNames = Object.keys(node).filter(x => x.startsWith('@sap.'));
    for (let name of annoNames) {
      if (typeof node[name] !== 'boolean' && typeof node[name] !== 'string') {
        signal(warning`Annotation "${name}" must have a string or boolean value`, defPath);
      }
    }
  }

  // In case we have in the model something like:
  // type Foo: array of Bar; type Bar: { qux: Integer };
  // In the type Foo we expand the first level of elements of the items like we have in CDL this:
  // type Foo: array of { qux: Integer };
  function expandFirstLevelOfArrayed(def) {
    if (def.items.type && !isBuiltinType(def.items.type)) {
      let finalType = getFinalTypeDef(def.items.type);
      if (isStructured(finalType)) {
        def.items.elements = cloneCsn(finalType.elements);
        delete def.items.type;
      }
    }
  }

  // (2.1) If 'action' uses structured types as parameters or return values that are not exposed in 'service'
  // (because the types are anonymous or have a definition outside of 'service'), create equivalent types
  // in 'service' and make 'action' use them instead
  function exposeTypesForAction(action, actionName, service) {
    if (action.returns && isArreyed(action.returns))
      exposeArrayOfTypeOf(action.returns, service, `return_${actionName.replace(/\./g, '_')}`, actionName);
    else
      exposeStructTypeOf(action.returns, service, `return_${actionName.replace(/\./g, '_')}`, actionName);

    for (let paramName in action.params || {}) {
      if (isArreyed(action.params[paramName]))
        exposeArrayOfTypeOf(action.params[paramName], service, `param_${actionName.replace(/\./g, '_')}_${paramName}`, actionName);
      else
        exposeStructTypeOf(action.params[paramName], service, `param_${actionName.replace(/\./g, '_')}_${paramName}`, actionName);
    }
  }

  function isArreyed(node) {
    return node.items || (node.type && getFinalTypeDef(node.type).items);
  }

  // If a member is of type "array of <named type|anonymous type>", we expose the arrayed type,
  // like we expose structures in structured mode
  function exposeArrayOfTypeOf(node, service, artificialName, memberName) {
    // if anonymously defined in place -> we always expose the type
    // this would be definition like 'elem: array of { ... }'
    // and we use the artificial name for the new type name
    if (node.items && !node.type) {
      exposeStructTypeOf(node, service, artificialName, memberName);
    }
    // we can have both of the 'type' and 'items' in the cases:
    // 1. 'elem: Foo' and 'type Foo: array of Baz' and 'type Baz: { ... }'
    // or 2. 'elem: Foo' and type Foo: array of Integer|String|...'
    else if (node.type) {
      // case 2. - in V2 we expand to the underlying base scalar and remove the type property
      if (node.items && node.items.type && isBuiltinType(node.items.type)
        && options.toOdata.version === 'v2') delete node.type;
      else if (getFinalTypeDef(node.type).items) {
        if (!isArtifactInService(node.type, service)) {
          let typeId = `${service}.${node.type}`;
          let newType = exposeArrayedType(getFinalTypeDef(node.type), typeId);
          // When we have in the model something like:
          // type Foo: array of Bar; type Bar: { qux: Integer };
          // In the type Foo we expand the first level of elements of the items like we have in CDL this:
          // type Foo: array of { qux: Integer };
          expandFirstLevelOfArrayed(newType);
          node.type = typeId;
        }
        // case 1. - as we keep the type property, the items property is removed
        if (node.items) delete node.items;
      }
    }

    function exposeArrayedType(typeDef, typeId) {
      let newType = csn.definitions[typeId];
      if (newType) {
        if (!(typeId in exposedStructTypes)) {
          signal(error`Cannot create artificial type "${typeId}" because the name is already used`);
          return null;
        }
        return newType;
      }
      // create empty type
      newType = {
        kind: 'type',
        items: Object.create(null),
      }

      // copy over the items
      newType.items = cloneCsn(typeDef.items);
      csn.definitions[typeId] = newType;
      exposedStructTypes[typeId] = true;
      return newType;
    }
  }

  // (1.2), (2.1) If 'node' exists and has a structured type that is not exposed in 'service', (because the type is
  // anonymous or has a definition outside of 'service'), create an equivalent type in 'service', either
  // using the type's name or (if anonymous) 'artificialName', and make 'node' use that type instead.
  // Complain if there is an error.
  function exposeStructTypeOf(node, service, artificialName, parentName) {
    if (!node) {
      return;
    }
    if (node.items) {
      exposeStructTypeOf(node.items, service, artificialName, parentName);
    }

    if ((csn.definitions[node.type] || node).elements
      && (!node.type || (!isArtifactInService(node.type, service) && (!node.type.startsWith('cds.') || node.type.startsWith('cds.foundation'))))) {
      let typeDef = node.type ? getCsnDef(node.type) : /* anonymous type */ node;
      if (typeDef && isStructured(typeDef) || (node.type && !node.type.startsWith(service))) {
        let typeId = node.type ? `${node.type.replace(/\./g, '_')}` : artificialName;
        let type = exposeStructType(typeId, typeDef.elements, service, parentName);
        if (!type) {
          // Error already reported
          return;
        }
        // Recurse into elements of 'type' (if any)
        for (let elemName in type.elements) {
          exposeStructTypeOf(type.elements[elemName], service, `${typeId}_${elemName}`, parentName);
        }
        typeDef.kind === 'type' ? copyAnnotations(typeDef, type) : copyAnnotations(node, type);
        if (structuredOData) delete node.elements;
        node.type = `${service}.${typeId}`;
      }
    }
  }

  // (1.2), (2.1) Expose an artificial structured type with ID 'typeId' with 'elements' in 'service' (reusing such a type
  // if it already exists).
  // Return the exposed type. Report any errors
  function exposeStructType(typeId, elements, service, parentName) {
    let typeName = `${service}.${typeId}`;
    // If type already exists, reuse it (complain if not created here)
    let type = csn.definitions[typeName];
    if (type) {
      if (!(typeName in exposedStructTypes)) {
        signal(error`Cannot create artificial type "${typeName}" for an action or function "${parentName}" because the name is already used`,
          ['definitions', parentName]);
        return null;
      }
      return type;
    }
    // Create type with empty elements
    type = {
      kind: 'type',
      elements: Object.create(null),
    };
    // Duplicate the type's elements
    for (let elemName in elements) {
      copyAndAddElement(elements[elemName], type, typeName, elemName);
    }
    csn.definitions[typeName] = type;
    // store typeName in set of exposed struct types
    exposedStructTypes[typeName] = true;
    return type;
  }

  // Third walk: Process associations
  // (3.1) Generate foreign key fields for managed associations (must be done
  // after struct flattening, otherwise we might encounter already generated foreign
  // key fields in types we have already processed)
  // (3.2) Flatten on-conditions in unmanaged associations
  function flattenForeignKeysForArt(def, defName, flattenedKeyArts) {
    if (defName in flattenedKeyArts)
      return; // already flattened
    flattenedKeyArts[defName] = true;
    const rootPath = ['definitions', defName];
    forEachMemberRecursively(def, (member, memberName, prop, subpath, parent) => {
      // Generate foreign key elements for managed associations.
      // In the case of composition of aspect we might have an element which does not
      // have on-cond and keys, therefore the check if a member has a 'keys'
      if (isManagedAssociationElement(member) && member.keys) {
        // Flatten foreign keys (replacing foreign keys that are managed associations by their respective foreign keys)
        flattenForeignKeys(member, flattenedKeyArts, flattenForeignKeysForArt);
        // Generate foreign key elements
        for (let keyIndex in member.keys) {
          let key = member.keys[keyIndex];
          let keyPath = rootPath.concat(subpath).concat('keys', keyIndex);
          if (!structuredOData) { // flatten the reference using RESOLVED references
            let resolvedIsStructured = referenceFlattener.isStructured(keyPath)
            if (resolvedIsStructured) {
              let ref = key.ref;
              let newref = []; // new flattened reference
              let previousElementIsStructured=false;
              ref.forEach((iref,i) => {
                if(previousElementIsStructured == undefined) return; // missing information - skip processing
                if(previousElementIsStructured) {
                  newref[newref.length-1] = newref[newref.length-1]+'_'+iref; // prevous element is sructured - concat last with current
                } else {
                  newref.push(iref); // prevous element is not structured - do not flatten, just push it
                }
                previousElementIsStructured = resolvedIsStructured[i]; // detect structured elements
              })
              if(key.ref.length>newref.length) { // anything flattened?
                key.ref = newref;
              }
            }
          }
          let foreignKeyElement = createForeignKeyElement(member, memberName, key, parent, defName, rootPath.concat(subpath).concat('keys', keyIndex));
          toFinalBaseType(foreignKeyElement);
          // Propagate the association's annotations to the foreign key element
          // (Overwriting because they should win over the derived type unraveling)
          copyAnnotations(member, foreignKeyElement, true);
        }
        // If the managed association is NOT NULL, we give it a target min cardinality of 1
        // if it didn't already have an explicitly specified min cardinality.
        // (No need to check again for min <= max cardinality, because max has already been checked to be > 0)
        if (member.notNull) {
          if (!member.cardinality) {
            member.cardinality = {};
          }
          if (member.cardinality.min === undefined) {
            member.cardinality.min = 1;
          }
        }
      }

      // (3.2) Flatten/normalize on-conditions in unmanaged associations
      if (member.type && isAssocOrComposition(member.type) && member.on) {
        if (!structuredOData) // flat-mode
          flattenOnCond(member, memberName, def.elements, defName, rootPath.concat(subpath));
        else // structured-mode
          normalizeOnCondForStructuredMode(member)
      }
    });
  }

  // The function performs normalization for on-conditions in 'structured'-mode (for odata) as follows:
  // 1. removes leading $self in references
  function normalizeOnCondForStructuredMode(assoc) {
    if (!assoc.on) return; // nothing to do
    forEachRef(assoc, (ref, node) => {
      // remove leading $self when at the begining of a ref
      if (ref.length > 1 && ref[0] === '$self')
        node.ref.splice(0, 1);
    });
  }

  // (4.1) Generate all that is required in ODATA for draft enablement of 'artifact' into the artifact,
  // into its transitively reachable composition targets, and into the model.
  // 'rootArtifact' is the root artifact where composition traversal started.

  // Constraints
  // Draft Root: Exactly one PK of type UUID
  // Draft Node: One PK of type UUID + 0..1 PK of another type
  // Draft Node: Must not be reachable from multiple draft roots
  function generateDraftForOdata(artifact, artifactName, rootArtifact, visitedArtifacts) {
    // Sanity check
    if (!isArtifactInSomeService(artifactName, services)) {
      throw new Error('Expecting artifact to be part of a service: ' + JSON.stringify(artifact));
    }
    // Nothing to do if already draft-enabled (composition traversal may have circles)
    if ((artifact['@Common.DraftRoot.PreparationAction'] || artifact['@Common.DraftNode.PreparationAction'])
      && artifact.actions && artifact.actions.draftPrepare) {
      return;
    }

    // extract EDM exposed keys for UUID inspection
    let keys = [];
    forEachGeneric(artifact, 'elements', (elt) => {
      if (elt.key && elt.key === true && isEdmPropertyRendered(elt, options))
        keys.push(elt);
    });

    // A draft enabled entity should *expose* exactly one primary key of type cds.UUID in the EDM document
    if (keys.length !== 1) {
      signal(warning`"${artifactName}": "@odata.draft.enabled" - Entity should expose exactly one key element`, ['definitions', artifactName]);
    }

    let uuidCount = keys.reduce((uuidCount, k) => {
      return k.type === 'cds.UUID' ? ++uuidCount : uuidCount;
    }, 0);
    if (uuidCount === 0) {
      signal(warning`"${artifactName}": "@odata.draft.enabled" - Entity key element should be of type "cds.UUID"`, ['definitions', artifactName]);
    }

    // Generate the DraftAdministrativeData projection into the service, unless there is already one
    let draftAdminDataProjectionName = `${getServiceOfArtifact(artifactName, services)}.DraftAdministrativeData`;
    let draftAdminDataProjection = csn.definitions[draftAdminDataProjectionName];
    if (!draftAdminDataProjection) {
      draftAdminDataProjection = createAndAddDraftAdminDataProjection(getServiceOfArtifact(artifactName, services));
    }
    // Report an error if it is not an entity or not what we expect
    if (draftAdminDataProjection.kind !== 'entity' || !draftAdminDataProjection.elements['DraftUUID']) {
      signal(error`Generated entity "${draftAdminDataProjectionName}" conflicts with existing artifact`, ['definitions', draftAdminDataProjectionName]);
    }
    // Generate the annotations describing the draft actions (only draft roots can be activated/edited)
    if (artifact == rootArtifact) {
      artifact['@Common.DraftRoot.ActivationAction'] = 'draftActivate';
      artifact['@Common.DraftRoot.EditAction'] = 'draftEdit';
      artifact['@Common.DraftRoot.PreparationAction'] = 'draftPrepare';
    } else {
      artifact['@Common.DraftNode.PreparationAction'] = 'draftPrepare';
    }

    for (let elemName in artifact.elements) {
      let elem = artifact.elements[elemName];
      // Make all non-key elements nullable
      if (elem.notNull && elem.key !== true) {
        delete elem.notNull;
      }
    }
    // Generate the additional elements into the draft-enabled artifact

    // key IsActiveEntity : Boolean default true
    let isActiveEntity = createScalarElement('IsActiveEntity', 'cds.Boolean', true, true, false);
    isActiveEntity.IsActiveEntity['@UI.Hidden'] = true;
    addElement(isActiveEntity, artifact, artifactName);

    // HasActiveEntity : Boolean default false
    let hasActiveEntity = createScalarElement('HasActiveEntity', 'cds.Boolean', false, false, true);
    hasActiveEntity.HasActiveEntity['@UI.Hidden'] = true;
    addElement(hasActiveEntity, artifact, artifactName);

    // HasDraftEntity : Boolean default false;
    let hasDraftEntity = createScalarElement('HasDraftEntity', 'cds.Boolean', false, false, true);
    hasDraftEntity.HasDraftEntity['@UI.Hidden'] = true;
    addElement(hasDraftEntity, artifact, artifactName);

    // @odata.contained: true
    // DraftAdministrativeData : Association to one DraftAdministrativeData;
    let draftAdministrativeData = createAssociationElement('DraftAdministrativeData', draftAdminDataProjectionName, true);
    draftAdministrativeData.DraftAdministrativeData.cardinality = { max: 1, };
    draftAdministrativeData.DraftAdministrativeData['@odata.contained'] = true;
    draftAdministrativeData.DraftAdministrativeData['@UI.Hidden'] = true;
    addElement(draftAdministrativeData, artifact, artifactName);

    // Note that we need to do the ODATA transformation steps for managed associations
    // (foreign key field generation, generatedFieldName) by hand, because the corresponding
    // transformation steps have already been done on all artifacts when we come here)
    let uuidDraftKey = draftAdministrativeData.DraftAdministrativeData.keys.filter(key => key.ref && key.ref.length === 1 && key.ref[0] === 'DraftUUID');
    if (uuidDraftKey && uuidDraftKey[0]) {
      uuidDraftKey = uuidDraftKey[0]; // filter returns an array, but it has only one element
      let path = ['definitions', artifactName, 'elements', 'DraftAdministrativeData', 'keys', 0];
      createForeignKeyElement(draftAdministrativeData.DraftAdministrativeData, 'DraftAdministrativeData', uuidDraftKey, artifact, artifactName, path);
    }
    // SiblingEntity : Association to one <artifact> on (... IsActiveEntity unequal, all other key fields equal ...)
    let siblingEntity = createAssociationElement('SiblingEntity', artifactName, false);
    siblingEntity.SiblingEntity.cardinality = { max: 1 };
    addElement(siblingEntity, artifact, artifactName);
    // ... on SiblingEntity.IsActiveEntity != IsActiveEntity ...
    siblingEntity.SiblingEntity.on = createAssociationPathComparison('SiblingEntity', 'IsActiveEntity', '!=', 'IsActiveEntity');

    // Iterate elements
    for (let elemName in artifact.elements) {
      let elem = artifact.elements[elemName];
      if (elemName !== 'IsActiveEntity' && elem.key) {
        // Amend the ON-condition above:
        // ... and SiblingEntity.<keyfield> = <keyfield> ... (for all key fields except 'IsActiveEntity')
        let cond = createAssociationPathComparison('SiblingEntity', elemName, '=', elemName);
        cond.push('and');
        cond.push(...siblingEntity.SiblingEntity.on);
        siblingEntity.SiblingEntity.on = cond;
      }

      // Draft-enable the targets of composition elements (draft nodes), too
      // TODO rewrite
      if (elem.target && elem.type && getFinalType(elem.type) === 'cds.Composition') {
        let draftNode = csn.definitions[elem.target];

        // Ignore if that is our own draft root
        if (draftNode != rootArtifact) {
          // Barf if the draft node has @odata.draft.enabled itself
          if (hasBoolAnnotation(draftNode, '@odata.draft.enabled', true)) {
            signal(error`"${artifactName}.${elemName}": Composition in draft-enabled entity cannot lead to another entity with "@odata.draft.enabled"`, ['definitions', artifactName, 'elements', elemName]);
          }
          // Ignore composition if not part of a service
          else if (!getServiceName(elem.target)) {
            signal(warning`Target "${elem.target}" of composition "${artifactName}.${elemName}" cannot be a draft node because it is not part of a service`, ['definitions', artifactName, 'elements', elemName]);
            continue;
          }
          else if (hasBoolAnnotation(draftNode, '@odata.draft.enabled', false)) {
            continue;
          }
          else {
            // Generate draft stuff into the target
            generateDraftForOdata(draftNode, elem.target, rootArtifact, visitedArtifacts);
          }
        }
      }
    }

    // Generate the actions into the draft-enabled artifact (only draft roots can be activated/edited)

    // action draftPrepare (SideEffectsQualifier: String) return <artifact>;
    let draftPrepare = createAction('draftPrepare', artifactName, 'SideEffectsQualifier', 'cds.String');
    addAction(draftPrepare, artifact, artifactName);

    if (artifact == rootArtifact) {
      // action draftActivate() return <artifact>;
      let draftActivate = createAction('draftActivate', artifactName);
      addAction(draftActivate, artifact, artifactName);

      // action draftEdit (PreserveChanges: Boolean) return <artifact>;
      let draftEdit = createAction('draftEdit', artifactName, 'PreserveChanges', 'cds.Boolean');
      addAction(draftEdit, artifact, artifactName);
    }
  }

  // CDXCORE-481
  // (4.5) If the member is an association whose target has @cds.odata.valuelist annotate it
  // with @Common.ValueList.viaAssociation.
  // This must be done before foreign keys are calculated and the annotations are propagated
  // to them. This will make sure that association and all its foreing keys are annotated with
  // Common.ValueList in the final EDM.
  // Do this only if the association is navigable and the enclosing artifact is
  // a service member (don't pollute the CSN with unnecessary annotations).
  // TODO: test???
  function addCommonValueListviaAssociation(member, memberName) {
    let vlAnno = '@Common.ValueList.viaAssociation';
    if (isAssociation(member.type)) {
      let navigable = member['@odata.navigable'] !== false; // navigable disabled only if explicitly set to false
      let targetDef = getCsnDef(member.target);
      if (navigable && targetDef['@cds.odata.valuelist'] && !member[vlAnno]) {
        member[vlAnno] = { '=': memberName };
      }
    }
  }

} // transform4odataWithCsn

// Return an array of non-abstract service names contained in compacted 'model'
function getServiceNames(model) {
  let result = [];
  forEachDefinition(model, (artifact, artifactName) => {
    if (artifact.kind === 'service' && !artifact.abstract) {
      result.push(artifactName);
    }
  });
  return result;
}

// some model utilities => TODO: move them to separate file
function isArtifactInSomeService(artName, services) {
  return services.some(serviceName => artName.startsWith(`${serviceName}.`));
}

function isLocalizedArtifactInService(artName, services) {
  if (!artName.startsWith('localized.')) return false;
  return isArtifactInSomeService(artName.split('.').slice(1).join('.'), services);
}

function getServiceOfArtifact(artName, services) {
  return services.find(serviceName => artName.startsWith(`${serviceName}.`));
}


// Check if an artifact with name 'artName' is part of a 'service'
function isArtifactInService(artName, service) {
  return artName.startsWith(`${service}.`);
}

function defNameWithoutServiceName(name, service) {
  return name.replace(`${service}.`, '');
}
