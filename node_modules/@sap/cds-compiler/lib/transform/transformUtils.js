'use strict';

// A "tools" collection of various transformation functions that might be helpful for
// different backends.

const { setProp, cloneWithTransformations }  = require('../base/model');
const { addBoolAnnotationTo, addStringAnnotationTo, printableName,
        copyAnnotations, isStructuredElement, hasBoolAnnotation } = require('../model/modelUtils');
const alerts = require('../base/alerts');

// Return the public functions of this module, with 'model' captured in a closure (for options etc).
// Use 'pathDelimiter' for flattened names (e.g. of struct elements or foreign key elements).
function getTransformers(model, pathDelimiter) {
  const { error, warning, signal } = alerts(model);
  let options = model.options;

  return {
    addDefaultTypeFacets,
    flattenForeignKeys,
    createForeignKeyElement,
    checkForeignKeys,
    checkMultipleAssignments,
    extractValidFromToKeyElement,
    checkAssignment,
    flattenStructuredElement,
    flattenStructStepsInPath,
    checkExposedAssoc,
    toFinalBaseType,
    isAssociationOperand,
    isDollarSelfOperand,
    createExposingProjection,
    createAndAddDraftAdminDataProjection,
    createScalarElement,
    createAssociationElement,
    createAssociationPathComparison,
    createForeignKey,
    addForeignKey,
    addElement,
    copyAndAddElement,
    createAction,
    addAction,
  };

  // Try to apply length, precision, scale from options if no type facet is set on the primitive types 'cds.String' or 'cds.Decimal'.
  // If 'obj' has primitive type 'cds.String' and no length (and it was not previously a UUID), add default length 5000 if no option is available.
  // if 'obj' has primitive type 'cds.Decimal' and no precision or scale try to apply precision, scale from options if available.
  function addDefaultTypeFacets(element) {
    if (element && element.type && element.type._artifact && !element.type._artifact.name.$renamed) {
      if(element.type._artifact.name.absolute === 'cds.String' && element.length === undefined) {
        element.length = { literal: 'number', val: (model.options && model.options.length ? model.options.length : 5000) }
      }
    }
  }

  // For a dictionary `foreignKeys` of foreign key infos, return a dictionary in flattened form, i.e.
  // replace all foreign keys that are managed associations themselves by their respective foreign keys,
  // recursively, with names flattened using '_' between path components.
  function flattenForeignKeys(foreignKeys) {
    let fkSeparator = pathDelimiter;

    let result = Object.create(null);
    for (let name in foreignKeys) {
      let foreignKey = foreignKeys[name];
      // Sanity checks
      if (!foreignKey.targetElement) {
        throw Error('Expecting foreign key ' + printableName(foreignKey) + ' to have targetElement');
      }
      if (!foreignKey.name.absolute || !foreignKey.name.element) {
        throw Error('Expecting foreign key ' + printableName(foreignKey) + ' to have absolute name and element name');
      }
      let fkArtifact = foreignKey.targetElement._artifact;
      if (!fkArtifact) {
        throw Error('Expecting foreign key ' + printableName(foreignKey) + ' to be resolved');
      }
      if (fkArtifact.target) {
        // Foreign key is itself a managed association: Replace by its target foreign keys
        // (In other words, use the target's generated foreign key fields as foreign keys)
        let targetForeignKeys = flattenForeignKeys(fkArtifact.foreignKeys);
        for (let targetForeignKeyName in targetForeignKeys) {
          let targetForeignKey = targetForeignKeys[targetForeignKeyName];
          let targetGeneratedForeignKeyFieldName = name + fkSeparator + targetForeignKeyName;
          let resultForeignKey = {
            name: {
              id: targetGeneratedForeignKeyFieldName,
              absolute: foreignKey.name.absolute,
              element: name + '.' + targetGeneratedForeignKeyFieldName,
              $inferred: 'flatten',
              $viaTransform: true
            },
            kind: 'key',
            targetElement: { path: [ { id: targetGeneratedForeignKeyFieldName } ] },
          };
          setProp(resultForeignKey, '_parent', foreignKey._parent);
          setProp(resultForeignKey, '_main', foreignKey._main);
          // FIXME: _artifact should actually point to the generated target foreign key element here (and not
          // (to the corresponding target foreign key itself), but because we generate foreign key elements
          // iteratively, not recursively, we cannot rely on generated foreign key elements in other entities
          // to exist yet. But doing it like this will be quite sufficient as a workaround, because target
          // foreign key and generated target foreign key element have all properties that we might inspect
          // on _artifact in common (type, annotations, ... we only ever inspect them in order to copy them,
          // after all)
          setProp(resultForeignKey.targetElement, '_artifact', targetForeignKey.targetElement._artifact);
          result[name + fkSeparator + targetForeignKeyName] = resultForeignKey;
        }
      } else if (isStructuredElement(fkArtifact)) {
        // Foreign key is structured: Replace by its flattened elements (which unfortunately might not exist yet,
        // because we do the flattening iteratively and the artifact containing the structured key might not have been
        // processed yet. As above, we use the actual key elements as a standin for _artifact)
        let flatKeyElements = flattenStructuredElement(fkArtifact);
        for (let flatElemName in flatKeyElements) {
          let flatElem = flatKeyElements[flatElemName];
          let resultForeignKey = {
            name: {
              id: flatElemName,
              absolute: foreignKey.name.absolute,
              element: flatElemName,
              $viaTransform: true
            },
            kind: 'key',
            targetElement: { path: [ { id: flatElemName } ] },
          };
          setProp(resultForeignKey, '_parent', foreignKey._parent);
          setProp(resultForeignKey, '_main', foreignKey._main);
          setProp(resultForeignKey.targetElement, '_artifact', flatElem);
          result[flatElemName] = resultForeignKey;
        }
      } else {
        // Otherwise simply take as it is
        result[name] = foreignKey;
      }
    }
    return result;
  }

  // Create an artificial foreign key element for association 'assoc' (possibly part
  // of nested struct, i.e. containing dots) in 'artifact', using foreign key info
  // from 'foreignKey', inserting it into 'elements' of 'artifact'. Add a property
  // 'generatedFieldName' to the corresponding 'foreignKey' of the assoc.
  // Note that this must happen after struct flattening (because it assumes that the
  // element names it encounters are relative to 'artifact').
  // Return the newly generated foreign key element.
  function createForeignKeyElement(assoc, foreignKey, artifact) {
    let fkArtifact = foreignKey.targetElement._artifact;
    // Sanity checks
    if (!fkArtifact) {
      throw Error('Expecting foreign key for ' + printableName(assoc) + ' to be resolved');
    }
    if (!assoc.name.absolute || !assoc.name.element) {
      throw Error('Expecting association ' + printableName(assoc) + ' to have absolute name and element name');
    }
    if (fkArtifact.target) {
      throw Error('Not expecting foreign key of association ' + printableName(assoc) + ' to be an association after flattening')
    }
    if (fkArtifact.type == undefined) {
      throw Error('Expecting artifact of foreign key for ' + printableName(assoc) + ' to have a type');
    }

    let fkSeparator = pathDelimiter;

    // Assemble foreign key element name from assoc name, '_' and foreign key name/alias
    let foreignKeyElementName = assoc.name.element.replace(/\./g, pathDelimiter) + fkSeparator + foreignKey.name.id;
    // Assemble artificial foreign key element
    let fkType = fkArtifact.type._artifact;
    let foreignKeyElement = {
      name:  {
        id: foreignKeyElementName,
        absolute: assoc.name.absolute,
        element: foreignKeyElementName,
        $inferred: 'flatten',
        $viaTransform: true
      },
      kind: 'element',
      type: {
        path: [ { id: fkType.name.$renamed || fkType.name.absolute } ],
      },
    };
    // Transfer selected type properties from target key element
    // FIXME: There is currently no other way but to treat the annotation '@odata.Type' as a type property.
    for (let prop of ['length', 'scale', 'precision', 'srid', 'default', '@odata.Type']) {
      if (fkArtifact[prop]) {
        foreignKeyElement[prop] = fkArtifact[prop];
      }
    }
    setProp(foreignKeyElement.type, '_artifact', fkType);
    setProp(foreignKeyElement.type.path[0], '_artifact', fkType);
    // If the association is non-fkArtifact resp. key, so should be the foreign key field
    for (let prop of ['notNull', 'key']) {
      if (assoc[prop]) {
        foreignKeyElement[prop] = Object.assign({}, assoc[prop]);
      }
    }

    // If the association was a projection or view element (i.e. it has a 'value'), construct a
    // corresponding 'value' for the generated foreign key element
    // FIXME: Can't resolve the corresponding _artifact links because they might not yet be created.
    // We currently live without them.
    if (assoc.value) {
      // TODO: previously, the code directly accessed assoc.value.element, probably set by forHana
      let elemName = assoc.value.element || (assoc.value._artifact ? assoc.value._artifact.name.element : '');
      let valueForeignKeyElementName = elemName.replace(/\./g, pathDelimiter) + fkSeparator + foreignKey.name.id;
      // For the foreign key element, take the same path as for the assoc, just without the last step
      let valueForeignKeyElementPath = [];
      if (assoc.value.path) {
        valueForeignKeyElementPath = cloneWithTransformations(assoc.value.path, {}, true).slice(0, -1);
      }
      valueForeignKeyElementPath.push({ id: valueForeignKeyElementName });
      foreignKeyElement.value = {
        path: valueForeignKeyElementPath,
        // TODO: keep the following, needed by toSql ?
        absolute: assoc.value.absolute || assoc.value._artifact && assoc.value._artifact.name.absolute,
        element: valueForeignKeyElementName,
        $viaTransform: true, // FIXME: Do we still need this?
      }
      // FIXME: Remove once the compactor no longer renders 'origin'
      if (assoc.origin) {
        foreignKeyElement.origin = foreignKeyElement.value;
      }
      // The foreign key element name is calculated if the assoc hasn't been renamed
      if (assoc.name.element == assoc.value.element) {
        foreignKeyElement.name.calculated = true;
      }
    }

    // Insert artificial element into artifact, with all cross-links (must not exist already)
    if (artifact.elements[foreignKeyElementName]) {
      signal(error`Generated foreign key element "${foreignKeyElementName}" for association "${assoc.name.absolute}.${assoc.name.element}" conflicts with existing element`, assoc.location);
    }
    artifact.elements[foreignKeyElementName] = foreignKeyElement;
    setProp(foreignKeyElement, '_parent', artifact);
    setProp(foreignKeyElement, '_main', artifact);
    setProp(foreignKeyElement, '_finalType', fkArtifact._finalType);

    // Establish the relationship between generated field and association:
    // - foreign key info has 'generatedFieldName'
    // - generated field has annotation '@odata.foreignKey4'.
    foreignKey.generatedFieldName = foreignKeyElementName;
    addStringAnnotationTo('@odata.foreignKey4', assoc.name.element, foreignKeyElement);
    return foreignKeyElement;
  }

  // For an association 'assoc', check that all foreign keys (if any) actually exist in the
  // target. Must only be applied after flattening structured foreign keys.
  // Note that this may also be called for unmanaged associations with artificially created
  // ON-conditions, because these still retain their foreign key info.
  // FIXME: For all cases except implicit redirection, this should actually be done by the compiler
  function checkForeignKeys(assoc) {
    // FIXME: Because this assumes flattening, it does not work with 'hdbcds' naming mode. Because
    // it will become obsolete soon anyway (compiler checking and rewriting ON-conditions), we
    // don't bother to adapt it.
    if (options.forHana && options.forHana.keepStructsAssocs) {
      return;
    }

    for (let name in assoc.foreignKeys) {
      let foreignKey = assoc.foreignKeys[name]
      // Sanity checks
      if (foreignKey.targetElement.path.length > 1) {
        throw Error('Expecting foreign key ' + + printableName(foreignKey) + ' to be flattened');
      }
      if (!assoc.target._artifact) {
        throw Error('Expecting target of association ' + printableName(assoc) + ' to be resolved');
      }
      if (!assoc.target._artifact.elements) {
        throw Error('Expecting target of association ' + printableName(assoc) + ' to have elements');
      }
      // Try to "resolve" the corresponding element
      let targetElement = assoc.target._artifact.elements[foreignKey.targetElement.path[0].id];
      if (targetElement == undefined) {
        if (assoc.redirected) {
          signal(error`Foreign key "${foreignKey.targetElement.path[0].id}" not found in redirected target "${assoc.target._artifact.name.absolute}" of association "${assoc.name.absolute}.${assoc.name.element}"`, assoc.location);
        } else {
          signal(error`Foreign key "${foreignKey.targetElement.path[0].id}" not found in target "${assoc.target._artifact.name.absolute}" of association "${assoc.name.absolute}.${assoc.name.element}"`, assoc.location);
        }
      }
    }
  }

  // For a structured element 'elem', return a dictionary of flattened elements to
  // replace it, flattening names with '_' and propagating all annotations and the
  // type properties 'key', 'notNull', 'virtual', 'masked' to the flattened elements.
  function flattenStructuredElement(elem, ipath=[]) {
    let path=ipath.concat(elem.name.id)
    // Sanity check
    if (!isStructuredElement(elem)) {
      throw new Error('Expecting element ' + printableName(elem) + ' to be a structured element');
    }
    // Collect all child elements (recursively) into 'result'
    let result = Object.create(null);
    for (let childName in elem._finalType.elements) {
      let childElem = elem._finalType.elements[childName];
      if (isStructuredElement(childElem)) {
        // Descend recursively into structured children
        let grandChildElems = flattenStructuredElement(childElem, path);
        for (let grandChildName in grandChildElems) {
          let flatElemName = elem.name.id + pathDelimiter + grandChildName;
          let flatElem = grandChildElems[grandChildName];
          result[flatElemName] = flatElem;
          // If the original element had a value, construct one for the flattened element
          if (elem.value) {
            createFlattenedValue(flatElem, flatElemName, grandChildName);
          }
          // Preserve the generated element name as it would have been with 'hdbcds' names
          result[flatElemName] = flatElem;
        }
      } else {
        // Primitive child - clone it and restore its cross references
        let flatElemName = elem.name.id + pathDelimiter + childName;
        let flatElem = cloneWithTransformations(childElem, {}, true);
        flatElem.name.element = flatElemName;
        flatElem.name.$inferred = 'flatten';
        flatElem.$viaTransform = true; // FIXME: This name is not ideal but used elsewhere, too)
        setProp(flatElem, '_finalType', childElem._finalType);
        setProp(flatElem, '_main', elem._main);
        setProp(flatElem, '_parent', elem._parent);
        // If the original element had a value, construct one for the flattened element
        if (elem.value) {
          createFlattenedValue(flatElem, flatElemName, childName);
        }
        // Preserve the generated element name as it would have been with 'hdbcds' names
        setProp(flatElem, '_flatElementNameWithDots', path.concat(childName).join('.'));
        result[flatElemName] = flatElem;
      }
    }
    // Fix all collected flat elements (names, annotations, properties, origin ..)
    for (let name in result) {
      // Adapt names within the element
      let flatElem = result[name];
      flatElem.name.id = name;
      flatElem.name.element = name;
      if (elem.name.calculated) {
        flatElem.name.calculated = true;
      }
      // Copy annotations from struct (not overwriting, because deep annotations should have precedence)
      copyAnnotations(elem, flatElem, false);
      // Copy selected type properties
      for (let p of ['key', 'notNull', 'virtual', 'masked', 'viaAll']) {
        if (elem[p]) {
          flatElem[p] = elem[p];
        }
      }
    }
    return result;

    // Create a flattened 'value' for flattened element 'flatElem' with full name 'flatElemName',
    // appending 'lastPathStep' to the original elem's value path
    function createFlattenedValue(flatElem, flatElemName, lastPathStep) {
      flatElem.value = {
        // TODO: keep absolute/element, needed by toSql ?
        absolute : elem.value.absolute,
        element : flatElemName,
        $viaTransform: true,
      }
      // Just extend 'elem's path by one step, leaving all IDs as they are (will be fixed later by flattenStructStepsInPath)
      if (elem.value.path) {
        flatElem.value.path = cloneWithTransformations(elem.value.path, {}, true);
      }
      flatElem.value.path.push({ id : lastPathStep });
      // FIXME: Cannot restore value._artifact here because it might not exist yet (projection
      // might be processed before entity). We currently live without it.
      // FIXME: Remove once the compactor no longer renders 'origin'
      flatElem.origin = flatElem.value;
    }
  }

  // Return a copy of 'path' where all path steps resulting from struct traversal are
  // fused together into one step, using '_' (so that the path fits again for flattened
  // structs), e.g.
  //   [ (Entity), (struct1), (struct2), (assoc), (elem) ] should result in
  //   [ (Entity), (struct1_struct2_assoc), (elem) ]
  // FIXME: The resulting path steps have slightly crooked _artifact (for each artificially
  // created flattened element, the path step's _artifact points to the original
  // (primitive) struct member it was generated for.
  function flattenStructStepsInPath(path) {
    let result = [];
    let stack = []; // IDs of path steps not yet processed or part of a struct traversal
    for (let pathStep of path) {
      stack.push(pathStep.id);
      // Current stack makes a new result step if next path step is not a struct traversal
      if (!pathStep._artifact || !isStructuredElement(pathStep._artifact)) {
        let resultStep = Object.assign({}, pathStep, { id : stack.join(pathDelimiter) });
        if (pathStep._artifact) {
          setProp(resultStep, '_artifact', pathStep._artifact);
        }
        result.push(resultStep);
        stack = [];
      }
    }
    // Process remaining stack if not empty
    if (stack.length > 0) {
      let pathStep = path[path.length - 1];
      let resultStep = Object.assign({}, pathStep, { id : stack.join(pathDelimiter) });
      if (pathStep._artifact) {
        setProp(resultStep, '_artifact', pathStep._artifact);
      }
      result.push(resultStep);
    }
    // The path might start with an element that is part of a struct (i.e. enclosing the path owner).
    // This hasn't been handled above simply because the struct is not part of the path.
    // FIXME: Find a simpler solution for this ... really ugly
    if (path[0]._artifact && path[0]._artifact.name.element && path[0]._artifact.name.element.indexOf('.') != -1) {
      result[0].id = path[0]._artifact.name.element.replace(/\./g, pathDelimiter);
    }
    // If the path starts with '$self', this is now redundant (because of flattening) and can be omitted,
    // making life easier for consumers
    if (result[0].id === '$self' && result.length > 1) {
      result = result.slice(1);
    }
    return result;
  }

  // Check that exposed associations do not point to non-exposed targets
  function checkExposedAssoc(artifact, association) {
    if (!association._ignore && association.target && association.target._artifact && association.target._artifact._service != artifact._service) {
      // If we have a 'preserved dotted name' ->  a result of flattening -> This scenario is not supported yet
      if (association._flatElementNameWithDots)
        signal(error`Redirection for sub elements not supported yet - association "${artifact.name.absolute}.${association.name.id}"`, association.location);
    }
  }

  // Replace the type of 'node' with its final base type (in contrast to the compiler,
  // also unravel derived enum types, i.e. take the final base type of the enum's base type.
  // Similar with associations and compositions (we probably need a _baseType link)
  function toFinalBaseType(node) {
    // Nothing to do if no type (or if array/struct type)
    if (!node || !node.type || node.type._artifact && node.type._artifact.builtin) {
      return;
    }
    // Sanity check
    if (!node._finalType) {
      throw Error(`Expecting _finalType for ${node.name.absolute}`);
    }
    // Take the final type as provided by the compiler
    let baseType = node._finalType.type || node.type;
    // If that is an enum, unravel the base type of that, too (unlike what the compiler does)
    if (node._finalType.enum) {
      node.enum = node._finalType.enum;
      baseType = node.type._artifact._finalType.type || node.type._artifact.type;
    }
    // If that is an e
    while (baseType._artifact.target)
      baseType = baseType._artifact.type;
    node.type = {
      path: [ { id: baseType._artifact.name.absolute } ],
      absolute: baseType._artifact.name.absolute,
      location: node.type.location,
      $viaTransform: true,
    };
    // Make sure all propagated type properties are taken as non-inferred
    for (let prop of ['length', 'precision', 'scale', 'srid', 'enum', 'target', 'foreignKeys']) {
      if (node[prop] != undefined && node[prop].$inferred === 'prop') {
        delete node[prop].$inferred;
      }
    }
    setProp(node.type, '_artifact', baseType._artifact);
    setProp(node.type.path[0], '_artifact', baseType._artifact);
  }

  // Return a full projection 'projectionId' of artifact 'art' for exposure in 'service', where the name of the projection
  // is the fully qualified name of 'art', replacing '.' and '::' by '_' resp. '__'.
  // Complain on location 'loc' mentioning 'reason' if such an artifact (other than the autogenerated one) already exists
  function createExposingProjection(art, projectionId, service, loc, reason) {
    let projectionAbsoluteName = service.name.absolute + '.' + projectionId
    // If there already is an artifact with this name, this is either the second attempt or a conflict
    let existingProjection = service.artifacts[projectionId];
    if (existingProjection) {
      if (existingProjection.$generatedByAutoExposure) {
        // Already auto-exposed
        return existingProjection;
      }
      signal(error`Cannot generate projection "${projectionId}" for ${reason} because of name conflict with existing artifact "${service.name.absolute}.$projectionId}"`, loc);
      return null;
    }
    // Create elements matching the artifact's elements
    let elements = Object.create(null);
    for (let elemName in art.elements) {
      let artElem = art.elements[elemName];
      let elem = Object.assign({}, artElem);
      elem.name = Object.assign({}, artElem.name, { calculated: true });
      elem.name.absolute = projectionAbsoluteName;
      elem.value = {
        id : elemName,
        // absolute: projectionAbsoluteName,
        // element: elemName,
        path: [ { id : art.name.id }, { id : elemName } ]
      }
      setProp(elem.value, '_artifact', artElem);
      // Transfer the original element's final type, unless it was the original element itself (then it becomes the new element itself)
      if (artElem._finalType) {
        setProp(elem, '_finalType', (artElem._finalType == artElem) ? elem : artElem._finalType);
      }
      // Transfer xrefs, that are redirected to the projection
      // TODO: shall we remove the transfered elements from the original?
      if (artElem._xref) {
        setProp(elem, '_xref', artElem._xref.filter(xref => xref.user && xref.user._main && xref.user._main._service == service));
      }
      // FIXME: Remove once the compactor no longer renders 'origin'
      elem.origin = elem.value;
      elem.viaAll = true;
      elements[elemName] = elem;
    }
    // Source is the original artifact
    let source = {
      path: [ { id: art.name.absolute } ],
      name: {
        calculated: true,
        id : art.name.id,
      },
    };
    setProp(source, '_artifact', art);
    // Add an artifact link for the last path step (for some reason, the original path does not seem to have it)
    if (source.path && !source.path[source.path.length - 1]._artifact) {
      setProp(source.path[source.path.length - 1], '_artifact', art);
    }
    let query = {
      op: { val: 'query', location: loc },
      from: [ source ],
      all: { val: true },
      elements,
      kind: 'query',
    };
    // Assemble the projection itself and add it into the model
    let projection = {
      name: {
        id: projectionId,
        absolute: projectionAbsoluteName
      },
      kind: 'entity',
      query: query,
      projection: {},
      $from: [ source ],
      queries: [ query ],
      $queries: [ query ],
      // source: source,
      elements: query.elements,
      $generatedByAutoExposure: true,
    };
    // copy annotations from art to projection
    for (let a of Object.keys(art).filter(x => x.startsWith('@'))) {
      projection[a] = art[a];
    }
    setProp(projection, '_service', service);
    // Sanity check: Can't already be there (checked above)
    if (model.definitions[projectionAbsoluteName]) {
      throw new Error('Duplicate projection: ' + projectionAbsoluteName);
    }
    model.definitions[projectionAbsoluteName] = projection;
    service.artifacts[projectionId] = projection;
    return projection;
  }

  // Return true if 'arg' is an expression argument of type association or composition
  function isAssociationOperand(arg) {
    if (!arg.path) {
      // Not a path, hence not an association (literal, expression, function, whatever ...)
      return false;
    }
    // Sanity check
    if (!arg._artifact) {
      // FIXME: With 'hanaFlavor, we see unresolved paths for magic function args like ROUND_HALF_UP - ignore them)
      if (model.options.hanaFlavor) {
        return false;
      }
      throw new Error(`Expected argument to be resolved: ${JSON.stringify(arg, null, 2)}`);
    }
    // If it has a target, it is an association or composition
    return arg._artifact.target || (arg._artifact._finalType && arg._artifact._finalType.target);
  }

  // Return true if 'arg' is an expression argument denoting "$self"
  function isDollarSelfOperand(arg) {
    return arg.path && arg.path.length == 1 && (arg.path[0].id === '$self' || arg.path[0].id === '$projection');
  }

  // Create a 'DraftAdministrativeData' projection on 'DRAFT.DraftAdministrativeData' in service 'service'
  // and add it to the model.
  function createAndAddDraftAdminDataProjection(service) {
    // Make sure we have a DRAFT.DraftAdministrativeData entity
    let draftAdminDataEntity = model.definitions['DRAFT.DraftAdministrativeData'];
    if (!draftAdminDataEntity) {
      draftAdminDataEntity = createAndAddDraftAdminDataEntity();
      model.definitions['DRAFT.DraftAdministrativeData'] = draftAdminDataEntity;
    }
    // Barf if it is not an entity or not what we expect
    if (draftAdminDataEntity.kind !== 'entity' || !draftAdminDataEntity.elements['DraftUUID']) {
      signal(error`Generated entity "DRAFT.DraftAdministrativeData" conflicts with existing artifact`, draftAdminDataEntity.location);
    }

    // Create a projection within this service
    return createExposingProjection(draftAdminDataEntity, 'DraftAdministrativeData', service, service.location, '"@odata.draft.enabled"');

    // Create the namespace 'DRAFT' and the 'DRAFT.DraftAdministrativeData' entity (unless they already exist)
    // and add them to the model.
    // Return the 'DRAFT.DraftAdministrativeData' entity.
    function createAndAddDraftAdminDataEntity() {
      // Make sure we have a DRAFT namespace
      let draftNamespace = model.definitions['DRAFT'];
      if (!draftNamespace) {
        draftNamespace = createAndAddDraftNamespace();
      }
      // Barf if it is not a namespace
      if (draftNamespace.kind !== 'namespace') {
        signal(error`Generated namespace "DRAFT" conflicts with existing artifact`, draftNamespace.location);
      }

      // Create the 'DRAFT.DraftAdministrativeData' entity
      let artifact = {
        name: {
          path: [
            { id: 'DRAFT' },
            { id: 'DraftAdministrativeData' },
          ],
          id: 'DraftAdministrativeData',
          absolute: 'DRAFT.DraftAdministrativeData',
        },
        kind: 'entity',
        elements: Object.create(null),
      }
      setProp(artifact.name.path[0], '_artifact', draftNamespace);
      setProp(artifact, '_finalType', artifact);

      // key DraftUUID : UUID
      let draftUuid = createScalarElement('DraftUUID', 'cds.UUID', true, undefined);
      addBoolAnnotationTo('@UI.Hidden', true, draftUuid);
      addStringAnnotationTo('@Common.Label', '{i18n>Draft_DraftUUID}', draftUuid);
      addElement(draftUuid, artifact);

      // CreationDateTime : Timestamp;
      let creationDateTime = createScalarElement('CreationDateTime', 'cds.Timestamp', false, undefined);
      addStringAnnotationTo('@Common.Label', '{i18n>Draft_CreationDateTime}', creationDateTime);
      addElement(creationDateTime, artifact);

      // CreatedByUser : String(256);
      let createdByUser = createScalarElement('CreatedByUser', 'cds.String', false,undefined);
      createdByUser.length = { literal: 'number', val: 256 };
      addStringAnnotationTo('@Common.Label', '{i18n>Draft_CreatedByUser}', createdByUser);
      addElement(createdByUser, artifact);

      // DraftIsCreatedByMe : Boolean;
      let draftIsCreatedByMe = createScalarElement('DraftIsCreatedByMe', 'cds.Boolean', false, undefined);
      addBoolAnnotationTo('@UI.Hidden', true, draftIsCreatedByMe);
      addStringAnnotationTo('@Common.Label', '{i18n>Draft_DraftIsCreatedByMe}', draftIsCreatedByMe);
      addElement(draftIsCreatedByMe, artifact);

      // LastChangeDateTime : Timestamp;
      let lastChangeDateTime = createScalarElement('LastChangeDateTime', 'cds.Timestamp', false, undefined);
      addStringAnnotationTo('@Common.Label', '{i18n>Draft_LastChangeDateTime}', lastChangeDateTime);
      addElement(lastChangeDateTime, artifact);

      // LastChangedByUser : String(256);
      let lastChangedByUser = createScalarElement('LastChangedByUser', 'cds.String', false, undefined);
      lastChangedByUser.length = { literal: 'number', val: 256 };
      addStringAnnotationTo('@Common.Label', '{i18n>Draft_LastChangedByUser}', lastChangedByUser);
      addElement(lastChangedByUser, artifact);

      // InProcessByUser : String(256);
      let inProcessByUser = createScalarElement('InProcessByUser', 'cds.String', false, undefined);
      inProcessByUser.length = { literal: 'number', val: 256 };
      addStringAnnotationTo('@Common.Label', '{i18n>Draft_InProcessByUser}', inProcessByUser);
      addElement(inProcessByUser, artifact);

      // DraftIsProcessedByMe : Boolean;
      let draftIsProcessedByMe = createScalarElement('DraftIsProcessedByMe', 'cds.Boolean', false, undefined);
      addBoolAnnotationTo('@UI.Hidden', true, draftIsProcessedByMe);
      addStringAnnotationTo('@Common.Label', '{i18n>Draft_DraftIsProcessedByMe}', draftIsProcessedByMe);
      addElement(draftIsProcessedByMe, artifact);

      // Add to the namespace
      draftNamespace.artifacts[artifact.name.id] = artifact;
      return artifact;
    }

    // Create the namespace 'DRAFT' and add it to the model.
    function createAndAddDraftNamespace() {
      let draftNamespace = {
        name: {
          path: [
            { id: 'DRAFT' },
          ],
          id: 'DRAFT',
          absolute: 'DRAFT',
        },
        kind: 'namespace',
        artifacts: Object.create(null),
      }
      model.definitions['DRAFT'] = draftNamespace;
      return draftNamespace;
    }
  }

  // Create an artificial scalar element 'elemName' with final type 'typeName'.
  // Make the element a key element if 'isKey' is true.
  // Add a default value 'defaultVal' if supplied
  function createScalarElement(elemName, typeName, isKey, defaultVal, notNull=false) {
    let type = model.definitions[typeName];
    if (!type) {
      throw new Error('Expecting valid type name: ' + typeName);
    }
    let elem = {
      name: {
        id : elemName,
        element: elemName,
      },
      kind: 'element',
      type: {
        path: [
          { id: typeName }
        ],
      },
    };
    setProp(elem.type, '_artifact', type);
    setProp(elem.type.path[0], '_artifact', type);
    setProp(elem, '_finalType', elem);
    if (isKey) {
      elem.key = {
        val: true,
      }
    }
    if (defaultVal !== undefined) {
      elem.default = {
        literal: 'boolean',
        val: defaultVal,
      }
    }
    if(notNull) {
      elem.notNull = { val: true };
    }
    return elem;
  }

  // Create an articial element 'elemName' of type 'cds.Association',
  // having association target 'target'. If 'isManaged' is true, take all keys
  // of 'target' as foreign keys.
  function createAssociationElement(elemName, target, isManaged) {
    let elem = createScalarElement(elemName, 'cds.Association', false, undefined);
    elem.target = {
      path: [
        { id: target.name.absolute }
      ],
    };
    setProp(elem.target, '_artifact', target);
    setProp(elem.target.path[0], '_artifact', target);
    if (isManaged) {
      elem.foreignKeys = Object.create(null);
      for (let keyElemName in target.elements) {
        let keyElem = target.elements[keyElemName];
        if (!keyElem.key) {
          continue;
        }
        let foreignKey = createForeignKey(keyElemName, keyElem);
        addForeignKey(foreignKey, elem);
        elem.implicitForeignKeys = true;
      }
    }
    return elem;
  }

  // Create a comparison operation <assoc>.<foreignElem> <op> <elem>.
  function createAssociationPathComparison(assoc, foreignElem, op, elem) {
    let result = {
      op: {
        val: op,
      },
      args: [
        {
          path: [
            { id: assoc.name.id },
            { id: foreignElem.name.id }
          ],
          absolute: foreignElem.name.absolute,
          element: foreignElem.name.id,
        },
        {
          path: [
            { id: elem.name.id }
          ],
          absolute: elem.name.absolute,
          element: elem.name.id,
        }
      ],
    }
    setProp(result.args[0].path[0], '_artifact', assoc);
    setProp(result.args[0].path[1], '_artifact', foreignElem);
    setProp(result.args[0], '_artifact', foreignElem);
    setProp(result.args[1].path[0], '_artifact', elem);
    setProp(result.args[1], '_artifact', elem);
    return result;
  }

  // Create an artificial foreign key 'keyElemName' for key element 'keyElem'. Note that this
  // only creates a foreign key, not the generated foreign key element.
  function createForeignKey(keyElemName, keyElem) {
    let foreignKey = {
      name: {
        id: keyElemName,
        $inferred: 'keys',
      },
      kind: 'key',
      targetElement: {
        path : [
          { id: keyElemName }
        ],
      },
      calculated: true,
      $inferred: 'keys',
    }
    setProp(foreignKey.targetElement, '_artifact', keyElem);
    setProp(foreignKey, '_finalType', keyElem._finalType);
    return foreignKey;
  }

  // Add foreign key 'foreignKey' to managed association element 'elem'.
  function addForeignKey(foreignKey, elem) {
    // Sanity checks
    if (!elem.target || !elem.foreignKeys) {
      throw new Error('Expecting managed association element with foreign keys');
    }

    // Foreign key must not exist
    if (elem.foreignKeys[foreignKey.name.id]) {
      signal(error`"${elem.name.absolute}.${elem.name.id}": Generated foreign key conflicts with existing foreign key`, elem.foreignKeys[foreignKey.name.id].location);
      return;
    }

    // Add the foreign key
    elem.foreignKeys[foreignKey.name.id] = foreignKey;
    foreignKey.name.absolute = elem.name.absolute;
    foreignKey.name.element = elem.name.element + '.' + foreignKey.name.id;
    setProp(foreignKey, '_main', elem._main);
    setProp(foreignKey, '_parent', elem._parent);
  }

  // Add element 'elem' to 'artifact'
  function addElement(elem, artifact) {
    // Sanity check
    if (!artifact.elements) {
      throw new Error('Expecting artifact with elements: ' + JSON.stringify(artifact));
    }
    // Element must not exist
    if (artifact.elements[elem.name.id]) {
      signal(error`"${artifact.name.absolute}.${elem.name.id}": Generated element name conflicts with existing element`, artifact.elements[elem.name.id].location);
      return;
    }
    // Add the element
    artifact.elements[elem.name.id] = elem;
    elem.name.absolute = artifact.name.absolute;
    setProp(elem, '_main', artifact);
    setProp(elem, '_parent', artifact);
    for (let keyName in elem.foreignKeys || {}) {
      elem.foreignKeys[keyName].name.absolute = artifact.name.absolute;
      setProp(elem.foreignKeys[keyName], '_main', artifact);
    }
  }

  // Make a copy of element 'elem' and add it to 'artifact' under the new name 'elemName'.
  // Return the newly created element
  function copyAndAddElement(elem, artifact, elemName) {
    if (!artifact.elements) {
      throw new Error('Expected structured artifact');
    }
    // Must not already have such an element
    if (artifact.elements[elemName]) {
      signal(error`"${artifact.name.absolute}.${elemName}": Generated element name conflicts with existing element`, artifact.elements[elemName].location);
    }
    let result = {
      name: {
        id : elemName,
        absolute: artifact.name.absolute,
        element: elemName,
      },
      kind: 'element',
    };
    // FIXME: For now, simply shallow-copy all these properties (and annotations)
    for (let prop in elem) {
      if (['type', 'key', 'notNull', 'length', 'precision', 'scale', 'srid', 'localized', 'onCond', 'foreignKeys', 'location', 'cardinality', 'items'].includes(prop)
          || prop.startsWith('@')) {
        result[prop] = elem[prop];
      }
    }
    // Clone this one because it may need modification later (redirection of conditions to draft shadow entity)
    if (elem.target) {
      result.target = cloneWithTransformations(elem.target, {}, true);
    }
    // Recurse into (anonymous) sub-elements
    if (elem.elements) {
      result.elements = Object.create(null);
      for (let elemName in elem.elements) {
        copyAndAddElement(elem.elements[elemName], result, elemName);
      }
    }
    setProp(result, '_parent', artifact);
    setProp(result, '_main', artifact);
    setProp(result, '_finalType', elem._finalType == elem ? result : elem._finalType);
    artifact.elements[elemName] = result;
    return result;
  }

  // Create an artificial action 'actionName' with return type artifact 'returnType' optionally with one parameter 'paramName'
  // of type name 'paramTypeName'
  function createAction(actionName, returnType, paramName = undefined, paramTypeName = undefined) {
    // Assemble the action
    let action = {
      name: {
        id: actionName,
        action: actionName,
      },
      kind: 'action',
      returns: {
        type: {
          path: [
            { id: returnType.name.id }
          ],
          absolute: paramTypeName,
        },
      }
    };
    setProp(action.returns.type.path[0], '_artifact', returnType);
    setProp(action.returns.type, '_artifact', returnType);
    setProp(action.returns, '_outer', action);
    setProp(action.returns, '_finalType', returnType);

    // Add parameter if provided
    if (paramName && paramTypeName) {
      let paramType = model.definitions[paramTypeName];
      if (!paramType) {
        throw new Error('Expecting valid parameter type name: ' + paramTypeName);
      }
      action.params = Object.create(null);
      action.params[paramName] = {
        name: {
          id: paramName,
          param: paramName,
          action: actionName,
        },
        kind: 'param',
        type: {
          path: [
            { id: paramTypeName }
          ],
        },
      }
      setProp(action.params[paramName].type.path[0], '_artifact', paramType);
      setProp(action.params[paramName].type, '_artifact', paramType);
    }

    return action;
  }

  // Add action 'action' to 'artifact'
  function addAction(action, artifact) {
    if (!artifact.actions) {
      artifact.actions = Object.create(null);
    }
    // Element must not exist
    if (artifact.actions[action.name.id]) {
      signal(error`"${artifact.name.absolute}.${action.name.id}": Generated action name conflicts with existing action`, artifact.actions[action.name.id].location);
      return;
    }
    // Add the action
    artifact.actions[action.name.id] = action;
    action.name.absolute = artifact.name.absolute;
    setProp(action, '_main', artifact);
    setProp(action, '_parent', artifact);
    for (let paramName in action.params || {}) {
      action.params[paramName].name.absolute = artifact.name.absolute;
      setProp(action.params[paramName], '_main', artifact);
    }
  }

  /**
   * If the element has annotation @cds.valid.from or @cds.valid.to, return it.
   *
   * @param {any} element Element to check
   * @returns {Array[]} Array of arrays, first filed has an array with the element if it has @cds.valid.from, second field if it has @cds.valid.to. Default value is [] for each field.
   */
  function extractValidFromToKeyElement(element) {
    let validFroms = [], validTos = [], validKeys = [];
    if(hasBoolAnnotation(element, '@cds.valid.from')) {
      validFroms.push(element);
    }
    if(hasBoolAnnotation(element, '@cds.valid.to')) {
      validTos.push(element);
    }
    if(hasBoolAnnotation(element, '@cds.valid.key')) {
      validKeys.push(element);
    }
    return [validFroms, validTos, validKeys];
  }

  /**
   * Check if the element can be annotated with the given annotation.
   * Only runs the check if:
   * - The artifact is not a type
   * - The artifact is not a view
   *
   * Signals an error, if:
   * - The element is structured
   * - Has a target
   * - Has an element as _parent.kind
   *
   * @param {any} annoName Annotation name
   * @param {any} element Element to check
   * @param {any} artifact Artifact
   * @returns {Boolean} True if no errors
   */
  function checkAssignment(annoName, element, artifact) {
    if(artifact.kind !== 'type' && !artifact.query) {
      if(isStructuredElement(element) || element.target || element._parent.kind === 'element') {
        signal(error`Element cannot be annotated with "${annoName}"`, element.location);
        return false;
      }
    }
    return true;
  }

  /**
   * Signals an error/warning if an annotation has been assigned more than once
   *
   * @param {any} array Array of elements that have the annotation
   * @param {any} annoName Name of the annotation
   * @param {any} artifact Root artifact containing the elements
   * @param {boolean} [err=true] Down-grade to a warning if set to false
   */
  function checkMultipleAssignments(array, annoName, artifact, err=true) {
    if(array.length > 1) {
      if(err == true) {
        signal(error`"${annoName}" must be assigned only once`, artifact.location);
      }
      else {
        signal(warning`"${annoName}" must be assigned only once`, artifact.location);
      }
    }
  }
}

module.exports = {
  // This function retrieves the actual exports
  getTransformers,
};
