'use strict';

// A "tools" collection of various transformation functions that might be helpful for
// different backends.
// The sibling of model/tranform/TransformUtil.js whixh works with compacted new CSN.

const alerts = require('../base/alerts');
const { hasErrors } = require('../base/messages');
const { setProp } = require('../base/model');
// eslint-disable-next-line no-unused-vars
const { copyAnnotations, printableName, hasBoolAnnotation, forEachDefinition } = require('../model/modelUtils');
const { dfilter } = require('./udict');
const { cloneCsn, forEachRef, getUtils } = require('../model/csnUtils');

// Return the public functions of this module, with 'model' captured in a closure (for definitions, options etc).
// Use 'pathDelimiter' for flattened names (e.g. of struct elements or foreign key elements).
// 'model' is compacted new style CSN
// TODO: Error and warnings handling with compacted CSN? - currently just throw new Error for everything
// TODO: check the situation with assocs with values. In compacted CSN such elements have only "@Core.Computed": true
function getTransformers(model, options, pathDelimiter = '_') {
  const { error, warning, signal } = alerts(model, options);
  const {
    getCsnDef,
    getFinalBaseType,
    hasBoolAnnotation,
    inspectRef,
    isStructured,
    isBuiltinType
  } = getUtils(model);

  return {
    addDefaultTypeFacets,
    flattenForeignKeys,
    createForeignKeyElement,
    checkForeignKeys,
    flattenStructuredElement,
    flattenOnCond,
    flattenStructStepsInRef,
    checkExposedAssoc,
    toFinalBaseType,
    copyTypeProperties,
    isAssociationOperand,
    isDollarSelfOperand,
    getFinalBaseType,
    createExposingProjection,
    createAndAddDraftAdminDataProjection,
    createScalarElement,
    createAssociationElement,
    createAssociationPathComparison,
    createForeignKey,
    addForeignKey,
    addElement,
    copyAndAddElement,
    createAction,
    addAction,
    extractValidFromToKeyElement,
    checkMultipleAssignments,
    checkAssignment,
    recurseElements,
    renameAnnotation,
    setAnnotation,
  };

  // Try to apply length, precision, scale from options if no type facet is set on the primitive types 'cds.String' or 'cds.Decimal'.
  // If 'obj' has primitive type 'cds.String' and no length try to apply length from options if available or set to default 5000.
  // if 'obj' has primitive type 'cds.Decimal' try to apply precision, scale from options if available.
  function addDefaultTypeFacets(element) {
    if (!element || !element.type)
      return;

    if (element.type === 'cds.String' && element.length === undefined) {
      element.length = model.options && model.options.length ? model.options.length : 5000;
      if (!(model.options && model.options.length))
        setProp(element, '$default', true);
    }
    if (element.type === 'cds.Decimal' && element.precision === undefined && model.options.precision) {
      element.precision = model.options.precision;
    }
    if (element.type === 'cds.Decimal' && element.scale === undefined && model.options.scale) {
      element.scale = model.options.scale;
    }
  }


  // For an array `keys` of foreign key infos, return an array in flattened form
  // in one of the two cases:
  // (1) replace all foreign keys that are managed associations themselves by
  // their respective foreign keys, recursively, with names flattened using
  // pathDelimiter between path components.
  // (2) replace all foreign keys that are structured with their respective flattened form.
  //
  // Note: must be done after struct flattening(flattenStructuredElement method),
  // otherwise we might encounter already generated foreign key fields in types
  // we have already processed.
  function flattenForeignKeys(assoc, flattenedKeyArts, callbackForUnflattenedArts) {
    let fkSeparator = pathDelimiter;

    let targetArt = getCsnDef(assoc.target);
    if (callbackForUnflattenedArts && !(assoc.target in flattenedKeyArts)) {
      callbackForUnflattenedArts(targetArt, assoc.target, flattenedKeyArts);
    }

    // get all the elements from the target that have 'key' identifier
    let targetKeys = dfilter(targetArt.elements, elem => elem.key === true);
    // in case we have explicitly defined FKs
    Object.assign(targetKeys, dfilter(targetArt.elements, (elem, elemName) => {
      if (elem._flatElementNameWithDots) {
        // this is flattened elem -> keys still not flattened, have to check if starts with key ref
        // FIXME: review why join('.')? what about join(fkSeparator)?
        return assoc.keys.map(key => key.ref.join('.')).some(keyDotName => elemName.startsWith(`${keyDotName}${fkSeparator}`));
      } else {
        // exact match of the name
        return assoc.keys.map(key => key.ref.join('.')).some(keyDotName => keyDotName === elemName);
      }
    }));

    let result = [];

    // this iteration assumes the elements in the tartgetArtifact are flattened
    for (let key of assoc.keys) {

      let fKeyName = key.ref.join(fkSeparator);

      // The key is an association - (1)
      if (Object.keys(targetKeys).includes(fKeyName) && targetKeys[fKeyName].type
        && targetKeys[fKeyName].type === 'cds.Association' && targetKeys[fKeyName].target
      ) {
        // as there is no assurance that the target of the target has flattened keys already
        // has to go through both of the associations
        getCsnDef(targetKeys[fKeyName].target); // sanity check if the definition exists
        targetKeys[fKeyName].keys.forEach(k => result.push({ ref: [`${fKeyName}${fkSeparator}${k.ref.join(fkSeparator)}`] }));
        continue;
      }

      // collect potential flattened keys, which are the counterpart of the current key
      let flattenedKeys = [];
      for (let keyName in targetKeys) {
        if (targetKeys[keyName].$viaTransform && keyName.startsWith(`${fKeyName}${fkSeparator}`))
          flattenedKeys.push(keyName);
      }

      // The keys is structured element (2)
      if (flattenedKeys.length) {
        flattenedKeys.forEach(k => result.push({ ref: [k], as: k }));
      } else {
        // Otherwise simply take as it is
        result.push(key);
      }
    }

    assoc.keys = result;
  }

  // (1) Create an artificial foreign key element for association 'assoc' (possibly part
  // of nested struct, i.e. containing dots) in 'artifact', using foreign key info
  // from 'foreignKey'.
  // (2) Inserting it into 'elements' of 'artifact'.
  // (3) Add a property '$generatedFieldName' to the corresponding 'foreignKey' of the assoc.
  //
  // Note that this must happen after struct flattening(flattenStructuredElement) - both fot elements and foreign keys.
  // Return the newly generated foreign key element.
  function createForeignKeyElement(assoc, assocName, foreignKey, artifact, artifactName, path) {
    let result = {};
    let fkSeparator = pathDelimiter;

    // Assemble foreign key element name from assoc name, '_' and foreign key name/alias
    // let foreignKeyElementName = assocName.replace(/\./g, pathDelimiter) + fkSeparator + foreignKey.ref.join(pathDelimiter);
    let foreignKeyElementName = `${assocName.replace(/\./g, pathDelimiter)}${fkSeparator}${foreignKey.as || foreignKey.ref.join(pathDelimiter)}`;

    let fkArtifact = inspectRef(path).art;

    // In case of compiler errors the foreign key might be missing
    if (!fkArtifact && hasErrors((model.options && model.options.messages) || model.messages)) {
      return null;
    }

    newForeignKey(fkArtifact,foreignKeyElementName)

    function processAssociationOrComposition(fkArtifact,foreignKeyElementName) {
      fkArtifact.keys.forEach(iKey => {
        let iKeyArtifact = inspectRef(iKey.$path).art;

        if (!iKeyArtifact && hasErrors((model.options && model.options.messages) || model.messages)) {
          return;
        }
        if(iKey.ref.length>1)
          throw Error(`createForeignKeyElement(${artifactName},${assocName},${iKey.$path.join('/')}) unexpected reference: `+iKey.ref)
        newForeignKey(iKeyArtifact,foreignKeyElementName+'_'+iKey.ref[0])
      })
    }

    // compose new foreign key out of 'fkArtifact' named 'foreignKeyElementName'
    function newForeignKey(fkArtifact,foreignKeyElementName) {

      if(fkArtifact.type=='cds.Association' || fkArtifact.type=='cds.Composition' ) {
        processAssociationOrComposition(fkArtifact,foreignKeyElementName)
        return;
      }

      let foreignKeyElement = Object.create(null);

      // Transfer selected type properties from target key element
      // FIXME: There is currently no other way but to treat the annotation '@odata.Type' as a type property.
      for (let prop of ['type', 'length', 'scale', 'precision', 'srid', 'default', '@odata.Type']) {
        if (fkArtifact[prop] != undefined) {
          foreignKeyElement[prop] = fkArtifact[prop];
        }
      }

      if (model.options && !model.options.forHana)
        copyAnnotations(assoc, foreignKeyElement, true);

      // If the association is non-fkArtifact resp. key, so should be the foreign key field
      for (let prop of ['notNull', 'key']) {
        if (assoc[prop] != undefined) {
          foreignKeyElement[prop] = assoc[prop];
        }
      }
      // Insert artificial element into artifact, with all cross-links (must not exist already)
      if (artifact.elements[foreignKeyElementName]) {
        signal(error`Generated foreign key element "${foreignKeyElementName}" for association "${assocName}" conflicts with existing element`, ['definitions', artifactName, 'elements', foreignKeyElementName]);
      }
      artifact.elements[foreignKeyElementName] = foreignKeyElement;

      // Establish the relationship between generated field and association:
      // - generated field has annotation '@odata.foreignKey4'.
      // - foreign key info has 'generatedFieldName'
      foreignKeyElement['@odata.foreignKey4'] = assocName;
      foreignKey.$generatedFieldName = foreignKeyElementName;
      setProp(foreignKey, "$path", path); // attach $path to the newly created element - used for inspectRef in processAssociationOrComposition

      result[foreignKeyElementName] = foreignKeyElement;
    } // function newForeignKey
    return result;
  }

  // For an association 'assoc', check that all foreign keys (if any) actually exist in the
  // target. Must only be applied after flattening structured foreign keys.
  // Note that this may also be called for unmanaged associations with artificially created
  // ON-conditions, because these still retain their foreign key info.
  // FIXME: For all cases except implicit redirection, this should actually be done by the compiler
  function checkForeignKeys(assoc, assocName, artifactName, options) {
    // FIXME: Because this assumes flattening, it does not work with 'hdbcds' naming mode. Because
    // it will become obsolete soon anyway (compiler checking and rewriting ON-conditions), we
    // don't bother to adapt it.
    if (options && options.forHana && options.forHana.keepStructsAssocs) {
      return;
    }

    for (let name in assoc.keys) {
      let foreignKey = assoc.keys[name];
      let target = model.definitions[assoc.target];
      // Sanity checks
      if(options && options.toOdata && options.toOdata.odataFormat !== 'structured')
        if (foreignKey.ref.length > 1) {
          throw Error('Expecting foreign key ' + foreignKey.$generatedFieldName + ' to be flattened');
        }
      if (!target) {
        throw Error('Expecting target of association ' + assocName + ' to be resolved');
      }
      if (!target.elements || Object.keys(target.elements).length == 0) {
        throw Error('Expecting target of association ' + assocName + ' to have elements');
      }
      // Try to "resolve" the corresponding element
      let targetElementName = foreignKey.ref[0];
      if (target.elements[targetElementName] == undefined) {
        signal(error`Foreign key "${targetElementName}" not found in target "${assoc.target}" of association "${artifactName}.${assocName}"`, ['definitions', artifactName, 'elements', assocName]);
      }
    }
  }

  // For a structured element 'elem', return a dictionary of flattened elements to
  // replace it, flattening names with pathDelimiter's value and propagating all annotations and the
  // type properties 'key', 'notNull', 'virtual', 'masked' to the flattened elements.
  // example input:
  //  { elem: {
  //          key: true,
  //          @foo: true,
  //          elements:
  //            { a: { type: 'cds.Integer' } },
  //            { b: {
  //                 elements:
  //                   { b1: type: 'cds.String', length: 42 } } },
  //  } }
  //
  // result:
  //  { elem_a: {
  //          key: true,
  //          @foo: true,
  //          type: 'cds.Integer' },
  //    elem_b_b1: {
  //          key: true,
  //          @foo: true,
  //          type: 'cds.String',
  //          length: 42 },
  // }
  function flattenStructuredElement(elem, elemName, parentElementPath=[], pathInCsn=[], flattenCallback=undefined) {
    let elementPath=parentElementPath.concat(elemName); // elementPath contains only element names without the csn structure node names
    if(flattenCallback)
      flattenCallback(pathInCsn);
    // in case the element is of user defined type => take the definition of the type
    // for type of 'x' -> elem.type is an object, not a string -> use directly
    let elemType;
    if (!elem.elements) // structures do not have final base type
      elemType = getFinalBaseType(elem.type);

    const struct = elemType ? elemType.elements : elem.elements;

    // Collect all child elements (recursively) into 'result'
    let result = Object.create(null);
    const addGeneratedFlattenedElement = (e, eName) => {
      if(result[eName]){
        signal(error`Generated element ${eName} conflicts with other generated element`, pathInCsn)
      } else {
        result[eName] = e;
      }    
    }

    for (let childName in struct) {
      let childElem = struct[childName];
      if (isStructured(childElem)) {
        // Descend recursively into structured children
        let grandChildElems = flattenStructuredElement(childElem, childName, elementPath, pathInCsn.concat('elements',childName), flattenCallback);
        for (let grandChildName in grandChildElems) {
          let flatElemName = elemName + pathDelimiter + grandChildName;
          let flatElem = grandChildElems[grandChildName];
          addGeneratedFlattenedElement(flatElem, flatElemName);
          // TODO: check with values. In CSN such elements have only "@Core.Computed": true
          // If the original element had a value, construct one for the flattened element
          // if (elem.value) {
          //   createFlattenedValue(flatElem, flatElemName, grandChildName);
          // }
          // Preserve the generated element name as it would have been with 'hdbcds' names
        }
      } else {
        // Primitive child - clone it and restore its cross references
        let flatElemName = elemName + pathDelimiter + childName;
        let flatElem = cloneCsn(childElem);
        setProp(flatElem, '$viaTransform', true); // FIXME: This name is not ideal but used elsewhere, too)
        setProp(flatElem, '_flatElementNameWithDots', elementPath.concat(childName).join('.'));
        addGeneratedFlattenedElement(flatElem, flatElemName);
      }
    }
    // Fix all collected flat elements (names, annotations, properties, origin ..)
    for (let name in result) {
      let flatElem = result[name];
      // Copy annotations from struct (not overwriting, because deep annotations should have precedence)
      copyAnnotations(elem, flatElem, false);
      // Copy selected type properties
      for (let p of ['key', 'notNull', 'virtual', 'masked', 'viaAll']) {
        if (elem[p]) {
          flatElem[p] = elem[p];
        }
      }
    }
    return result;
  }

  // Return a copy of 'ref' where all path steps resulting from struct traversal are
  // fused together into one step, using '_' (so that the path fits again for flattened
  // structs), e.g.
  //   [ (Entity), (struct1), (struct2), (assoc), (elem) ] should result in
  //   [ (Entity), (struct1_struct2_assoc), (elem) ]
  // 'path' is the csn path to the ref
  function flattenStructStepsInRef(ref, path) {
    // Refs of length 1 cannot contain steps - no need to check
    if (ref.length < 2) {
      return ref;
    }

    try {
      return flatten(ref, path);
    } catch (e) {
      if (e.message && e.message === "Scope 'ref-where' but no entity was provided.") {
        return flatten(ref, path);
      } else {
        throw e;
      }
    }

    function flatten(ref, path) {
      let result = [];
      //let stack = []; // IDs of path steps not yet processed or part of a struct traversal
      const { links, scope } = inspectRef(path);
      if (scope === '$magic')
        return ref;
      let flattenStep = false;
      links.forEach((value, idx) => {
        if (flattenStep)
          result[result.length - 1] += pathDelimiter + ref[idx];
        else {
          result.push(ref[idx]);
        }
        flattenStep = value.art && !(value.art.kind === 'entity') && !value.art.SELECT && (value.art._effectiveType && value.art._effectiveType.elements || value.art.elements);
      });
      // If the path starts with '$self', this is now redundant (because of flattening) and can be omitted,
      // making life easier for consumers
      if (result[0] === '$self' && result.length > 1) {
        result = result.slice(1);
      }
      return result;
    }
  }

  // Flatten on conditions of unmanaged associations. This method assumes that
  // other flattening of the elements was already performed and there are
  // no left over structure elements marked with some ignore flag. Also, uses
  // the non-enumerable property '_flatElementNameWithDots'.
  function flattenOnCond(assoc, assocName, defElements, defName, path) {

    if (!assoc.on) return; // nothing to do

    forEachRef(assoc, (ref, node, path) => {
      // assoc itself is inside a struct -> all the first refs need to be flattened;
      if (assoc.$viaTransform) {
        // when the first ref id is the same association
        if (assoc._flatElementNameWithDots.endsWith(`.${ref[0]}`))
          ref.splice(0, 1, assocName);
        // elem from the curr name resolution scope
        // but not a $self, will deal with this one later
        else if (ref[0] !== '$self') {
          // .splice(-1, 1, ref[0]) does not work here, why???
          let currStructFlatName = `${assoc._flatElementNameWithDots.split('.').slice(0, -1).join('_')}`
          node.ref.splice(0, 1, `${currStructFlatName}_${ref[0]}`);
        }
      }

      let flatRef = [];
      let needToFlat = false;

      // $user.locale must not be flatten and they are not understand by inspectRef
      if (ref.join('.') === '$user.locale')
        return;

      ref.slice().forEach(refId => {
        if (needToFlat) {
          let flatLastElem = `${flatRef[flatRef.length - 1]}${pathDelimiter}${refId}`;
          flatRef.splice(-1, 1, flatLastElem);
          needToFlat = false;
        } else
          flatRef.push(refId);

        node.ref = flatRef;
        let { art } = inspectRef(path);

        // if not resolved to an art, then this element was flattened
        if (!art)
          needToFlat = true;
      });

      // remove leading $self when at the begining of a ref
      if (ref.length > 1 && ref[0] === '$self')
        node.ref.splice(0, 1);
    }, path);
  }

  // Check that exposed associations do not point to non-exposed targets
  function checkExposedAssoc(artName, assocDef, assocName, service) {
    let assocTargetDef = getCsnDef(assocDef.target);
    if (!assocDef._ignore && assocDef.target && assocTargetDef && !assocDef.target.startsWith(service)) {
      // If we have a 'preserved dotted name' ->  a result of flattening -> This scenario is not supported yet
      if (assocDef._flatElementNameWithDots)
        signal(error`Redirection for sub elements not supported yet - association "${artName}.${assocName}"`, ['definitions', artName, 'elements', assocName]);
    }
  }

  /**
   * Copy properties of the referenced type, but don't resolve to the final base type.
   *
   * @param {any} node Node to copy to
   * @returns {void}
   */
  function copyTypeProperties(node) {
    // Nothing to do if no type (or if array/struct type)
    if (!node || !node.type) return;
    // ..  or if it is a ref
    if (node.type && node.type.ref) return;
    // ..  or builtin already
    if (node.type && typeof node.type === 'string' && node.type.startsWith('cds.') && !node.type.startsWith('cds.foundation.')) return;

    // The type might already be a full fledged type def (array of)
    const typeDef = typeof node.type === 'string' ? getCsnDef(node.type) : node.type;
    // Nothing to do if type is an array or a struct type
    if (typeDef.items || typeDef.elements) return;
    // if the declared element is an enum, these values are with priority
    if (!node.enum && typeDef.enum)
      Object.assign(node, { enum: typeDef.enum });
    if (!node.length && typeDef.length && !typeDef.$default)
      Object.assign(node, { length: typeDef.length });
    if (!node.precision && typeDef.precision)
      Object.assign(node, { precision: typeDef.precision });
    if (!node.scale && typeDef.scale)
      Object.assign(node, { scale: typeDef.scale });
    if (!node.srid && typeDef.srid)
      Object.assign(node, { srid: typeDef.srid });
  }

  // Replace the type of 'node' with its final base type (in contrast to the compiler,
  // also unravel derived enum types, i.e. take the final base type of the enum's base type.
  // Similar with associations and compositions (we probably need a _baseType link)
  function toFinalBaseType(node) {
    // Nothing to do if no type (or if array/struct type)
    if (!node || !node.type) return;
    // In case of a ref -> Follow the ref
    if (node.type && node.type.ref) {
      let finalBaseType = getFinalBaseType(node.type);
      if(finalBaseType === null)
        throw Error('Failed to obtain final base type for reference : ' + node.type.ref.join('/'));
      if (finalBaseType.elements) {
        node.elements = finalBaseType.elements; // copy elements
        delete node.type; // delete the type reference as edm processing does not expect it
      } else {
        node.type=finalBaseType;
      }
      return;
    }
    // ..  or builtin already
    if (node.type && typeof node.type === 'string' && node.type.startsWith('cds.') && !node.type.startsWith('cds.foundation.')) return;

    // The type might already be a full fledged type def (array of)
    let typeDef = typeof node.type === 'string' ? getCsnDef(node.type) : node.type;
    // Nothing to do if type is an array or a struct type
    if (typeDef.items || typeDef.elements) return;
    // if the declared element is an enum, these values are with priority
    if (!node.enum && typeDef.enum)
      Object.assign(node, { enum: typeDef.enum });
    if (!node.length && typeDef.length)
      Object.assign(node, { length: typeDef.length });
    if (!node.precision && typeDef.precision)
      Object.assign(node, { precision: typeDef.precision });
    if (!node.scale && typeDef.scale)
      Object.assign(node, { scale: typeDef.scale });
    if (!node.srid && typeDef.srid)
      Object.assign(node, { srid: typeDef.srid });
    node.type = typeDef.type;
    toFinalBaseType(node);
  }

  // Return a full projection 'projectionId' of artifact 'art' for exposure in 'service'.
  // Add the created projection to the model and complain if artifact already exists.
  // Used by Draft generation
  function createExposingProjection(art, artName, projectionId, service) {
    let projectionAbsoluteName = `${service}.${projectionId}`;
    // If there already is an artifact with this name, this is either the second attempt or a conflict
    let existingProjection = model.definitions[projectionAbsoluteName];
    if (existingProjection) {
      signal(error`Cannot generate projection "${projectionAbsoluteName}" because of name conflict with existing artifact "${service.name.absolute}.$projectionId}"`);
      return null;
    }
    // Create elements matching the artifact's elements
    let elements = Object.create(null);
    for (let elemName in art.elements) {
      let artElem = art.elements[elemName];
      let elem = Object.assign({}, artElem);
      // Transfer xrefs, that are redirected to the projection
      // TODO: shall we remove the transfered elements from the original?
      // if (artElem._xref) {
      //   setProp(elem, '_xref', artElem._xref.filter(xref => xref.user && xref.user._main && xref.user._main._service == service));
      // }
      // FIXME: Remove once the compactor no longer renders 'origin'
      elements[elemName] = elem;
    }
    let query = {
      'SELECT': {
        'from': {
          'ref': [
            artName
          ]
        }
      }
    };
    // Assemble the projection itself and add it into the model
    let projection = {
      'kind': 'entity',
      query,
      elements,
      //'$syntax': 'projection'
    };
    // copy annotations from art to projection
    for (let a of Object.keys(art).filter(x => x.startsWith('@'))) {
      projection[a] = art[a];
    }
    // Sanity check: Can't already be there (checked above)
    if (model.definitions[projectionAbsoluteName]) {
      throw new Error('Duplicate projection: ' + projectionAbsoluteName);
    }
    model.definitions[projectionAbsoluteName] = projection;
    return projection;
  }

  // Create a 'DraftAdministrativeData' projection on entity 'DRAFT.DraftAdministrativeData'
  // in service 'service' and add it to the model.
  function createAndAddDraftAdminDataProjection(service) {
    // Make sure we have a DRAFT.DraftAdministrativeData entity
    let draftAdminDataEntity = model.definitions['DRAFT.DraftAdministrativeData'];
    if (!draftAdminDataEntity) {
      draftAdminDataEntity = createAndAddDraftAdminDataEntity();
      model.definitions['DRAFT.DraftAdministrativeData'] = draftAdminDataEntity;
    }
    // Barf if it is not an entity or not what we expect
    if (draftAdminDataEntity.kind !== 'entity' || !draftAdminDataEntity.elements['DraftUUID']) {
      signal(error`Generated entity "DRAFT.DraftAdministrativeData" conflicts with existing artifact`, ['definitions', 'DRAFT.DraftAdministrativeData']);
    }

    // Create a projection within this service
    return createExposingProjection(draftAdminDataEntity, 'DRAFT.DraftAdministrativeData', 'DraftAdministrativeData', service);

    /**
     * Create the 'DRAFT.DraftAdministrativeData' entity (unless it already exist)
     * Return the 'DRAFT.DraftAdministrativeData' entity.
     */
    function createAndAddDraftAdminDataEntity(artifactName = 'DRAFT.DraftAdministrativeData') {
      // Create the 'DRAFT.DraftAdministrativeData' entity
      let artifact = {
        kind: 'entity',
        elements: Object.create(null),
      }

      // key DraftUUID : UUID
      let draftUuid = createScalarElement('DraftUUID', 'cds.UUID', true);
      draftUuid.DraftUUID['@UI.Hidden'] = true;
      draftUuid.DraftUUID['@Common.Label'] = '{i18n>Draft_DraftUUID}';
      addElement(draftUuid, artifact, artifactName);

      // CreationDateTime : Timestamp;
      let creationDateTime = createScalarElement('CreationDateTime', 'cds.Timestamp');
      creationDateTime.CreationDateTime['@Common.Label'] = '{i18n>Draft_CreationDateTime}';
      addElement(creationDateTime, artifact, artifactName);

      // CreatedByUser : String(256);
      let createdByUser = createScalarElement('CreatedByUser', 'cds.String');
      createdByUser['CreatedByUser'].length = 256;
      createdByUser.CreatedByUser['@Common.Label'] = '{i18n>Draft_CreatedByUser}';
      addElement(createdByUser, artifact, artifactName);

      // DraftIsCreatedByMe : Boolean;
      let draftIsCreatedByMe = createScalarElement('DraftIsCreatedByMe', 'cds.Boolean');
      draftIsCreatedByMe.DraftIsCreatedByMe['@UI.Hidden'] = true;
      draftIsCreatedByMe.DraftIsCreatedByMe['@Common.Label'] = '{i18n>Draft_DraftIsCreatedByMe}';
      addElement(draftIsCreatedByMe, artifact, artifactName);

      // LastChangeDateTime : Timestamp;
      let lastChangeDateTime = createScalarElement('LastChangeDateTime', 'cds.Timestamp');
      lastChangeDateTime.LastChangeDateTime['@Common.Label'] = '{i18n>Draft_LastChangeDateTime}';
      addElement(lastChangeDateTime, artifact, artifactName);

      // LastChangedByUser : String(256);
      let lastChangedByUser = createScalarElement('LastChangedByUser', 'cds.String');
      lastChangedByUser['LastChangedByUser'].length = 256;
      lastChangedByUser.LastChangedByUser['@Common.Label'] = '{i18n>Draft_LastChangedByUser}';
      addElement(lastChangedByUser, artifact, artifactName);

      // InProcessByUser : String(256);
      let inProcessByUser = createScalarElement('InProcessByUser', 'cds.String');
      inProcessByUser['InProcessByUser'].length = 256;
      inProcessByUser.InProcessByUser['@Common.Label'] = '{i18n>Draft_InProcessByUser}';
      addElement(inProcessByUser, artifact, artifactName);

      // DraftIsProcessedByMe : Boolean;
      let draftIsProcessedByMe = createScalarElement('DraftIsProcessedByMe', 'cds.Boolean');
      draftIsProcessedByMe.DraftIsProcessedByMe['@UI.Hidden'] = true;
      draftIsProcessedByMe.DraftIsProcessedByMe['@Common.Label'] = '{i18n>Draft_DraftIsProcessedByMe}';
      addElement(draftIsProcessedByMe, artifact, artifactName);

      return artifact;
    }
  }

  // Create an artificial scalar element 'elemName' with final type 'typeName'.
  // Make the element a key element if 'isKey' is true.
  // Add a default value 'defaultVal' if supplied
  // example result: { foo: { type: 'cds.Integer', key: true, default: { val: 6 }, notNull: true } }
  //                   ^^^            ^^^^^^^^^       ^^^^                   ^^             ^^
  //                 elemName         typeName        isKey               defaultVal       notNull
  function createScalarElement(elemName, typeName, isKey = false, defaultVal = undefined, notNull=false) {
    if (!isBuiltinType(typeName) && !model.definitions[typeName]) {
      throw new Error('Expecting valid type name: ' + typeName);
    }
    let result = {
      [elemName]: {
        type: typeName
      }
    };
    if (isKey) {
      result[elemName].key = true;
    }
    if (defaultVal !== undefined) {
      result[elemName].default = {
        val: defaultVal,
      }
    }
    if(notNull) {
      result[elemName].notNull = true;
    }
    return result;
  }

  // Return true if 'arg' is an expression argument denoting "$self"
  function isDollarSelfOperand(arg) {
    return arg.ref && arg.ref.length == 1 && (arg.ref[0] === '$self');
  }

  // Return true if 'arg' is an expression argument of type association or composition
  function isAssociationOperand(arg, path) {
    if (!arg.ref) {
      // Not a path, hence not an association (literal, expression, function, whatever ...)
      return false;
    }
    const { art } = inspectRef(path);
    // If it has a target, it is an association or composition
    return art && art.target !== undefined;
  }

  // Create an artificial element 'elemName' of type 'cds.Association',
  // having association target 'target'. If 'isManaged' is true, take all keys
  // of 'target' as foreign keys.
  // e.g. result:
  // { toFoo: {
  //     type: 'cds.Association', target: 'Foo',
  //     keys: [{ ref: ['id'] }]
  // } }
  function createAssociationElement(elemName, target, isManaged = false) {
    let elem = createScalarElement(elemName, 'cds.Association', false, undefined);
    let assoc = elem[elemName];
    assoc.target = target;

    if (isManaged) {
      assoc.keys = [];
      let targetArt = getCsnDef(target);
      for (let keyElemName in targetArt.elements) {
        let keyElem = targetArt.elements[keyElemName];
        if (!keyElem.key) {
          continue;
        }
        let foreignKey = createForeignKey(keyElemName, keyElem);
        addForeignKey(foreignKey, assoc);
      }
    }
    return elem;
  }

  // Create a comparison operation <assoc>.<foreignElem> <op> <elem>.
  // return an array to be spread in an on-condition
  // e.g. [ { ref: ['SiblingEntity','ID'] }, '=', { ref: ['ID'] } ]
  //                 ^^^^^          ^^^      ^^           ^^^
  //                 assoc      foreignElem  op           elem
  function createAssociationPathComparison(assoc, foreignElem, op, elem) {
    return [
      { ref: [assoc, foreignElem] }, op, { ref: [elem] }
    ]
  }

  // Create an artificial foreign key 'keyElemName' for key element 'keyElem'. Note that this
  // only creates a foreign key, not the generated foreign key element.
  // TODO: check the usage of this function's param 'keyElem' ?
  function createForeignKey(keyElemName, keyElem = undefined) { /* eslint-disable-line no-unused-vars */

    return {
      ref: [keyElemName]
      // TODO: do we need these two?
      // calculated: true,
      // $inferred: 'keys',
    }
  }

  // Add foreign key 'foreignKey' to association element 'elem'.
  function addForeignKey(foreignKey, elem) {
    // Sanity checks
    if (!elem.target || !elem.keys) {
      throw new Error('Expecting managed association element with foreign keys');
    }

    // Foreign key must not exist
    if (elem.keys.some(key => JSON.stringify(foreignKey) === JSON.stringify(key))) {
      signal(error`Key already exists: ${JSON.stringify(foreignKey)}`);
      return;
    }

    // Add the foreign key
    elem.keys.push(foreignKey);
  }


  /**
   * Add element 'elem' to 'artifact'
   *
   * @param {any} elem is in form: { b: { type: 'cds.String' } }
   * @param {CSN.Artifact} artifact is: { kind: 'entity', elements: { a: { type: 'cds.Integer' } ... } }
   * @param {string} [artifactName] Name of the artifact in `csn.definitions[]`.
   * @returns {void}
   */
  function addElement(elem, artifact, artifactName) {
    // Sanity check
    if (!artifact.elements) {
      throw new Error('Expecting artifact with elements: ' + JSON.stringify(artifact));
    }
    let elemName = Object.keys(elem)[0];
    // Element must not exist
    if (artifact.elements[elemName]) {
      let path = undefined;
      if (artifactName) {
        path = ['definitions', artifactName, 'elements', elemName];
      }
      signal(error`"${elemName}": Element name conflicts with existing element`, path);
      return;
    }

    // Add the element
    Object.assign(artifact.elements, elem);
  }

  /**
   * Make a copy of element 'elem' (e.g. { elem: { type: 'cds.Integer' } })
   * and add it to 'artifact' under the new name 'elemName'.
   * ( e.g. { artifact: { elements: { elemName: { type: 'cds.Integer' } } })
   * Return the newly created element
   * (e.g. { elemName: { type: 'cds.Integer' } })
   *
   * @param {object} elem
   * @param {CSN.Artifact} artifact
   * @param {string} artifactName
   * @param {string} elementName
   */
  function copyAndAddElement(elem, artifact, artifactName, elementName) {
    if (!artifact.elements) {
      throw new Error('Expected structured artifact');
    }
    // Must not already have such an element
    if (artifact.elements[elementName]) {
      const path = ['definitions', artifactName, 'elements', elementName];
      signal(error`"${elementName}": Element name conflicts with existing element`, path);
    }

    let result = { [elementName]: {} };
    for (let prop in elem)
      result[elementName][prop] = elem[prop];
    Object.assign(artifact.elements, result);
    return result;
  }

  // Create an artificial action 'actionName' with return type artifact 'returnType' optionally with one parameter 'paramName'
  // of type name 'paramTypeName'
  function createAction(actionName, returnTypeName = undefined, paramName = undefined, paramTypeName = undefined) {
    // Assemble the action
    let result = {
      [actionName]: {
        kind: 'action'
      }
    };

    let action = result[actionName];

    if (returnTypeName) {
      if (!isBuiltinType(returnTypeName) && !model.definitions[returnTypeName])
        throw new Error('Expecting valid return type name: ' + returnTypeName);
      action.returns = { type: returnTypeName };
    }

    // Add parameter if provided
    if (paramName && paramTypeName) {
      if (!isBuiltinType(paramTypeName) && !model.definitions[paramTypeName])
        throw new Error('Expecting valid parameter type name: ' + paramTypeName);

      action.params = Object.create(null);
      action.params[paramName] = {
        type: paramTypeName
      }
    }

    return result;
  }

  /**
   * Add action 'action' to 'artifact'
   *
   * @param {object} action Action that shall be added to the given artifact.
   *                        In form of `{ myAction: { kind: 'action', returns ... } }`
   * @param {CSN.Artifact} artifact Artifact in the form of `{ kind: 'entity', elements: ... }`
   * @param {string} artifactName Name of the artifact (used for error locations).
   **/
  function addAction(action, artifact, artifactName) {
    if (!artifact.actions) {
      artifact.actions = Object.create(null);
    }

    let actionName = Object.keys(action)[0];
    // Element must not exist
    if (artifact.actions[actionName]) {
      signal(error`Generated action name conflicts with existing action "${actionName}"`,
        ['definitions', artifactName, 'actions', actionName]);
      return;
    }

    // Add the action
    Object.assign(artifact.actions, action);
  }

  /**
   * If the element has annotation @cds.valid.from or @cds.valid.to, return it.
   *
   * @param {any} element Element to check
   * @param {Array} path path in CSN for error messages
   * @returns {Array[]} Array of arrays, first filed has an array with the element if it has @cds.valid.from, second field if it has @cds.valid.to. Default value is [] for each field.
   */
  function extractValidFromToKeyElement(element, path) {
    let validFroms = [], validTos = [], validKeys = [];
    if (hasBoolAnnotation(element, '@cds.valid.from')) {
      validFroms.push({ element, path: [...path] });
    }
    if (hasBoolAnnotation(element, '@cds.valid.to')) {
      validTos.push({ element, path: [...path] });
    }
    if (hasBoolAnnotation(element, '@cds.valid.key')) {
      validKeys.push({ element, path: [...path] });
    }
    return [validFroms, validTos, validKeys];
  }

  /**
   * Check if the element can be annotated with the given annotation.
   * Only runs the check if:
   * - The artifact is not a type
   * - The artifact is not a view
   *
   * Signals an error, if:
   * - The element is structured
   * - Has a target
   * - Has an element as _parent.kind
   *
   * @param {string} annoName Annotation name
   * @param {object} element Element to be checked
   * @param {string[]} path
   * @param {CSN.Artifact} artifact
   * @returns {boolean} True if no errors
   */
  function checkAssignment(annoName, element, path, artifact) {
    if (artifact.kind !== 'type' && !artifact.query) {
      // path.length > 4 to check for structured elements
      if (element.elements || element.target || path.length > 4) {
        signal(error`Element cannot be annotated with "${annoName}"`, path);
        return false;
      }
    }
    return true;
  }

  /**
   * Signals an error/warning if an annotation has been assigned more than once
   *
   * @param {any} array Array of elements that have the annotation
   * @param {any} annoName Name of the annotation
   * @param {CSN.Artifact} artifact Root artifact containing the elements
   * @param {string} artifactName Name of the root artifact
   * @param {boolean} [err=true] Down-grade to a warning if set to false
   */
  function checkMultipleAssignments(array, annoName, artifact, artifactName, err = true) {
    if (array.length > 1) {
      if (err == true) {
        signal(error`"${annoName}" must be assigned only once`, ['definitions', artifactName]);
      } else {
        signal(warning`"${annoName}" must be assigned only once`, ['definitions', artifactName]);
      }
    }
  }

  /**
   * Calls `callback` for each element in `elements` property of `artifact` recursively.
   *
   * @param {CSN.Artifact} artifact the artifact
   * @param {string[]} path path to get to `artifact` (mainly used for error messages)
   * @param {(art: CSN.Artifact, path: string[]) => any} callback Function called for each element recursively.
   */
  function recurseElements(artifact, path, callback) {
    callback(artifact, path);
    let elements = artifact.elements;
    if (elements) {
      path.push('elements', null);
      for (let name in elements) {
        let obj = elements[name];
        path[path.length - 1] = name;
        recurseElements(obj, path, callback);
      }
      // reset path for subsequent usages
      path.length -= 2; // equivalent to 2x pop()
    }
  }

  // Rename annotation 'fromName' in 'node' to 'toName' (both names including '@')
  function renameAnnotation(node, fromName, toName) {
    let annotation = node && node[fromName];
    // Sanity checks
    if (!fromName.startsWith('@')) {
      throw Error('Annotation name should start with "@": ' + fromName);
    }
    if (!toName.startsWith('@')) {
      throw Error('Annotation name should start with "@": ' + toName);
    }
    if (annotation == undefined) {
      throw Error('Annotation ' + fromName + ' not found in ' + JSON.stringify(node));
    }
    if(node[toName] === undefined || node[toName] === null) {
      delete node[fromName];
      node[toName] = annotation;
    }
  }

  /**
   * Assign annotation to a node but do not overwrite already existing annotation assignment
   * that is (assignment is either undefined or has null value)
   *
   * @param {object} node Assignee
   * @param {string} name Annotation name
   * @param {any} value Annotation value
   * @returns {void}
   */
  function setAnnotation(node, name, value) {
    if (!name.startsWith('@')) {
      throw Error('Annotation name should start with "@": ' + name);
    }
    if (value === undefined) {
      throw Error('Annotation value must not be undefined');
    }

    if(node[name] === undefined || node[name] === null)
      node[name] = value;
  }
}


// A generic function that applies a number of (simple) transformations to a csn model
// by visiting each node. The transformer object has properties that are looked for in
// the node(s) and the corresponding functions are applied. The functions are called
// with the oldValue, the node and the property name as parameters
// E.g. { type: fctToMapType() } as a transformer would change each type node in the model
// by replacing the oldValue of type by fctToMapType(oldValue, node, 'type')
// The function is aware of dictionaries and would not call the transformer on an
// entity called 'type'
function transformModel(model, transformers) {

  return transformNode(model, undefined, undefined, []);

  // This general transformation function will be applied to each node recursively
  function transformNode(node, bla, blub, path) {
    // Return primitive values and null unchanged, but let objects and dictionaries through
    // (Note that 'node instanceof Object' would be false for dictionaries).
    if (node === null || typeof node !== 'object') {
      return;
    }
    // Simply return if node is to be ignored
    if (node == undefined || node._ignore)
      return;
    // Transform arrays element-wise
    if (node instanceof Array) {
      node.forEach((subnode, index) => transformNode(subnode, null, null, path.concat([index])));
      return;
    }
    // Things not having 'proto' are dictionaries
    let proto = Object.getPrototypeOf(node);
    // Iterate own properties of 'node' and transform them into 'resultNode'
    for (let key of Object.keys(node)) {
      // Dictionary always use transformNode(), other objects their transformer according to key
      let transformer = (proto == undefined) ? transformNode : transformers[key] || transformers[key.charAt(0)];
      // Apply transformer, or use transformNode() if there is none
      (transformer || transformNode)(node[key], node, key, path.concat([key]));
    }
  }
}


module.exports = {
  // This function retrieves the actual exports
  getTransformers,
  transformModel
};
