const { extend } = require('./utilities')

class any {
  constructor(...aspects) {
    this.set('name')
    aspects.length && extend(this).with(...aspects)
  }

  /**
   * Allows mixins to a single builtin class
   * @example cds.entity.mixin (class { foo(){} })
   */
  static mixin(...aspects) {
    return extend(this).with(...aspects)
  }

  /**
   * Allows mixins to a single builtin class prototype
   * @example cds.entity.prototype.mixin (class { foo(){} })
   */
  mixin(...aspects) {
    return extend(this).with(...aspects)
  }

  set kind(k) {
    this.set('kind', k, true)
  }
  get kind() {
    return this.set('kind', this.parent ? 'element' : this.query ? 'entity' : 'type')
  }

  is(kind) {
    if (typeof kind === 'function') return this instanceof kind
    if (kind === 'struct') return this.elements !== undefined
    else return this.kind === kind
  }

  own(property) {
    let pd = Reflect.getOwnPropertyDescriptor(this, property)
    if (pd) return pd.value || pd.get(this)
  }

  set(property, value, enumerable = false) {
    Reflect.defineProperty(this, property, {
      value,
      enumerable,
      writable: 1,
      configurable: 1,
    })
    return value
  }

  valueOf() {
    return this.name
  }
}

class type extends any {}
class struct extends type {}
class context extends any {}
class service extends context {}

class entity extends struct {
  is(kind) {
    if (kind === 'view') return this.query !== undefined
    return kind === 'entity' || kind === 'struct' || super.is(kind)
  }

  set keys(k) {
    this.set('_keys', k)
  }
  get keys() {
    const pd = Reflect.getOwnPropertyDescriptor(this, '_keys')
    if (pd) return pd.value
    let ee = this.elements,
      keys,
      dict = {}
    for (let e in ee) if (ee[e].key) (keys = dict)[e] = ee[e]
    return (this.keys = keys)
  }
}

class Association extends type {
  is(kind) {
    return kind === 'Association' || this.type.endsWith(kind) || super.is(kind)
  }

  get is2many() {
    return !this.is2one
  }
  get is2one() {
    let c = this.cardinality
    return !c || c.max === 1 || (!c.max && !c.targetMax) || c.targetMax === 1
  }

  set _elements(k) {
    this.set('_elements', k)
  }
  get _elements() {
    const { keys } = this
    if (!keys) return (this._elements = undefined)
    const fks = {},
      { elements } = this._target
    for (let k of keys) fks[k.as || k.ref[0]] = elements[k.ref[0]]
    return (this._elements = fks)
  }

  set _keys(k) {
    this.set('keys', k)
  }
  get _keys() {
    if (this.keys) return (this._keys = this.keys)
    if (this.on || this.is2many || !this._target) return (this._keys = undefined)
    const keys = [],
      tks = this._target.keys
    for (let k in tks) keys.push({ ref: [tks[k].name] })
    return (this._keys = keys)
  }
}

/**
 * Export is a dictionary of all builtin classes
 */
module.exports = {
  any,
  type,
  struct,
  entity,
  Association,
  context,
  service,

  /**
   * Turns the given CSN definitions into linked definitions.
   * @type <T>(csn:T) => T
   */
  bootstrap(csn) {
    const defs = { any: any.prototype }
    for (const t in csn) {
      if (t in this) {
        defs[t] = this[t].prototype
        continue
      }
      const c = class extends this[csn[t].type || 'any'] {}
      defs[t] = Object.defineProperty(c.prototype, 'name', { value: t })
      this[t] = Object.defineProperty(c, 'name', { value: t })
    }
    return defs
  },

  /**
   * Allows to mixin functions or properties to several equally named builtin classes
   * @example
   * cds.builtin.classes.mixin (
   *  	class any { foo(){} },
   *  	class entity { bar(){} }
   * )
   */
  mixin(...classes) {
    for (let each of classes) {
      const clazz = this[each.name]
      if (!clazz) throw new Error(`unknown class '${each.name}'`)
      clazz.mixin(each)
    }
    return this
  },
}
