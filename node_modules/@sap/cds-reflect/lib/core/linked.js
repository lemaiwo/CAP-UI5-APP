const cds = require('../index'), _builtin = cds.builtin.types, {set} = cds.reflect
const { any, struct, array, context, service, entity, annotation } = _builtin
const _kinds = { annotation, context, service, entity, view:entity }
const _is_linked = Symbol ('is linked')

module.exports = function cds_linked (m) {
	const rm = cds.reflect(m,1)
	if (!rm[_is_linked]) {
		const defs = rm.definitions
		for (let each in defs) _link (defs[each], each, undefined, defs)
		set (rm, _is_linked, true)
	}
	return rm
}


function _link (d, name, parent, defs) {
	if (name)  set (d,'name', name)
	if (parent)  set (d,'parent', parent) // REVISI: -> rename to _parent but seems to conflict with compiler
	// NOTE: the lines below expect own properties only -> have to go before linking prototypes
	if (d.target)  set (d,'_target', _target (d.target,d,defs))
	if (d.via)  set (d,'_via', _target (d.via,d,defs))
	if (d.items)  _link (d.items, name,d,defs)
	for (let e in d.elements) _link (d.elements[e],e,d,defs)
	for (let e in d.actions) _link (d.actions[e],e,d,defs)
	// link definitions prototype
	try { Object.setPrototypeOf (d,
		d.query ? _infer(d,defs) :
		d.type ? _typeof(d.type,defs) || _resolve (d.type,defs) :
		_kinds [d.kind] || ( // note: 'type' and 'element' have to be ignored
			d.elements ? struct :
			d.items ? array : any
		)
	)} catch(e) { throw new Error (
		`circular dependency thru ${d.name} > ${_protos(defs[d.type]).join(' > ')}`
	)}
	// link exposed entities to containing services
	if (d.kind === 'service') {
		const prefix = name+'.'
		for (let each in defs) if (each.startsWith(prefix)) set (defs[each] ,'_service', d)
	}
	return d
}

function _infer (view, defs) {
	const target = cds.infer (view.query, defs)
	return target || _unresolved ('invalid query?', entity)
}

function _protos (p) {
	for (var chain=[]; p && p.name; p = p.__proto__) chain.push (p.name)
	return chain
}

const _target = (x,d,defs) => typeof x === 'string' ? _resolve(x,defs) : _link(x,'<inline>',d,defs)
const _resolve = (x,defs) => defs[x] || _builtin[x] || (defs[x] = _unresolved(x))
const _typeof = ({ref},defs) => { if (ref) {
	let [head,...tail] = ref, t = _resolve (head,defs)
	for (let next of tail)  t = t.elements && t.elements[next] || _unresolved(ref.join(':'))
	return t
}}
const _unresolved = (x,p=any) => ({name:x, __proto__:p, isUnresolved:true})
