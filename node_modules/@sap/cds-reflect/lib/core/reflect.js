const { Association, entity, any } = require('./csn').classes
const _is_reflected = Symbol('is reflected'); any.prototype[_is_reflected] = true
const _class = Symbol(); any[_class] = true


/** @returns { ReflectedModel & Association & entity } */
function cds_reflect (x,_link) {
	return cached.at(x) || cached.add (x,
		is.Model(x) ? new ReflectedModel (x,_link) :
		is.Association(x) ? new Association (x) :
		is.entity(x) ? new entity (x) :
		new any (x)
	)
}


class ReflectedModel extends any {

	constructor (csn, _link) {
		if (csn) { // called without args by compiler during deep clones
			Object.setPrototypeOf (csn, ReflectedModel.prototype)
			if (!_link)  csn.forall ((d,name,parent) => {
				d.kind || set (d,'kind', parent ? 'element' : d.query ? 'entity' : 'type')
				d.name || set (d,'name', name)
				parent && set (d,'parent', parent)
			})
		} else csn = super()
		return csn
	}

	*each (x, defs=this.definitions, pick=is(x)) {
		for (let d in defs) if (pick(defs[d])) yield defs[d]
	}

	all (x, defs=this.definitions, pick=is(x)) {
		const found=[]; for (let d in defs) if (pick(defs[d])) found.push (defs[d])
		return found
	}

	find (x, defs=this.definitions, pick=is(x)) {
		for (let d in defs) if (pick(defs[d])) return defs[d] //> first match
	}

	map (x, visit) {
		if (!visit) [ x, visit ] = [ is.any, x ]
		return this.all(x) .map (visit)
	}

	foreach (x, visit, defs=this.definitions, pick=is(x)) {
		if (!visit) [ visit, pick ] = [ x, is.any ]
		for (let d in defs) if (pick(defs[d]))  visit (defs[d], d)
		return this
	}

	forall (x, visit, defs=this.definitions, pick=is(x)) {
		if (!visit) [ visit, pick ] = [ x, is.any ]
		_recurse (defs)
		function _recurse (defs, parent) {
			for (let each in defs) {
				const d = defs[each]
				if (pick(d))  visit (d, each, parent, defs)
				_recurse (own(d,'elements'), d)
				_recurse (own(d,'actions'), d)
				_inline (own(d,'target'))
				_inline (own(d,'via'))
			}
		}
		function _inline(d) {
			if (typeof d === 'object')  _recurse (d.elements,d)
		}
		return this
	}

	childrenOf (x, filter=is.any, property) {
		let ns = !x ? '' : typeof x === 'string' ? x : x.namespace || x.name || '';  if (ns)  ns += '.'
		const children = (ns) => !ns ? children : this.childrenOf (ns,filter)
		const defs = this.definitions
		for (let fqn in defs) if (fqn.startsWith(ns)) {
			let d = defs[fqn], rn = fqn.slice(ns.length)
			if (filter(d,rn))  children[rn] = defs[fqn]
		}
		if (property)  this.set (property, children)
		return children
	}

	get exports() { return this.childrenOf (this, (_,rn)=>!rn.includes('.'), 'exports') }
	get entities() { return this.childrenOf (this, is.entity, 'entities') }
	get services() { return this.set ('services', this.all (is.service)) }

	set (p,v) { set(this,p,v); return v }
}


const set = (o,p,v) => Object.defineProperty (o,p,{value:v,configurable:1,writable:1})

const is = Object.assign (x => {
	if (!x) throw new Error ('missing filter for model reflection: '+ x)
	if (x[_class])  return  d => d instanceof x || d.kind == x.name
	if (typeof x === 'function')  return x
	if (typeof x === 'string')  return  is[x] || (d => d.kind === x)
	throw new Error ('invalid filter for model reflection: '+ x)
},{
	Model: d => d.definitions !== undefined || d.extensions !== undefined || d.version !== undefined,
	struct: d => d.elements !== undefined  ||  d.query !== undefined,
	entity: d => d.kind === 'entity'  ||  d.kind === 'view'  ||  d.query !== undefined,
	view: d => d.query !== undefined,
	service: d => d.kind === 'service',
	Association: d => d.type === 'cds.Association' || d.type === 'cds.Composition',
	Composition: d => d.type === 'cds.Composition',
	any: ()=>true,
})

const own = (d,p) => {
	const pd = Reflect.getOwnPropertyDescriptor(d,p)
	return pd ? pd.value || pd.get(d) : undefined
}

const cached = new class extends WeakMap {
	at (ref) {
		return ref[_is_reflected] ? ref : this.get(ref)
	}
	add (ref, entry) {
		set (entry, _is_reflected, true)
		this.set (ref,entry)
		return entry
	}
}

module.exports = Object.assign (cds_reflect, { own, set })
