const { convertErrorCodeToString } = require('../util')

class HdbStatement {
  /**
   * Create an HdbStatement object.
   *
   * @param {object} statement - Statement object obtained from hdb.
   * @param {string} sql - SQL string to be passed to SqlError
   * @param {object} hanaStream - hanaStream object if using hana-client
   * @param {boolean} autoDrop - Determines whether statement should be dropped automatically after execute. Defaults to false.
   */
  constructor (statement, sql, hanaStream, autoDrop = false) {
    this._stmt = statement
    this._sql = sql
    this._hanaStream = hanaStream
    this._autoDrop = autoDrop
  }

  /**
   * Execute prepared statement.
   *
   * Values are provided as an array.
   * In order to insert multiple rows with a single execute
   * values have to be provided as arrays of values composed in an outer array.
   *
   * Method returns a result object.
   * For example, in case of SELECT the result object contains a result-set.
   * In case of INSERT/DELETE the result object contains a number of affected rows.
   * In case of multiple (batch) insert the result object is an array like [1, 1, ..., 1]
   *
   * @example
   * single insert: execute([1, 'a'])
   * multiple insert: execute([[1, 'a'], [2, 'b']])
   *
   * @param {array} values - Values to be set in the prepared SQL statement.
   * @returns {Promise} Promise that resolves with the result object if successful and rejects if not.
   * Result object can be undefined.
   */
  execute (values) {
    return new Promise((resolve, reject) => {
      this._stmt[this._getFunctionName(values.streaming)](values, (err, result) => {
        if (err) {
          convertErrorCodeToString(err)
          err.query = this._sql
          this._dropIfSpecified()

          return reject(err)
        }

        if (Array.isArray(result) && result.length !== 0 && !result.some(isNaN)) {
          result = result.reduce((pv, cv) => pv + cv, 0)
        }

        if (values.streaming) {
          if (this._hanaStream) {
            return this._getReadObjectHanaClient(result, resolve, reject)
          }

          const rows = []
          const objStream = result.createObjectStream()

          objStream
            .on('readable', this._getReadObjectHdb(objStream, rows))
            .once('error', this._getErrorObjectHdb(reject))
            .once('end', this._getEndObjectHdb(rows, resolve))
        } else {
          this._dropIfSpecified()
          resolve(result)
        }
      })
    })
  }

  /**
   * Manually drop the prepared statement. Should be used, for instance, when autoDrop is set to false.
   */
  drop () {
    this._stmt.drop()
  }

  _dropIfSpecified () {
    if (this._autoDrop) {
      this.drop()
    }
  }

  _getReadObjectHdb (result, rows) {
    return () => {
      const row = result.read()

      if (row) {
        for (const key of Object.keys(row)) {
          if (typeof row[key] === 'object' && row[key] !== null) {
            row[key] = row[key].createReadStream()
            row[key].on('end', () => {
              this._dropIfSpecified()
            })
            row[key].on('error', () => {
              this._dropIfSpecified()
            })
          }
        }

        rows.push(row)
      }
    }
  }

  _getEndObjectHdb (rows, resolve) {
    return () => {
      return resolve(rows)
    }
  }

  _getErrorObjectHdb (reject) {
    return err => {
      return reject(err)
    }
  }

  _getColumnInfo (result) {
    const columnInfo = []

    for (let i = 0, length = result.getColumnCount(); i < length; i++) {
      columnInfo.push({
        name: result.getColumnInfo()[i].originalColumnName,
        lob: result.getColumnInfo()[i].nativeTypeName === 'BLOB'
      })
    }

    return columnInfo
  }

  _getResultSetRow (result, columnInfo) {
    const res = {}

    for (let i = 0, length = result.getColumnCount(); i < length; i++) {
      if (columnInfo[i].lob) {
        res[columnInfo[i].name] = this._hanaStream.createLobStream(result, i, { readSize: 1024000 })
        res[columnInfo[i].name].on('end', () => {
          this._dropIfSpecified()
        })
        res[columnInfo[i].name].on('error', () => {
          this._dropIfSpecified()
        })
      } else {
        res[columnInfo[i].name] = result.getValue(i)
      }
    }

    return res
  }

  // The method createObjectStream does not work in hana-client as expected.
  // It provides the complete LOBs and not the streams.
  // The resultset should be constructed like bellow.
  _getReadObjectHanaClient (result, resolve, reject) {
    const resultSet = []
    const columnInfo = this._getColumnInfo(result)

    let next = true

    while (next) {
      next = result.next((err, ret) => {
        if (err) {
          return reject(err)
        }

        if (ret) {
          resultSet.push(this._getResultSetRow(result, columnInfo))
        }

        if (!next) {
          resolve(resultSet)
        }
      })
    }
  }

  _getFunctionName (streaming) {
    if (streaming) {
      if (this._hanaStream) {
        return 'executeQuery'
      }

      return 'execute'
    }

    return 'exec'
  }
}

module.exports = HdbStatement
