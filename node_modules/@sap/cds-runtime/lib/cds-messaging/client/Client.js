const FeatureNotSupportedError = require('../utils/FeatureNotSupported')
const InProcessEMClient = require('./inProcessEMClient')
const MockEMClient = require('./mockEMClient')
const { resolve } = require('../utils/thenable')
const os = require('os')
const path = require('path')
const MAX_NUMBER_RECONNECTS = 100000

class Client {
  /**
   * Constructs an Enterprise Messaging Client for sending and receiving messages using SAP Enterprise Messaging framework and AMQP Client Library.
   * @param {Object} connectionOptions - binding configurations for the queue(s).
   */
  constructor (connectionOptions) {
    this._options = this._getOptions(connectionOptions)
    this._clientEM = this._getClient()
    this._reconnectAttempts = 0
    this._senderStream = null
  }

  _getClient () {
    switch (this._options.kind) {
      case 'enterprise-messaging':
        const ClientAmqp = this._getPackage('@sap/xb-msg-amqp-v100').Client
        return new ClientAmqp(this._options.amqp)
      case 'file-based-messaging':
        return new MockEMClient(this._options)
      case 'in-process-messaging':
        return new InProcessEMClient(this._options)
      default:
        throw new Error(`'${this._options.kind}' is not a valid messaging kind.`)
    }
  }
  /**
   * Dummy .isValid function for pool
   */
  isValid () {
    return true
  }

  /**
   * Dummy .end function for pool
   */
  end () {
    return this.disconnect()
  }

  _periodicallyReconnect () {
    setTimeout(() => {
      this.connect().catch(() => {
        this._reconnectAttempts++
        console.log(
          `Connection to Enterprise Messaging Client at ${
            this._options.amqp.uri
          } lost: Unsuccessful attempt to reconnect (${this._reconnectAttempts}).`
        )
        if (this._reconnectAttempts < MAX_NUMBER_RECONNECTS) this._periodicallyReconnect()
      })
    }, 1500)
  }

  /**
   * Establishes connection to the server using AMQP Client Library.
   * Automatic reconnect will follow in case connection is lost.
   * @public
   */
  connect () {
    return new Promise((resolve, reject) => {
      this._clientEM
        .on('connected', async () => {
          this._removeConnectedListeners()
          this._reconnectAttempts = 0
          resolve(this)
        })
        .on('error', err => {
          this._removeAllListeners()
          reject(err)
        })
        .on('disconnected', async () => {
          this._removeAllListeners()
          if (this._options.kind === 'enterprise-messaging') this._periodicallyReconnect()
        })

      this._clientEM.connect()
    })
  }

  /**
   * Disconnects from the server using AMQP Client Library
   * @public
   */
  disconnect () {
    return new Promise((resolve, reject) => {
      this._clientEM.removeAllListeners('disconnected')
      this._clientEM
        .on('disconnected', () => {
          this._removeAllListeners()
          resolve()
        })
        .on('error', err => {
          this._removeAllListeners()
          reject(err)
        })

      this._clientEM.disconnect()
    })
  }

  /**
   * Publishes messages to the configured endpoints.
   * @param {Object} message to be sent to the queue(s).
   * @param {String} target to be sent to the queue(s).
   * @param {Object} headers to be sent to the queue(s).
   * @public
   */
  emit (message, target) {
    const payload = Buffer.from(JSON.stringify(message), 'utf8')
    const msg = {
      payload,
      target: {
        properties: {
          to: target
        }
      }
    }

    ;(this._pendingOperations || resolve()).then(() => {
      const senderStream =
        this._senderStream ||
        (this._senderStream = this._clientEM.sender(`${this._options.appName}-${this._options.appID}`).attach(''))
      senderStream.write(msg)
    })
  }

  /**
   * Receives messages from the configured endpoints.
   * @param {Function} dataHandler handler for the received data.
   * @param {Function} errHandler handler in case of errors.
   * @param {String} source Source to register, e.g. 'queue:myQueue'
   * @public
   */
  on (dataHandler, errHandler, source) {
    if (!source) {
      throw new Error('Cannot register handlers if no source is configured.')
    }
    ;(this._pendingOperations || resolve()).then(() => {
      const receiver = source.split(':')[1]

      this._clientEM
        .receiver(receiver)
        .attach(source)
        .on('data', dataHandler)
      if (errHandler) {
        this._clientEM.on('error', errHandler)
      }
    })
  }

  /**
   * VCAP_SERVICES does not provide the format, which is used by the client.
   * Ensure format, but do not break if it is aligned in the future.
   * @param {Object} oa2 - raw connect options as provided by environment
   * @returns {{endpoint: string, client: string, secret: string, granttype: string}}
   * @private
   */
  _getOAuth2 (oa2) {
    return {
      client: oa2.client || oa2.clientid,
      secret: oa2.secret || oa2.clientsecret,
      endpoint: oa2.endpoint || oa2.tokenendpoint,
      granttype: oa2.granttype
    }
  }

  _removeAllListeners () {
    this._clientEM.removeAllListeners('disconnected')
    this._clientEM.removeAllListeners('error')
    this._clientEM.removeAllListeners('connected')
  }

  _removeConnectedListeners () {
    this._clientEM.removeAllListeners('error')
    this._clientEM.removeAllListeners('connected')
  }

  _getOptions (connectionOptions) {
    const options = {}
    options.kind =
      connectionOptions.kind === 'messaging'
        ? connectionOptions.credentials &&
          connectionOptions.credentials.management &&
          connectionOptions.credentials.messaging
          ? 'enterprise-messaging'
          : 'file-based-messaging'
        : connectionOptions.kind

    if (options.kind === 'enterprise-messaging') {
      if (
        !connectionOptions ||
        !connectionOptions.credentials ||
        !connectionOptions.credentials.management ||
        !connectionOptions.credentials.messaging
      ) {
        throw new Error('No messaging credentials found: You need to bind your app to a message broker.')
      }

      const enterpriseMessagingOptions = {
        namespace: connectionOptions.credentials.namespace,
        amqp: connectionOptions.credentials.messaging.filter(entry => entry.protocol.includes('amqp10ws'))[0],
        management: connectionOptions.credentials.management[0]
      }
      enterpriseMessagingOptions.amqp.oa2 = this._getOAuth2(enterpriseMessagingOptions.amqp.oa2)

      Object.assign(options, enterpriseMessagingOptions)
    }

    const vcapApplication = process.env.VCAP_APPLICATION && JSON.parse(process.env.VCAP_APPLICATION)
    options.appName = (vcapApplication && vcapApplication.application_name) || 'CAP'
    options.appID = (vcapApplication && vcapApplication.application_id) || '00000000'
    options.mock = this._getFile(connectionOptions.credentials && connectionOptions.credentials.file, options)

    return options
  }

  _getFile (file, options) {
    return options.kind === 'file-based-messaging'
      ? file && file !== true && file !== 'default'
        ? file
        : path.join(os.tmpdir(), 'cds-message-box')
      : null
  }

  _getPackage (packageName) {
    try {
      return require(packageName)
    } catch (err) {
      throw new Error(`The package '${packageName}' is required to use enterprise messaging.`)
    }
  }

  /**
   * Not supported .stream function
   *
   * @throws FeatureNotSupported
   */
  stream () {
    return Promise.reject(new FeatureNotSupportedError())
  }

  /**
   * Not supported .foreach function
   *
   * @throws FeatureNotSupported
   */
  foreach () {
    return Promise.reject(new FeatureNotSupportedError())
  }

  /**
   * Not supported .deploy function
   *
   * @throws FeatureNotSupported
   */
  deploy () {
    return Promise.reject(new FeatureNotSupportedError())
  }

  /**
   * Dummy .setUser function
   */

  setUser () {}

  /**
   * Dummy .setLocale function
   */
  setLocale () {}

  /**
   * Dummy .setCSN function
   */
  setCSN (csn) {
    this._csn = csn
  }

  /**
   * Dummy .setContext function
   */
  setContext (context) {
    this._context = context
  }
}

module.exports = Client
