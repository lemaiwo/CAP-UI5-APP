const fs = require('fs')
const { resolve } = require('../utils/thenable')
const EventEmitter = require('events')
const DEBUG = /y|messaging/.test(process.env.DEBUG)

let loggedInfo = false

class MockEMClient extends EventEmitter {
  constructor (options) {
    super()
    this._options = options
    this._processing = false
    this._ownSubscriptions = new Set()
    this._lockfile = this._options && `${this._options.mock}.lock`
    this._emitChain = null

    if (!loggedInfo) {
      // TODO: Use logger
      console.log(`[cds] - mocking Messaging using file: ${this._options.mock}`)
      loggedInfo = true
    }
  }

  _trimmedLinesFromData (data) {
    return (
      data &&
      data
        .trim()
        .split('\n')
        .map(line => line && line.trim())
    )
  }

  disconnect () {
    DEBUG && console.trace('STOP watching:', this._options.mock)
    this._watcher.close()
    this.emit('disconnected')
    return Promise.resolve(this)
  }

  sender (key) {
    return this
  }

  attach (target) {
    return this
  }

  write (msg) {
    if (process.env.NODE_ENV === 'production') {
      // TODO: Use logger
      console.warn('[cds] - File-based-messaging should not be used in a productive environment.')
    }
    if (this._options && this._options.mock && this._options.mock) {
      const plain = String.fromCharCode.apply(null, new Uint8Array(msg.payload))
      const toWrite = `\n${msg.target.properties.to} ${plain}`

      this._writeFile(toWrite)
    }
  }

  _writeFile (toWrite) {
    try {
      fs.statSync(this._lockfile)
      setTimeout(() => this._writeFile(toWrite), 10)
    } catch (err) {
      // no lock exists
      this._touchSync(this._lockfile)
      fs.appendFileSync(this._options.mock, toWrite)
      fs.unlinkSync(this._lockfile)
    }
  }

  receiver () {
    return this
  }

  end () {
    return this
  }

  connect () {
    if (this._options && this._options.mock && this._options.mock) {
      fs.appendFileSync(this._options.mock, ' ')
      DEBUG && console.trace('START watching:', this._options.mock)
      this._watcher = fs.watch(this._options.mock, event => {
        this._whenFileIsChanged(event)
      })
      process.on('shutdown', () => this.disconnect())
      // trigger initial change
      this._triggerWatchCycle(this._options.mock)
      this.emit('connected')
    }
    return this
  }

  _processLines (lines, idx = 0) {
    const processedLine = lines && lines[idx]
    const [subjectString, ...rest] = processedLine && processedLine.split(' ')

    if (!this._ownSubscriptions.has(subjectString)) {
      // ignore if no subscription exists
      const newIdx = idx + 1
      if (newIdx < lines.length) {
        this._processLines(lines, newIdx)
      } else {
        this._processing = false
      }
      return
    }
    const value = rest.join(' ')
    if (value && subjectString) {
      const subject = subjectString.replace('topic:', '')
      const chunks = Buffer.from(value)
      const source = this._options.mock
      this._emitAndTriggerCycle(source, processedLine, chunks, subject)
    }
  }

  _whenFileIsChanged (event) {
    if (event === 'error') return this.disconnect()
    // Too many events are triggered.
    // This is a known issue.
    // The following lines prevent firing events too often
    // and make the operation (psuedo) atomic.
    // After the operation, a file change is triggered to start a new cycle.
    if (!this._processing) {
      this._processing = true
      try {
        const data = fs.readFileSync(this._options.mock, 'utf-8')
        if (!data || !data.trim()) {
          this._processing = false
          return
        }
        const lines = this._trimmedLinesFromData(data)
        this._processLines(lines)
      } catch (err) {}
    }
  }

  addSubscription (topic) {
    if (process.env.NODE_ENV === 'production') {
      console.warn('File-based-messaging should not be used in a productive environment.')
    }
    this._ownSubscriptions.add(`topic:${topic}`)
  }

  _emitAndTriggerCyclePromise (source, processedLine, chunks, subject) {
    return new Promise((resolve, reject) => {
      this.emit('data', {
        done: () => {
          this._afterDone(source, processedLine)
          resolve()
        },
        failed: () => {
          this._afterFailed(source, processedLine)
          resolve()
        },
        payload: {
          chunks: [chunks]
        },
        source: {
          properties: {
            subject
          }
        }
      })
    })
  }

  _emitAndTriggerCycle (source, processedLine, chunks, subject) {
    this._emitChain = (this._emitChain || resolve()).then(() =>
      this._emitAndTriggerCyclePromise(source, processedLine, chunks, subject)
    )
  }

  _afterFailed (source, processedLine) {
    // Also remove failed messages
    this._createLockModifyUnlock(source, processedLine)
  }

  _removeProcessedLineSync (source, processedLine) {
    const data = fs.readFileSync(source, 'utf-8')
    const lines = this._trimmedLinesFromData(data)
    if (lines) {
      this._removeUsedLine(lines, processedLine)
      fs.writeFileSync(source, lines.join('\n'))
    }
  }

  _createLockModifyUnlock (source, processedLine) {
    try {
      fs.statSync(this._lockfile)
      setTimeout(() => this._createLockModifyUnlock(source, processedLine), 50)
    } catch (err) {
      this._touchSync(this._lockfile)
      this._removeProcessedLineSync(source, processedLine)
      fs.unlinkSync(this._lockfile)
      this._processing = false
      this._triggerWatchCycle(source)
    }
  }

  _noOp () {
    return () => {}
  }

  _afterDone (source, processedLine) {
    this._createLockModifyUnlock(source, processedLine)
  }

  _triggerWatchCycle (source) {
    fs.appendFile(source, ' ', this._noOp)
  }

  _removeUsedLine (lines, processedLine) {
    lines.splice(lines.indexOf(processedLine), 1)
  }

  _touchSync (filename) {
    fs.closeSync(fs.openSync(filename, 'w'))
  }
}

module.exports = MockEMClient
