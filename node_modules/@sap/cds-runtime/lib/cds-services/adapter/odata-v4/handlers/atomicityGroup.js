/**
 * Start of an atomicity group of $batch
 * @return {Function}
 */
const start = (odataContext, done) => {
  odataContext.applicationData.doNotFinishTransaction = true

  if (odataContext.id) {
    odataContext.applicationData.eventEmitterOfAtomicityGroup =
      odataContext.applicationData.eventEmitterOfAtomicityGroup || new Map()

    odataContext.applicationData.eventEmitterOfAtomicityGroup.set(odataContext.id, [])
  }

  done()
}

const _dispatchCollectedEvents = (odataContext, err) => {
  if (odataContext.id) {
    odataContext.applicationData.eventEmitterOfAtomicityGroup.get(odataContext.id).forEach(emitter => {
      emitter.dispatch(err)
    })
  }
}

/**
 * End of an atomicity group of $batch
 * @return {Function}
 */
const end = async (odataErr, odataContext, done) => {
  // Might not be added or already removed. In any case means no DB client left.
  if (!odataContext.applicationData || !odataContext.applicationData.endTransactionIfConnected) {
    done()
    return
  }

  const command = odataErr || odataContext.failedRequests.length > 0 ? 'ROLLBACK' : 'COMMIT'
  delete odataContext.applicationData.doNotFinishTransaction

  try {
    await odataContext.applicationData.endTransactionIfConnected(command, {
      _txId: odataContext.id,
      _: { shared: odataContext.applicationData }
    })

    _dispatchCollectedEvents(odataContext)

    done()
  } catch (err) {
    _dispatchCollectedEvents(odataContext, err)

    done(err)
  }
}

module.exports = {
  start,
  end
}
