const { isDraftEnabled } = require('../../../../common/utils/draft')

const QueryOptions = require('@sap/odata-server').QueryOptions
const getColumns = require('../../../services/utils/columns')
const { addKeysToWhere, enhanceCqnWithSubSelects, isNavigation, isPathSupported } = require('./selectHelper')
const { isViewWithParams, enhanceCqnWithParams, validationQuery } = require('./selectHelper')
const { getFeatureNotSupportedError } = require('../../../util/errors')
const { ensureUnlocalized } = require('../../../services/utils/draftUtils')
const ExpressionToCQN = require('./ExpressionToCQN')
const orderByToCQN = require('./orderByToCQN')
const selectToCQN = require('./selectToCQN')
const searchToCQN = require('./searchToCQN')
const applyToCQN = require('./applyToCQN')
const topSkipToCQN = require('./topSkipToCQN')
const topSkipWithPaginationToCQN = require('./topSkipWithPaginationToCQN')
const { _expand } = require('../utils/handlerUtils')
const { isSingleton } = require('../utils/handlerUtils')

const {
  COUNT,
  ENTITY,
  ENTITY_COLLECTION,
  NAVIGATION_TO_MANY,
  NAVIGATION_TO_ONE,
  PRIMITIVE_PROPERTY,
  VALUE,
  SINGLETON
} = require('@sap/odata-server').uri.UriResource.ResourceKind

const SUPPORTED_SEGMENT_KINDS = [
  ENTITY,
  ENTITY_COLLECTION,
  NAVIGATION_TO_ONE,
  NAVIGATION_TO_MANY,
  PRIMITIVE_PROPERTY,
  COUNT,
  VALUE,
  SINGLETON
]

const _filter = (model, entity, uriInfo, queryOptions, cqn) => {
  if (queryOptions && queryOptions.$filter) {
    const alias = cqn.SELECT.from.as
    cqn.where(new ExpressionToCQN(entity, model, alias).parse(uriInfo.getQueryOption(QueryOptions.FILTER)))
  }
}

const _includeBrackets = string => {
  let quotes = 0

  for (let i = 0, length = string.length; i < length; i++) {
    if (string.charAt(i) === '"' && string.charAt(i - 1) !== '\\') {
      quotes = quotes === 0 ? quotes + 1 : quotes - 1
    }
    if (string.charAt(i) === '(' && quotes === 0) {
      return true
    }
  }

  return false
}

const _search = (reflectedEntity, uriInfo, cqn, queryOptions) => {
  const search = uriInfo.getQueryOption(QueryOptions.SEARCH)
  if (search) {
    if (_includeBrackets(queryOptions.$search)) {
      throw getFeatureNotSupportedError(`Parenthesis operator in query option "${QueryOptions.SEARCH}"`)
    }

    const is$apply = uriInfo.getQueryOption(QueryOptions.APPLY)

    let columns = []
    const aggregates = []

    if (is$apply) {
      cqn.SELECT.columns.forEach(c => {
        const csnColumn = reflectedEntity.elements[c.ref[c.ref.length - 1]]
        csnColumn ? columns.push(csnColumn) : aggregates.push({ name: c.ref[c.ref.length - 1] })
      })
    } else {
      columns = getColumns(reflectedEntity, false, true)
    }

    const allowedTypes = ['cds.String', 'cds.UUID', 'cds.Date', 'cds.Time', 'cds.DateTime', 'cds.Timestamp']
    const allowedColumns = columns.filter(column => allowedTypes.includes(column.type))
    const filteredColumns = allowedColumns.filter(column => column['@Search.defaultSearchElement'])
    const columnsToBeSearched = filteredColumns.length > 0 ? filteredColumns : allowedColumns

    if (is$apply) {
      columnsToBeSearched.push(...aggregates)
    }

    cqn.where(...searchToCQN(columnsToBeSearched.map(column => column.name), search))
  }
}

const _orderby = (reflectedEntity, uriInfo, cqn) => {
  orderByToCQN(reflectedEntity, cqn.SELECT, uriInfo.getQueryOption(QueryOptions.ORDERBY))
}

const _getKeysFromObject = keysObject => {
  const keys = []
  for (const key of Object.keys(keysObject)) {
    if (keysObject[key].foreignKeys) {
      // OLD CSN
      for (const foreignKey of Object.keys(keysObject[key].foreignKeys)) {
        keys.push(`${key}_${foreignKey}`)
      }
    } else if (keysObject[key].keys) {
      for (const foreignKey of keysObject[key].keys) {
        keys.push(`${key}_${foreignKey.ref[0]}`)
      }
    } else {
      keys.push(key)
    }
  }

  return keys
}

const _select = (queryOptions, keys, entity) => {
  if (queryOptions && queryOptions.$select) {
    const keyColumns = []
    if (keys) {
      keyColumns.push(..._getKeysFromObject(keys))
    }

    return selectToCQN(queryOptions.$select, keyColumns, entity)
  }

  return []
}

const _apply = (uriInfo, queryOptions, entity, model) => {
  if (queryOptions && queryOptions.$apply) {
    return applyToCQN(uriInfo.getQueryOption(QueryOptions.APPLY), entity, model)
  }
  return {}
}

const _topSkip = (queryOptions, cqn) => {
  if (queryOptions && (queryOptions.$top || queryOptions.$skip)) {
    topSkipToCQN(cqn, {
      top: queryOptions.$top ? parseInt(queryOptions.$top) : Number.MAX_SAFE_INTEGER,
      skip: queryOptions.$skip ? parseInt(queryOptions.$skip) : undefined
    })
  }
}

const _getPropertyParam = pathSegments => {
  const index = pathSegments[pathSegments.length - 1].getKind() === VALUE ? 2 : 1
  const prop = pathSegments[pathSegments.length - index].getProperty()

  return prop && prop.getName()
}

const _isCollectionOrToMany = kind => {
  return kind === ENTITY_COLLECTION || kind === NAVIGATION_TO_MANY
}

const _isCount = kind => {
  return kind === COUNT
}

const _extendCqnWithApply = (cqn, apply) => {
  if (apply.groupBy) {
    apply.groupBy.forEach(col => cqn.groupBy(col))
  }
  if (apply.filter) {
    cqn.where(apply.filter)
  }
}

const _cleanupForApply = (apply, cqn) => {
  if (Object.keys(apply).length !== 0) {
    // cleanup order by columns which are not part of columns
    const selectColumns = cqn.SELECT.columns.map(c => c.as || c.ref[c.ref.length - 1])
    if (cqn.SELECT.orderBy) {
      const newOrderBy = cqn.SELECT.orderBy.filter(o => o.ref && selectColumns.includes(o.ref[o.ref.length - 1]))
      // remove path expressions because subselect only uses columns
      cqn.SELECT.orderBy = newOrderBy.map(col => ({ ref: [col.ref[col.ref.length - 1]], sort: col.sort }))
    }

    if (!cqn.SELECT.orderBy || !cqn.SELECT.orderBy.length) {
      delete cqn.SELECT.orderBy
    }
  }
}

const _isSet = segment => {
  return segment.getNavigationProperty() && segment.getNavigationProperty().getName() === 'Set'
}

const _checkViewWithParamCall = (isView, segments, kind, name) => {
  if (!isView) {
    return
  }
  if (segments.length < 2) {
    throw new Error(`Incorrect call to a view with parameter "${name}"`)
  }
  // if the last segment is count, check if previous segment is Set, otherwise check if the last segment equals Set
  if (!_isSet(segments[segments.length - (_isCount(kind) ? 2 : 1)])) {
    throw new Error(`Incorrect call to a view with parameter "${name}"`)
  }
}

const enhanceCqnForNavigation = (segments, isView, cqn, service, SELECT, kind, _) => {
  if (isNavigation(segments) && !isView) {
    enhanceCqnWithSubSelects(cqn, segments, service.model, SELECT)

    if (kind === NAVIGATION_TO_MANY || kind === NAVIGATION_TO_ONE) {
      _.validationQuery = validationQuery(segments, service.model, SELECT)
    }
  }
}

const _addKeysToSelectIfNoStreaming = (entity, select, streaming) => {
  if (!streaming) {
    for (const k of Object.values(entity.keys)) {
      if (!k.is2one && !k.is2many && !select.includes(k.name)) {
        select.push(k.name)
      }
    }
  }
}

/**
 * Transform odata READ request into a CQN object.
 *
 * @param {Object} service - Service, which will process this request.
 * @param {object} context - Contains request information and utility methods like statements.
 * @param {object} req - An odata request.
 * @private
 */
const readToCQN = (service, { statements: { SELECT }, target, _ }, req) => {
  const uriInfo = req.getUriInfo()
  const segments = uriInfo.getPathSegments()
  isPathSupported(SUPPORTED_SEGMENT_KINDS, segments)

  const queryOptions = req.getQueryOptions()
  const reflectedEntity = service.model.definitions[ensureUnlocalized(target.name)]
  const entityName = reflectedEntity.name
  const propertyParam = _getPropertyParam(segments)
  const apply = _apply(uriInfo, queryOptions, reflectedEntity, service.model)
  const select = _select(queryOptions, reflectedEntity.keys, reflectedEntity)
  const expand = _expand(reflectedEntity, uriInfo)

  // TODO: Correct implementation of the combined apply, select and expand as described in
  // http://docs.oasis-open.org/odata/odata-data-aggregation-ext/v4.0/odata-data-aggregation-ext-v4.0.html
  // part 3.16

  if (Object.keys(apply).length) {
    if (apply.aggregations) {
      select.push(...apply.aggregations)
    }

    if (apply.groupBy) {
      select.push(...apply.groupBy)
    }
  }

  if (propertyParam) {
    select.push(propertyParam)

    // add keys if no streaming, TODO: what if streaming via to-one
    _addKeysToSelectIfNoStreaming(reflectedEntity, select, _.streaming)
  }

  if (select.length === 0) {
    select.push(...getColumns(reflectedEntity, true, true))
  }

  if (expand.length !== 0) {
    select.push(...expand)
  }

  // keep target as input because of localized view
  let cqn = SELECT.from(target, select)
  if (isSingleton(reflectedEntity)) cqn.SELECT.one = true
  const isView = isViewWithParams(cqn)
  const kind = segments[segments.length - 1].getKind()

  // views with parameters should always be called with /Set in URL
  _checkViewWithParamCall(isView, segments, kind, target.name)
  enhanceCqnForNavigation(segments, isView, cqn, service, SELECT, kind, _)

  enhanceCqnWithParams(cqn, segments, service.model.definitions[entityName], isView)
  addKeysToWhere(segments, cqn, isDraftEnabled(service.model.definitions[entityName]), isView)

  if (Object.keys(apply).length !== 0) {
    _extendCqnWithApply(cqn, apply)

    // build subselect for apply
    const newColumns = cqn.SELECT.columns.map(col => col.as || col.ref[col.ref.length - 1])
    cqn = SELECT.from(cqn, newColumns)
  }

  if (_isCollectionOrToMany(kind) || _isCount(kind)) {
    _filter(service.model, reflectedEntity, uriInfo, queryOptions, cqn)
    _search(reflectedEntity, uriInfo, cqn, queryOptions)
  }

  if (_isCollectionOrToMany(kind)) {
    _orderby(reflectedEntity, uriInfo, cqn)
    _topSkip(queryOptions, cqn)
    topSkipWithPaginationToCQN(uriInfo, cqn)
  }

  _cleanupForApply(apply, cqn)

  return cqn
}

module.exports = readToCQN
