const { getFeatureNotSupportedError } = require('../../../util/errors')
const { isStreaming } = require('../utils/stream')

const _keysAndValues = segment => {
  const keysAndValues = {}
  for (const value of segment.getKeyPredicates()) {
    keysAndValues[value.getEdmRef().getName()] = value.getText()
  }
  return keysAndValues
}

const _keyValueObject = (target, data) => {
  return Object.values(target.keys)
    .filter(k => !k.is2one && !k.is2many)
    .reduce((prev, curr) => {
      prev[curr.name] = data[curr.name]
      return prev
    }, {})
}
const SUPPORTED_KINDS = ['NAVIGATION.TO.ONE', 'ENTITY', 'SINGLETON']
/**
 * Transform odata UPDATE request into a CQN object.
 *
 * @param context - Contains request information and utility methods like statements.
 * @param req - An odata request.
 * @throws Error - If invalid segment kind provided
 * @private
 */
const updateToCQN = (context, req) => {
  const segments = req.getUriInfo().getPathSegments()
  const segment = segments[segments.length - 1]
  const streaming = isStreaming(segments)

  if (SUPPORTED_KINDS.includes(segment.getKind()) || streaming) {
    const cqn = context.statements.UPDATE(context.target).data(context.data)

    if (segment.getKind() !== 'SINGLETON') {
      // FIXME: need to support update on to-one association
      // REVISIT: Why go through OData request again if we have info in context.data?
      // REVISIT: Can we use context.data for streaming as well?
      const keysAndValues = streaming
        ? _keysAndValues(segments[segments.length - 2])
        : _keyValueObject(context.target, context.data)

      for (const key in keysAndValues) {
        cqn.where(key, '=', keysAndValues[key])
      }
    }

    return cqn
  }

  throw getFeatureNotSupportedError(`UPDATE of kind "${segment.getKind()}"`)
}

module.exports = updateToCQN
