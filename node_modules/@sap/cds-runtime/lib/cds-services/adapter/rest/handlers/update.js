const RestContext = require('../utils/RestContext')
const { parseUpdateUrl } = require('../utils/parse-url')
const handleError = require('../utils/handle-error')
const { validationChecks } = require('../utils/validation-checks')
const { contentTypeCheck } = require('../utils/header-checks')
const { base64toBuffer, bufferToBase64 } = require('../utils/binary')

const update = service => {
  return (req, res) => {
    const contentTypeErr = contentTypeCheck(req)
    if (contentTypeErr) return handleError(contentTypeErr, service, res)
    let parsedUrl
    try {
      parsedUrl = parseUpdateUrl(service.entities, req)
    } catch (err) {
      return handleError(err, service, res)
    }

    base64toBuffer(req.body, parsedUrl.segments[0])

    const context = new RestContext(service, parsedUrl, req, res)
    const err = validationChecks(context.event, context.data, context.target)
    if (err) return handleError(err, service, res)

    let processedEvent

    if (Array.isArray(context.query)) {
      const promises = []
      context._.shared.doNotFinishTransaction = true
      for (let i = 0; i < context.query.length; i++) {
        const modifiedContext = { ...context, data: context.data[i], query: context.query[i] }
        promises.push(service.processEvent(modifiedContext))
      }

      processedEvent = Promise.all(promises)
        .then(result => {
          return context._.shared.endTransactionIfConnected('COMMIT', context).then(() => result)
        })
        .catch(err => {
          return context._.shared.endTransactionIfConnected('ROLLBACK', context).then(() => {
            throw err
          })
        })
    } else {
      processedEvent = service.processEvent(context)
    }

    return processedEvent
      .then(result => {
        context.emit('succeeded')
        context.emit('done')

        bufferToBase64(result, parsedUrl.segments[0])
        // FOLLOW-UP: allow mtx to set status code to 202
        // FOLLOW-UP: default is 200
        // res.status(200)
        res.send(result)
      })
      .catch(err => {
        context.emit('failed', err)
        context.emit('done')

        // Hide errors in generic message but log detailed error
        handleError(err, service, res)
      })
  }
}

module.exports = update
