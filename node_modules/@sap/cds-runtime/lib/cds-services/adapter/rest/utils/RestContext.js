const uuid = require('@sap/cds-foss')('uuid/v4')

const BaseContext = require('../../utils/BaseContext')
const restToCqn = require('../rest-to-cqn')
const { getKeyValuePair } = require('./key-value-utils')
const proxifyContext = require('./proxify-context')

class RestContext extends BaseContext {
  constructor (service, parsedUrl, req, res) {
    // set to false to get normal EventEmitter and not delayed
    super(service, false)

    // set _txId so that ops via local clients share a transaction
    this._txId = uuid()

    this._ = { req, res, shared: {} }

    this.setHttpMethod(req.method)

    this.setUserAndAttr(service)

    this.errors = []
    this.event = this._getEvent(parsedUrl, service)

    // TODO: replace with generic solution, target is either the first segment (no associations) or undefined for custom operations
    if (!this._isCustomOperation(parsedUrl.segments[0])) {
      this.target = parsedUrl.segments[0]
    }

    if (this._isCustomOperation(parsedUrl.segments[parsedUrl.segments.length - 1])) {
      // data = parsedUrl.params || _validatedBodyValues(req.body, parsedUrl, this) || {}
      this.data = parsedUrl.params || req.body || {}
    } else {
      this.data = this._getData(parsedUrl, this.target, req)
    }

    Object.defineProperty(this, 'query', {
      configurable: true,
      get: function () {
        const query = restToCqn(service, proxifyContext(this), parsedUrl)
        Object.defineProperty(this, 'query', { value: query, writable: true })
        return query
      },
      set: function (value) {
        Object.defineProperty(this, 'query', { value: value, writable: true })
      }
    })

    this.postPreparation(req)
  }

  _getKeyValues (method, target, keys) {
    if (method === 'CREATE' || (method === 'UPDATE' && !keys)) {
      return {}
    }

    return getKeyValuePair(target, keys)
  }

  /**
   * Get data from odata-v4.
   * READ and DELETE work are retrieved from URL; CREATE and UPDATE from body.
   * For function invocations the URL parameters are set as data.
   * For CREATE and UPDATE annotated columns can be mixed in.
   *
   * @param {string} component - odata-v4 component which processes this request.
   * @param req
   * @param annotatedColumns - in case of insert and update we might have annotated columns for user/now
   * @returns {Object}
   * @private
   */
  _getData ({ method, segments }, target, req) {
    // TODO: what to do by reading collections
    const keyValues = this._getKeyValues(method, target, segments[1])

    if (method === 'READ' || method === 'DELETE') {
      return keyValues
    }

    const data = req.body || {}
    const dataArray = Array.isArray(data) ? data : [data]

    if (req.method === 'POST' || req.method === 'PUT' || req.method === 'PATCH') {
      for (const data of dataArray) {
        this.fillKeyValues(keyValues, data)
      }
    }

    return data
  }

  _isCustomOperation (element) {
    return element.kind === 'action' || element.kind === 'function'
  }

  _getEvent ({ customOperation, method, segments }, service) {
    switch (method) {
      case 'UPDATE':
      case 'DELETE':
        return method
      case 'CREATE':
      case 'READ':
        if (customOperation) {
          const lastSegment = segments[segments.length - 1]
          return customOperation.startsWith('unbound') ? `${service.name}.${lastSegment.name}` : lastSegment.name
        }
        return method
    }
  }
}

module.exports = RestContext
