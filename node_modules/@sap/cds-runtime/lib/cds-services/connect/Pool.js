const genericPool = require('@sap/cds-foss')('generic-pool')
const { resolve } = require('../util/thenable')

const ACQUIRE_TIMEOUT_ERROR =
  'Requesting client from pool timed out. Max pool size is %MAX%, current pool size is %CURRENT%. Increase "acquireTimeoutMillis" for longer waiting time or "max" to create more clients.'

/**
 * Pool to acquire db connection clients.
 */
class Pool {
  /**
   * Creates a Pool according to the given pool settings (minimum and maximum number of clients) and client settings
   * (db client type and connection options).
   *
   * @param {string} poolKey - Identifier the clients are tagged with.
   * @param {string} Client - To be used client.
   * @param {Object} connectionOptions - Pool and Client settings
   * @param {Object} [connectionOptions.pool] - The min and max pool settings.
   * @param {number} [connectionOptions.pool.min] - The minimum number of db connection clients.
   * @param {number} [connectionOptions.pool.max] - The maximum number of db connection clients.
   * @param {number} [connectionOptions.pool.evictionRunIntervalMillis] - The time interval in ms for an eviction check of idle db
   * clients in a pool.
   * @param {number} [connectionOptions.pool.numTestsPerEvictionRun] - The number of db clients to be checked in each eviction run.
   * @param {number} [connectionOptions.pool.softIdleTimeoutMillis] - The time interval in ms until a db client in idle state is
   * considered as 'to be evicted'. Does not evict idle db clients if number of available clients would fall below
   * options.pool.min.
   * @param {number} [connectionOptions.pool.idleTimeoutMillis] - The time interval in ms until a db client in idle state is
   * considered as 'to be evicted'. If number of available clients would fall below options.pool.min it evicts this
   * client and creates a new one to meet options.pool.min.
   * @param {Object} [connectionOptions.credentials] - Credentials how to connect with a client
   * @param {string} [connectionOptions.credentials.host] - Address to the db
   * @param {string} [connectionOptions.credentials.port] - Port for db
   * @param {string} [connectionOptions.credentials.user] - Username for authentication
   * @param {string} [connectionOptions.credentials.password] - Password for authentication
   * @param {string} [connectionOptions.reflectedModel] - Reflected model, that belongs to the data source
   */
  constructor (poolKey, Client, connectionOptions) {
    this._poolKey = poolKey
    this._Client = Client
    this._connectOptions = connectionOptions
    this._pool = genericPool.createPool(this._getPoolFactory(connectionOptions), connectionOptions.pool)
  }

  _getPoolFactory (options) {
    return {
      /**
       * Connects the db client.
       *
       * @returns {Promise}
       * @private
       */
      create: () => {
        const Client = this._Client
        return new Client(options).connect()
      },

      /**
       * Closes the database connection of the client and returns a promise which will be resolved upon success.
       *
       * @returns {Promise}
       * @private
       */
      destroy: client => {
        return client.end()
      },

      /**
       * Validate whether the client is in a valid state and successfully connected to the database or not.
       * @returns {Promise}
       * @private
       */
      validate: client => {
        return resolve(client.isValid())
      }
    }
  }

  _acquireFromPool () {
    return this._pool.acquire().catch(() => {
      const options = this._connectOptions.pool
      throw new Error(ACQUIRE_TIMEOUT_ERROR.replace('%MAX%', options.max).replace('%CURRENT%', this._pool.size))
    })
  }

  /**
   * Acquires a db client from the session.
   * @param {Object} context - Event context of using handler.
   * @param {Object} [model] - CSN of service
   */
  async acquire (context, model) {
    const client = await this._acquireFromPool()

    // add information to client, so it can be returned to correct pool. Pushed down, so extra .then can be avoided
    client._pool = this

    // Client propagation
    client.setLocale && client.setLocale((context.user && context.user.locale) || 'en_US')
    client.setUser && client.setUser((context.user && context.user.id) || '')
    client.setSessionContext && client.setSessionContext('VALID-FROM', context._ && context._['VALID-FROM'])
    client.setSessionContext && client.setSessionContext('VALID-TO', context._ && context._['VALID-TO'])
    client.setTransactionTimestamp && client.setTransactionTimestamp(undefined)

    client.setCSN(model)
    client.setContext(context)

    return client
  }

  /**
   * Releases a db client to be reused by the session.
   * @param {Client} client - The client that should be released
   * @returns {Promise} A promise for the release of the client
   */
  release (client) {
    return this._pool.release(client)
  }

  /**
   * Destroys a db client to be recreated by the session.
   * @param {Client} client - The client that should be destroyed
   * @returns {Promise} A promise for the destruction of the client
   */
  destroy (client) {
    return this._pool.destroy(client)
  }

  /**
   * Drain the instance of all clients.
   * Allows a graceful shutdown of the complete session instance.
   */
  disconnect () {
    return this._pool.drain().then(() => {
      return this._pool.clear()
    })
  }

  get noClientsBorrowed () {
    return this._pool.borrowed === 0
  }
}

module.exports = Pool
