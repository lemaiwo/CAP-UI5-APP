const uuid = require('@sap/cds-foss')('uuid/v4')

const Pool = require('./Pool')
const Transaction = require('./Transaction')
const { getOptions, getDefaultMainKind } = require('./options')
const { resolve } = require('../util/thenable')

const MODEL = Symbol.for('sap.cds.model')

/**
 * Service to acquire db connection clients.
 */
class Service {
  /**
   * Creates a Service according to the given pool settings (minimum and maximum number of clients) and client settings
   * (db client type and connection options).
   *
   * @param {String} [datasource] - name of datasource
   * @param {Object} [options] - Pool and Client settings
   * @param {Object} [options.pool] - The min and max pool settings.
   * @param {number} [options.pool.min] - The minimum number of db connection clients.
   * @param {number} [options.pool.max] - The maximum number of db connection clients.
   * @param {number} [options.pool.evictionRunIntervalMillisForPools] - The time interval in ms until an idle pool is
   * evicted.
   * Default 60000 ms (1 min).
   * @param {number} [options.pool.evictionRunIntervalMillis] - The time interval in ms for an eviction check of idle db
   * clients in a pool.
   * Default 10000 ms (10 s).
   * @param {number} [options.pool.numTestsPerEvictionRun] - The number of db clients to be checked in each eviction run.
   * Defaults to half of options.pool.min, but at least 2.
   * @param {number} [options.pool.softIdleTimeoutMillis] - The time interval in ms until a db client in idle state is
   * considered as 'to be evicted'. Does not evict idle db clients if number of available clients would fall below
   * options.pool.min.
   * Default 30000 ms (30 s).
   * @param {number} [options.pool.idleTimeoutMillis] - The time interval in ms until a db client in idle state is
   * considered as 'to be evicted'. If number of available clients would fall below options.pool.min it evicts this
   * client and creates a new one to meet options.pool.min.
   * Default 480000 ms (8 min).
   * @param {Object} [options.model] - The to be used model.
   * @param {Object|String} [options.kind] - The to be used kind(s).
   * @param {Object} [options.service] - if options.model, the to be used service name.
   * @param {Object} [options.credentials] - Credentials how to connect with a client
   * @param {string} [options.credentials.host] - Address to the db
   * @param {string} [options.credentials.port] - Port for db
   * @param {string} [options.credentials.user] - Username for authentication
   * @param {string} [options.credentials.password] - Password for authentication
   * @param {boolean} [options.multiTenant] - true, if mt is active
   */
  constructor (datasource, options) {
    const o = (this.options = getOptions(datasource, options))
    if (o.multiTenant) this._addTenantManagers()
    if (o.model && typeof o.model === 'object' && !Array.isArray(o.model)) {
      this._useReflectedModel(o.model)
    }

    this._includePackageMethods(datasource)
    this._pools = new Map()

    // Create cache for accessing entities
    Object.defineProperties(this, { _entities: { value: {} } })
  }

  _addTenantManagers () {
    this._tenantManagers = new Map()
    for (const [mainKind, _package] of this.options.packages) {
      const TenantManager = _package.TenantManager
      if (TenantManager) {
        this._tenantManagers.set(mainKind, new TenantManager(this.options.connectionOptions.get(mainKind)))
      }
    }
  }

  _includePackageMethods (datasource) {
    for (const [, _package] of this.options.packages) {
      if (_package.serviceFunctions) {
        Object.defineProperties(this, {
          create: { value: _package.serviceFunctions.create, writable: true },
          read: { value: _package.serviceFunctions.read, writable: true },
          update: { value: _package.serviceFunctions.update, writable: true },
          delete: { value: _package.serviceFunctions.delete, writable: true },
          insert: { value: _package.serviceFunctions.insert, writable: true }
        })
      }

      if (_package.httpFunctions) {
        Object.defineProperties(this, {
          get: { value: _package.httpFunctions.get, writable: true },
          post: { value: _package.httpFunctions.post, writable: true },
          put: { value: _package.httpFunctions.put, writable: true },
          patch: { value: _package.httpFunctions.patch, writable: true },
          delete: { value: _package.httpFunctions.delete, writable: true }
        })
      }

      if (_package.messagingFunctions) {
        const boundMessagingFunctions = _package.messagingFunctions.bind.call(this, datasource, this.model)
        Object.defineProperties(this, {
          removeAllListeners: { value: _package.messagingFunctions.removeAllListeners, writable: true },
          putQueue: { value: _package.messagingFunctions.putQueue, writable: true },
          deleteQueue: { value: _package.messagingFunctions.deleteQueue, writable: true },
          addSubscription: { value: _package.messagingFunctions.addSubscription, writable: true },
          messagingOptions: { value: boundMessagingFunctions.messagingOptions, writable: true },
          emit: { value: boundMessagingFunctions.emit, writable: true },
          on: { value: boundMessagingFunctions.on, writable: true }
        })
      }
    }
  }

  _useReflectedModel (model) {
    this.model = model
    const services = this.model.all('service')
    if (services.length === 1) {
      this.entities = this.model.childrenOf(services[0], child => child.kind === 'entity')
    } else if (this.options.service) {
      this.entities = this.model.childrenOf(
        services.find(srv => srv.name === this.options.service),
        child => child.kind === 'entity'
      )
    } else {
      this.entities = this.model.entities
    }
    for (const [, connectionOption] of this.options.connectionOptions) {
      if (!connectionOption.credentials) {
        connectionOption.credentials = {}
      }
      connectionOption.model = model
    }
  }

  /**
   * Acquires a db client from the session.
   * @param {Object} [context] - Context object
   * @param {string} [context.user.id] - The user name for the db connection
   * @param {string} [context.user.locale] - The language identifier
   * @param {string} [context.attr.token] - Full JWT from (HTTP) request
   * @param {string} [context.attr.identityZone] - GUID of a tenant
   * @param {string} [mainKind] - Kind to be acquired (for compound services)
   * @returns {Promise.<Object>} Promise, that resolves with result object if db client acquired successfully
   * @returns {Promise} Promise, that rejects with error if no kind or tenantId provided
   */
  async acquire (context = {}, mainKind = null) {
    if (!mainKind) mainKind = this._mainKind || (this._mainKind = getDefaultMainKind(this.options.packages))

    const tenantId = this._getTenantId(context.attr)
    const poolKey = `${tenantId}-${mainKind}`

    // Fallback in case of first call, or pool has been invalidated
    let pool = this._pools.get(poolKey) || this._createPool(poolKey, tenantId, mainKind)

    // Test connect or instance manager call is not finished yet
    if (pool instanceof Promise) pool = await pool

    return pool.acquire(context, context[MODEL] || this.model)
  }

  _getTenantId ({ identityZone } = {}) {
    if (this.options.multiTenant) {
      if (identityZone) {
        return identityZone
      }

      throw new Error('No valid "GUID" of a tenant provided')
    }

    return 'singleTenant'
  }

  /**
   * Starts or joins an already started transaction for the given context.
   * @param {Object} [context] - Object to which the transaction is assigned. Most frequently it is the req argument
   * in an event handler; in that case the transaction will be automatically. If omitted, a new transaction will be
   * started, which will not be committed and ended automatically.
   * @returns Object
   */
  transaction (context = {}) {
    if (!context._txId) {
      context._txId = uuid()
    }

    /*
     * context._.shared.connections is a Map with a Map per _txId that holds a transaction per service
     */
    if (!context._) context._ = {}
    if (!context._.shared) context._.shared = {}
    if (!context._.shared.connections) context._.shared.connections = new Map()
    if (!context._.shared.connections.has(context._txId)) context._.shared.connections.set(context._txId, new Map())

    /*
     * REVISIT:
     * using 'this' is not good as it doesn't reflect the effective data source
     * should be something like `this.options.kind:${JSON.stringify(this.options.credentials)}`, but must also include tenant info
     */
    let tx = context._.shared.connections.get(context._txId).get(this)
    if (!tx) {
      tx = new Transaction(this, context)
      context._.shared.connections.get(context._txId).set(this, tx)
    }

    return tx
  }

  /**
   * Provide large binary stream for a given query.
   *
   * @param {string|object} query - SELECT SQL string or SELECT CQN object.
   * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string or as CQN object with placeholders.
   * @param {Object} [context]
   * @param {string} [mainKind] - Kind to be acquired (for compound services).
   * @returns {Promise} Promise, that resolves with stream if successful or rejects with error if not.
   * Result object can be undefined if no rows obtained.
   */
  stream (query, values, context = {}, mainKind = null) {
    return this.acquire(context, mainKind).then(client => {
      return client.stream(query, values).then(result => {
        return this.release(client).then(() => {
          return result
        })
      })
    })
  }

  // TODO: Instead of a getter, use a function getTenantManager(mainKind) to support multiple tenantManagers
  /**
   * Getter for TenantManager
   * @returns {TenantManager}
   */
  get tenantManager () {
    if (this._tenantManagers.size === 1) {
      for (const [, tenantManager] of this._tenantManagers) {
        return tenantManager
      }
    }
  }

  /**
   * Create a pool instance if a test connect succeeds.
   * @param poolKey
   * @returns {*|Function|Promise<T>}
   * @private
   */
  _createPool (poolKey, tenantId, mainKind) {
    const ready = this._getAndCheckCredentials(tenantId, mainKind)
      .then(options => {
        const pool = new Pool(poolKey, this.options.packages.get(mainKind).Client, options)
        this._pools.set(poolKey, pool)
        return pool
      })
      .catch(err => {
        // Remove pool if multitenancy and crash the node instance on purpose otherwise
        if (this.options.multiTenant) {
          this._pools.delete(poolKey)
        } else {
          setImmediate(() => {
            throw err
          })
        }

        // Throw again or other errors will occur until next tic is reached.
        throw err
      })

    this._pools.set(poolKey, ready)

    return ready
  }

  /**
   * Load credentials from instance manager if needed.
   * Test connect in any case.
   * @param {string} tenantId
   * @returns {Object}
   * @private
   */
  _getAndCheckCredentials (tenantId, mainKind) {
    if (this.options.multiTenant) {
      return this._tenantManagers
        .get(mainKind)
        .get(tenantId)
        .then(credentials => {
          // Get defaults from general options; mostly pool options are relevant
          const options = Object.assign({}, this.options.connectionOptions.get(mainKind))
          options.credentials = Object.assign({}, options.credentials || {}, credentials)
          options.pool = Object.assign({}, options.pool)

          const _package = this.options.packages.get(mainKind)
          // A client might not provide the "options" function
          if (_package && _package.options) {
            _package.options(options)
          }

          return this._testConnection(options, _package.Client)
        })
    }

    return this._testConnection(
      this.options.connectionOptions.get(mainKind),
      this.options.packages.get(mainKind).Client
    )
  }

  /**
   * Test the credentials by doing a test connect.
   * @param {Object} connectionOptions
   * @returns {Promise<Object>}
   * @private
   */
  async _testConnection (connectionOptions, Client) {
    if (!Client) {
      return resolve(connectionOptions)
    }

    const client = new Client(connectionOptions)
    await client.connect()
    await client.end()
    return connectionOptions
  }

  /**
   * Releases a db client to be reused by the session.
   * @param {Client} client - The client that should be released
   * @returns {Promise} A promise for the release of the client
   */
  release (client) {
    return client._pool.release(client).then(() => this._released(client))
  }

  /**
   * Destroys a db client to be recreated by the session.
   * @param {Client} client - The client that should be destroyed
   * @returns {Promise} A promise for the destruction of the client
   */
  destroy (client) {
    return client._pool.destroy(client).then(() => this._released(client))
  }

  _released (client) {
    const pool = client._pool
    const timeout = this.options.pool.evictionRunIntervalMillisForPools
    if (timeout > 0) {
      if (pool._timeout) clearTimeout(pool._timeout)
      pool._timeout = setTimeout(() => {
        if (pool.noClientsBorrowed) this._disconnect(pool)
      }, timeout)
    }
    delete client._pool
  }

  /**
   * Drain the instance of all clients.
   * Allows a graceful shutdown of the complete session instance.
   * @param {string} [tenantId] - GUID of a tenant.
   * @returns {Promise} resolves if disconnect is successful, rejects with error if not
   */
  disconnect (tenantId = '') {
    if (this._pools.size === 0) return Promise.resolve()
    let disconnects = []
    for (const [key, pool] of this._pools) {
      if (key.startsWith(tenantId)) disconnects.push(this._disconnect(pool))
    }
    if (tenantId && disconnects.length === 0) return Promise.reject(new Error(`No pool for tenantId ${tenantId}`))
    return Promise.all(disconnects)
  }

  _disconnect (pool) {
    if (pool instanceof Promise) return pool.then(p => this._disconnect(p))
    this._pools.delete(pool._poolKey)
    if (pool._timeout) {
      clearTimeout(pool._timeout)
      delete pool._timeout
    }
    return pool.disconnect()
  }

  /**
   * Execute CQN or SQL outside of the odata package.
   *
   * @param {string|object} query - SQL string or CQN object generated by the DML statements.
   * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string.
   * @param {Object} [context] Event context.
   * @param {string} [mainKind] - Kind to be acquired (for compound services).
   * @returns {Object} thenable, that resolves with result object (array) if successful or rejects with error if not.
   *
   */
  async run (query, values, context = {}, mainKind = null) {
    const client = await this.acquire(context, mainKind)
    if (this.options.model && !client._csn) client.setCSN(context[MODEL] || this.model) // REVISIT: Could be former model???
    try {
      return client.run(query, values)
    } finally {
      this.release(client)
    }
  }

  /**
   * Executes the statement and processes the result set one by one.
   * Should be used if huge result sets are expected to process it in a streaming-like fashion
   * instead of materializing the full set in memory before.
   *
   * @param {string|object} query - SQL string or CQN object generated by the DML statements.
   * @param {Array} [values] - Values to be set in the SQL statement if query is provided as string.
   * @param {function} cb - synchronous function to process each row of the result set.
   * @param {Object} [context] Event context.
   * @param {string} [mainKind] - Kind to be acquired (for compound services).
   * @returns {Promise} Promise, that resolves with undefined if successful or rejects with error if not.
   */
  async foreach (query, values, cb, context, mainKind) {
    const client = await this.acquire(context, mainKind)
    // REVISIT: Warum setzen wir hier kein model?
    try {
      return client.foreach(query, values, cb)
    } finally {
      this.release(client)
    }
  }

  /**
   * Drops all tables/views and creates them again
   * @param {object} csn the unreflected CSN.
   * @param {Object} [context] Event context.
   * @param {string} [mainKind] - Kind to be acquired (for compound services).
   * @returns {Promise} Promise, that resolves with undefined if successful or rejects with error if not.
   */
  async deploy (csn, context, mainKind) {
    // REVISIT: deploy kann komplett entfernt werden
    const dbc = await this.acquire(context, mainKind)
    try {
      return await dbc.deploy(csn)
    } finally {
      await this.release(dbc)
    }
  }
}

if (/\b(y|all|true|ql|cql|sql|srv)\b/.test(process.env.DEBUG)) {
  const { stdout } = require('./debug')

  class DebugSession extends Service {
    acquire (...args) {
      stdout('acquire connection')
      return super.acquire(...args)
    }

    release (...args) {
      stdout('release connection')
      return super.release(...args)
    }

    disconnect () {
      stdout('disconnect session')
      return super.disconnect()
    }
  }

  module.exports = DebugSession
} else {
  module.exports = Service
}
