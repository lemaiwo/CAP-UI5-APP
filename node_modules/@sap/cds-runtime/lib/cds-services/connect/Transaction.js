/**
 * Transaction to encapsulate operations on a data source which should be executed as an atomic unit of work.
 */
module.exports = class Transaction {
  /**
   * Creates a transaction for a given connection service and a specific context.
   * @param {Object} service - Session allowing to acquire and manage data source clients
   * @param {Object} context - Object to which the transaction is assigned. Most frequently it is the req argument
   * in an event handler; in that case the transaction will be automatically. If omitted, a new transaction will be
   * started, which will not be committed and ended automatically.
   */
  constructor (service, context) {
    Object.assign(this, { _service: service, _context: context })
    for (const [, each] of service.options.packages) {
      Object.assign(this, each.serviceFunctions)
      Object.assign(this, each.httpFunctions)
    }
  }

  run (query, values) {
    return _run('run', this, query, values)
  }
  foreach (query, values, callback) {
    return _run('foreach', this, query, values, callback)
  }
  commit (ignoreReleaseError) {
    return _end('commit', this, ignoreReleaseError)
  }
  rollback (ignoreReleaseError) {
    return _end('rollback', this, ignoreReleaseError)
  }
}

const followProjection = require('../util/followProjection')
const MODEL = Symbol.for('sap.cds.model') // Support for legacy push down of model

function _updateConnections (tx) {
  if (!tx._context._.shared.connections.has(tx._context._txId)) {
    tx._context._.shared.connections.set(tx._context._txId, new Map())
  }
  if (!tx._context._.shared.connections.get(tx._context._txId).has(tx._service)) {
    tx._context._.shared.connections.get(tx._context._txId).set(tx._service, tx)
  }
}

/**
 * Helper for tx.run and tx.foreach
 */
async function _run (op, tx, query, ...etc) {
  // acquire a connection from the pool if first _run of transaction
  if (!tx.client) {
    /*
     * make tx.client a promise for immediate effect on parallel _run's
     * (i.e., second _run will wait on client in if statement below)
     * that resolves with the resoliution of client.begin
     */
    tx.client = tx._service.acquire(tx._context).then(async c => {
      await c.begin()
      c.setCSN(tx._context[MODEL] || tx._service.model)
      c.setContext(tx._context)
      if (c.setTransactionTimestamp && typeof c.setTransactionTimestamp === 'function') {
        c.setTransactionTimestamp(new Date().toISOString())
      }

      /*
       * REVISIT:
       * Only introduced to continuously allow the following:
       *   const tx = cds.transaction(some_custom_context)
       *   tx..run(...)
       *   tx.commit()
       *   tx.run(...)
       *   tx.commit()
       * Note that the second .commit() didn't do anything, so only SELECT queries (seemed to) work.
       */
      _updateConnections(tx)

      return c
    })
  }

  // wait till begin is done (log error and pass up)
  if ('then' in tx.client) {
    try {
      tx.client = await tx.client
    } catch (err) {
      if (process.env.NODE_ENV !== 'production') {
        console.error(err)
      }
      throw err
    }
  }

  // bulk run a set of queries
  if (Array.isArray(query)) {
    return Promise.all(query.map(q => _run(op, tx, q)))
  }

  query = followProjection(query, tx._service)

  // finally run single queries
  return tx.client[op](query, ...etc)
}

/**
 * Helper for tx.commit and tx.rollback
 */
async function _end (op, tx, ignoreReleaseError) {
  let client = tx.client

  if (!client) {
    if (ignoreReleaseError) {
      return
    } else {
      throw new Error(`Cannot ${op}: client not found`)
    }
  } else if ('then' in client) {
    client = await client
  }

  // remove no longer needed connection
  tx._context._.shared.connections.get(tx._context._txId).delete(tx._service)
  if (tx._context._.shared.connections.get(tx._context._txId).size === 0) {
    tx._context._.shared.connections.delete(tx._context._txId)
  }

  delete tx.client

  try {
    // REVISIT: Why is the session destroyed when the commit fails?
    await client[op]()
    await tx._service.release(client)
  } catch (err) {
    await tx._service.destroy(client)
    throw err
  }
}
