const { COMMON, ODATA } = require('../../common/constants/annotation')
const { isDraftEnabled } = require('../../common/utils/draft')

const getError = require('../util/getError')
const { all } = require('../util/thenable')

const {
  events: { MOD }
} = require('./utils/constants')

// Service hooks and generic handlers
const handlers = require('./handlers')
const { After, Before, On, Reject } = require('./hooks')
const Client = require('./client/Client')
const path = require('path')
const os = require('os')

// Service utils
const auditLogger = require('../util/auditlog')
const { isDraftRootEntity, selectDeepUpdateData } = require('./utils/compositionTree')
const { getDefaultHandlers, getScenario } = require('./utils/defaultHandlers')
const getDiff = require('./utils/diff')
const { checkIntegrity, flattenDeepToOneAssociations, filterReadOnly } = require('./utils/handlerUtils')
const temporalInitialHandler = require('../../common/generic/temporal').handler
const { isPersonalDataRelevant } = require('./utils/personalData')
const logger = require('./utils/logger')
const compareJson = require('./utils/compareJson')
const {
  events: { CUD_DRAFT },
  DRAFT_COLUMNS
} = require('./utils/constants')
const { actionAndFunctionQueries } = require('../adapter/odata-v4/utils/handlerUtils')

// Utils used also at adapters
const getAnnotations = require('../adapter/utils/getAnnotations')

const { getParams } = require('../adapter/odata-v4/utils/data')

/**
 * Generic Service Event Handler.
 */
class Service extends Client {
  /**
   * Constructs an OData service for the given CDS model.
   * @param {Object} csn - the reflected CSN.
   * @param {Object} options - configuration options
   * @param {function} [impl] - init function to register custom handlers.
   */
  constructor (csn, options) {
    super()

    let reflectedModel
    if (global.cds.env.features && global.cds.env.features.snapi) {
      reflectedModel = csn
    } else {
      reflectedModel = csn.reflectedModel
      this._csn = csn.csn
    }

    this.options = options
    // compat for umbrella
    this._options = options
    this.name = options.service
    this.model = reflectedModel

    this._messagingService = this._getMessagingService()

    this.definition = reflectedModel.definitions[this.name]

    Object.defineProperties(this, {
      operations: {
        get: () =>
          reflectedModel.childrenOf(this.definition, d => d.kind === 'action' || d.kind === 'function', 'operations'),
        configurable: true
      },
      entities: {
        get: () => reflectedModel.childrenOf(this.definition, d => d.kind === 'entity', 'entities'),
        configurable: true
      },
      types: {
        get: () => reflectedModel.childrenOf(this.definition, d => !d.kind || d.kind === 'type', 'types'),
        configurable: true
      }
    })

    this._handlers = {
      initial: new Before(this.model, this.name),
      before: new Before(this.model, this.name),
      on: new On(this.model, this.name, this._messagingService),
      after: new After(this.model, this.name),
      reject: new Reject(this.model, this.name)
    }

    this._addFunctions()
    this._addDefaultHandler()
  }

  _getMessagingOptionsCompat () {
    const providedSrv = global.cds.env.provides && global.cds.env.provides[this.name]
    const messaging = global.cds.env.requires && global.cds.env.requires.messaging
    if (providedSrv) {
      // for compatibility to existing tests only --> should rather remove it
      const kinds = typeof providedSrv.kind === 'object' ? Object.keys(providedSrv.kind) : [providedSrv.kind]

      let o = Object.assign({}, providedSrv)
      if (providedSrv.credentials) {
        o.credentials = Object.assign({}, providedSrv.credentials)
      }

      if (messaging && kinds.includes('messaging')) {
        o = this._mergeWithMessaging(o, messaging)
      }
      return o
    }
  }

  _getMessagingOptions () {
    const messaging = global.cds.env.requires && global.cds.env.requires.messaging
    const o = messaging ? { ...messaging } : {}

    let { kind, credentials } = o
    if (!credentials) credentials = o.credentials = {}

    if (credentials.file === true || credentials.file === 'default') {
      o.credentials.file = path.join(os.tmpdir(), 'cds-message-box')
    }

    if (this.options.credentials) {
      Object.assign(credentials, this.options.credentials.messaging)
    }

    if (!kind || kind === 'local') {
      o.kind = this._getDerivedKind(kind, credentials)
    }

    // This is to report credentials to local bindings in dev scenarios:
    // if (!this.options.credentials) this.options.credentials = {}
    // if (!this.options.credentials.messaging) this.options.credentials.messaging = {}
    // Object.assign(this.options.credentials, credentials)

    return o
  }

  _getDerivedKind (kind, credentials) {
    if (kind === 'local') {
      return credentials.file ? 'file-based-messaging' : 'in-process-messaging'
    }
    if (!kind) {
      return credentials.management && credentials.messaging
        ? 'enterprise-messaging'
        : credentials.file
          ? 'file-based-messaging'
          : 'in-process-messaging'
    }
  }

  _getMessagingService () {
    const o = this._getMessagingOptionsCompat() || this._getMessagingOptions()
    o.model = this.model

    return global.cds.ql.connect(this.name, o)
    // return cds.connect.to(this.name, o)
    // FIXME: we need to clean this up later - it's also always adding a secondary MessagingService to each service, even if no messaging is switched on at all, e.g. in bookshop
  }

  _mergeWithMessaging (connectionOptions, messaging) {
    if (typeof connectionOptions.kind === 'object') {
      const mergedOptionsObj = Object.assign({}, messaging, connectionOptions.kind.messaging)
      delete connectionOptions.kind.messaging
      connectionOptions.kind[messaging.kind] = mergedOptionsObj
      delete connectionOptions.kind[messaging.kind].kind
    } else {
      connectionOptions = Object.assign({}, messaging, connectionOptions, { kind: messaging.kind })
    }
    return connectionOptions
  }

  /**
   * Require logger on first usage.
   * Could be provided via options.
   *
   * @returns {Object}
   */
  get logger () {
    const log = logger(this.options)
    Object.defineProperty(this, 'logger', { value: log })
    return log
  }

  /**
   * Require @sap/audit-logging on first usage.
   * @returns {Object}
   * @private
   */
  get _auditLogger () {
    const audit = auditLogger(this.options.auditlog, this.logger)
    Object.defineProperty(this, '_auditLogger', { value: audit })
    return audit
  }

  /**
   * @deprecated since version 1.11.0 - use Service.impl instead
   */
  with (serviceImpl) {
    return this.impl(serviceImpl)
  }

  _finishWithHandlers () {
    this._handlers.before.finishAddingWithHandlers()
    this._handlers.on.finishAddingWithHandlers()
    this._handlers.after.finishAddingWithHandlers()
  }

  /**
   * Registers custom handlers.
   * @param {string|object|function} serviceImpl - init function to register custom handlers.
   */
  impl (serviceImpl) {
    if (typeof serviceImpl === 'string') {
      serviceImpl = require(serviceImpl)
    }

    if (typeof serviceImpl === 'object') {
      serviceImpl = serviceImpl[this.name]
    }

    if (typeof serviceImpl !== 'function') {
      return this
    }

    if (/^class\s/.test(Function.prototype.toString.call(serviceImpl))) {
      const ImplClass = serviceImpl
      serviceImpl = srv => {
        const inst = new ImplClass(srv)
        for (let e of Reflect.ownKeys(ImplClass.prototype)) {
          if (e in { constructor: 1, prototype: 1 }) {
            continue
          }
          const handler = (...args) => inst[e](...args)
          srv.on(e, handler)
        }
      }
    }

    this._handlers.before.startAddingWithHandlers()
    this._handlers.on.startAddingWithHandlers()
    this._handlers.after.startAddingWithHandlers()

    const result = serviceImpl.apply(this, [this])

    if (result && result.then) {
      result.then(() => {
        return this._finishWithHandlers()
      })
    } else {
      this._finishWithHandlers()
    }

    return this
  }

  /**
   * Register default on handlers for all entities of the service.
   * If the entity is marked with @readonly annotation only default handler for read is registered, others are rejected.
   * If the entity is marked with @insertonly annotation only default handler for insert is registered, others are rejected.
   * @private
   */
  _addDefaultHandler () {
    // Final handler, that will throw an error - should be registered first!
    this.on(this._markDefault(handlers.finalOn))

    this._addDefaultBeforeAuthHandler()

    const isDraftEnabledService = Object.values(this.entities).some(entity => entity[ODATA.DRAFT])

    if (isDraftEnabledService) {
      this.model['IS_SERVICE_DRAFT'] = true
    }

    this._addETagHandling()

    const serviceEntities = this._getServiceEntities()
    for (const entity of serviceEntities) {
      const { before, on, reject } = getDefaultHandlers(
        isDraftEnabledService,
        isDraftEnabled(this.model.definitions[entity.name]),
        isDraftRootEntity(this.model.definitions, entity.name),
        entity.name
      ).get(getScenario(entity, serviceEntities))

      this._addDefaultInitialHandler(before, entity)
      this._addDefaultOnHandler(on, entity)
      this._addDefaultRejectHandler(reject, entity.name)

      // register audit logging handlers only for entities with personal data annotation
      if (isPersonalDataRelevant(entity)) {
        this._addPersonalDataHandler(entity)
      }

      // REVISIT: add temporal handler as if it would be part of context
      this._initial(entity.name, this._markDefault(temporalInitialHandler))

      // add referencial integrity check, if needed, to be executed directly before committing the transaction
      if (this._isReferenceIntegrityCheckNeeded(entity, this.model.definitions[this.name])) {
        this.before(
          'COMMIT',
          entity,
          this._markDefault(this._getReferenceIntegrityCheckHandler(['CREATE', 'UPDATE', 'DELETE'], this.model))
        )
      }
    }

    // Generic commit/rollback
    this.on('COMMIT', this._markDefault(handlers.onCommit))
    this.on('ROLLBACK', this._markDefault(handlers.onRollback))
  }

  _markDefault (handler) {
    handler.isDefault = true
    return handler
  }

  _isReferenceIntegrityCheckNeeded (entity, service) {
    return (
      !this.model['IS_SERVICE_DRAFT'] &&
      !(entity['@cds.integrity.skip'] !== false && (entity['@cds.integrity.skip'] || service['@cds.integrity.skip']))
    )
  }

  _getReferenceIntegrityCheckHandler (methods, csn) {
    return context => {
      if (methods.includes(context.event)) {
        return checkIntegrity(context, csn)
      }
    }
  }

  _addDefaultInitialHandler (before, entity) {
    for (const [method, handlerName] of before) {
      if (Array.isArray(handlerName)) {
        handlerName.forEach(name => {
          const handler = handlers[name](this)
          this._initial(method, entity, this._markDefault(handler))
        })
      } else {
        const handler = handlers[handlerName](this)
        this._initial(method, entity, this._markDefault(handler))
      }
    }
  }

  _addDefaultOnHandler (on, entity) {
    for (const [method, handlerName] of on) {
      const handler = handlers[handlerName](this)
      this.on(method, entity, this._markDefault(handler))
    }
  }

  _addDefaultRejectHandler (reject, entityName) {
    if (reject.length) {
      this.reject(reject, entityName)
    }
  }

  /**
   * Register default before commit and after commit/rollback handler for the entity.
   * @param entity
   * @private
   */
  _addPersonalDataHandler (entity) {
    if (
      entity['@AuditLog.Operation.Insert'] ||
      entity['@AuditLog.Operation.Update'] ||
      entity['@AuditLog.Operation.Delete']
    ) {
      this.before('COMMIT', entity, this._markDefault(handlers.beforeCommitPersonalData(this._auditLogger)))
      this.after('COMMIT', entity, this._markDefault(handlers.afterCommitPersonalData))
      this.before('ROLLBACK', entity, this._markDefault(handlers.beforeRollbackPersonalData(this._auditLogger)))
      this.after('ROLLBACK', entity, this._markDefault(handlers.afterRollbackPersonalData))
    } else if (entity['@AuditLog.Operation.Read']) {
      this.before('COMMIT', entity, this._markDefault(handlers.beforeCommitPersonalData(this._auditLogger)))
    }
  }

  /**
   * Register default before handlers for all authorization annotated entities and operations of the service.
   * @private
   */
  _addDefaultBeforeAuthHandler () {
    for (const entity of this._getServiceEntities()) {
      const annotations = getAnnotations(entity)

      for (const key of Object.keys(annotations)) {
        const handler = handlers.beforeEntityAuth(annotations[key], this._auditLogger, this.model)
        this.before(key, entity, this._markDefault(handler))
      }

      if (entity.actions) {
        // bound actions or functions
        this._addBeforeOperationAuthHandler(entity.actions, entity)
      }
    }

    this._addBeforeOperationAuthHandler(this.operations)
  }

  _addBeforeOperationAuthHandler (operations, entity) {
    for (const key of Object.keys(operations)) {
      const annotations = getAnnotations(operations[key])

      if (annotations['operation']) {
        const handler = handlers.beforeEntityAuth(annotations['operation'], this._auditLogger, this.model)
        this.before(key, entity, this._markDefault(handler))
      }
    }
  }

  _addETagHandling () {
    const handler = handlers.beforeETagCheck
    for (const entity of this._getServiceEntities()) {
      const draft = isDraftEnabled(this.model.definitions[entity.name])
      if (Object.values(entity.elements).some(val => val['@odata.etag'])) {
        if (draft) {
          this._initial('READ', entity, this._markDefault(handler))
          this._initial('NEW', entity, this._markDefault(handler))
          this._initial('DELETE', entity, this._markDefault(handler))
          this._initial('PATCH', entity, this._markDefault(handler))
          this._initial('EDIT', entity, this._markDefault(handler))
          this._initial('CANCEL', entity, this._markDefault(handler))
        } else {
          this._initial('CREATE', entity, this._markDefault(handler))
          this._initial('READ', entity, this._markDefault(handler))
          this._initial('UPDATE', entity, this._markDefault(handler))
          this._initial('DELETE', entity, this._markDefault(handler))
        }

        if (entity.actions) {
          Object.keys(entity.actions).forEach(key => {
            this._initial(entity.actions[key].name, entity, this._markDefault(handler))
          })
        }
      }
    }
  }

  _getServiceEntities () {
    const regex = new RegExp(`^${this.name.replace(/\./g, '\\.')}\\.\\w+$`)
    return this.model.all(definition => {
      return definition.kind === 'entity' && definition.name.match(regex)
    })
  }

  /**
   * Add an initial handler for a specific event type and entity. N handlers per type and entity can be registered.
   * This is reserved for generic intial handlers and not part of the registration API for custom handlers.
   * @param {string} event - Name of event like 'CREATE', 'UPDATE', 'DELETE', ...
   * @param {string|Object} [entity] - Name of the entity or CSN entity.
   * @param {function|Object} handler - To be executed event handler. It could be function or CQN object.
   * @returns {Service}
   * @private
   */
  _initial (event, entity, handler) {
    this._handlers.initial.use(event, entity, handler)

    return this
  }

  /**
   * Add a before handler for a specific event type and entity. N handlers per type and entity can be registered.
   * @param {string} event - Name of event like 'CREATE', 'UPDATE', 'DELETE', ...
   * @param {string|Object} [entity] - Name of the entity or CSN entity.
   * @param {function|Object} handler - To be executed event handler. It could be function or CQN object.
   * @returns {Service}
   */
  before (event, entity, handler) {
    this._handlers.before.use(event, entity, handler)

    return this
  }

  /**
   * Replace an on handler for a specific event type and entity.
   * @param {string} [event] - Name of event like 'CREATE', 'UPDATE', 'DELETE', ...
   * @param {string|Object} [entity] - Name of the entity or CSN entity.
   * @param {function|Object} handler - To be executed event handler. It could be function or CQN object.
   * @returns {Service}
   */
  on (event, entity, handler) {
    // Support for DAOs from Cloud SDK
    if (entity && typeof entity === 'function' && '_entityName' in entity) {
      entity = entity._entityName
    }

    // If we are called with a view, fetch an underlying entity which is exposed by this service
    let d = this.model.definitions[`${this.name}.${entity}`]
    const LIMIT = 100
    for (let i = 0; i <= LIMIT; i++) {
      if (i === LIMIT) {
        throw new Error('Entity resolution stack limit reached')
      }

      if (!d) break
      if (!d.name || !d.name.startsWith) break
      if (d.name.startsWith(this.name)) {
        entity = d.name
        break
      }
      d = this.model.definitions[d.query._target.name]
    }

    this._handlers.on.use(event, entity, handler)

    return this
  }

  /**
   * Add an after handler for a specific event type and entity. N handlers per type and entity can be registered.
   * In case an arrow function with '(each) =>' is used for the event handler an iterator for the result set will be added automatically.
   * @param {string} event - Name of event like 'CREATE', 'UPDATE', 'DELETE', ...
   * @param {string|string|Object} [entity] - Name of the entity or CSN entity.
   * @param {function|Object} handler - To be executed event handler. It could be function or CQN object.
   * @returns {Service}
   */
  after (event, entity, handler) {
    this._handlers.after.use(event, entity, handler)

    return this
  }

  emit (...args) {
    this._messagingService.emit(...args)
    return this
  }

  /**
   * Reject an event type, list of event types or an event type for a entity.
   * @param {string|Array} event - Specific event type or list of types.
   * @param {string|Object|Array} [entity] - Name of the entity or CSN entity or list of entities the event type should be rejected for.
   * The list can be specified either as Array or as multiple parameters.
   * @returns {Service}
   */
  reject (...args) {
    this._handlers.reject.use(...args)

    return this
  }

  _triggeredByDraftCreate (context) {
    return context.event === 'CREATE' && context.target[ODATA.DRAFT]
  }

  _triggeredByDraftPatch (context) {
    return (
      context.event === 'PATCH' &&
      (context.target[COMMON.DRAFT_NODE.PREP_ACTION] || context.target[COMMON.DRAFT_ROOT.PREP_ACTION])
    )
  }

  async _actionsAndFunctionsAfter (context, result) {
    const req = context._.odataReq
    if (req && context._.returnType && context._.returnType.kind === 'entity' && req.getQueryOptions()) {
      await actionAndFunctionQueries(context, req, result, this)
    }
  }

  /**
   * Process an event from any adapter/channel.
   * @param {Object} context
   * @returns {Promise<Array>}
   */
  async processEvent (context) {
    if (this._handlers.reject.has(context.event, context.target)) {
      throw getError(405)
    }

    // REVISIT: remove overwrite of overwrite in umbrella
    /* istanbul ignore if */
    if (context.constructor.name === 'OdataContext') {
      Object.defineProperty(context, 'params', {
        configurable: true,
        get: function () {
          context._params = context._params || getParams(context._.odataReq)
          return context._params
        }
      })
    }

    this._addError(context)
    this._addReject(context)
    this._addReply(context)
    if (
      MOD.includes(context.event) &&
      !this._triggeredByDraftCreate(context) &&
      !this._triggeredByDraftPatch(context)
    ) {
      filterReadOnly(context)
      // REVISIT: Workaround for rest adapter not having ref on context.data
      if (context.query.UPDATE && context.data !== context.query.UPDATE.data) {
        filterReadOnly({ data: context.query.UPDATE.data, target: context.target, event: context.event })
      } else if (
        context.query.INSERT &&
        context.query.INSERT.entries &&
        context.data !== context.query.INSERT.entries[0]
      ) {
        filterReadOnly({ data: context.query.INSERT.entries[0], target: context.target, event: context.event })
      }
    }
    this._addRunIfPrimarySessionExists(context)
    this._addDiffIfNeeded(context)
    this._addLogger(context)

    // validate associations for deep insert
    flattenDeepToOneAssociations(context, this.model)

    let result

    try {
      result = this._storeDataOperations(
        context.event,
        context,
        await this._actionsFunctionsHandlers(context.event, context)
      )

      // TODO put in initial after handler once implemented
      await this._actionsAndFunctionsAfter(context, result)
    } catch (err) {
      await this._commitRollback('ROLLBACK', context, this._storeDataOperations(context.event, context, err))

      throw err
    }

    return this._commitRollback('COMMIT', context, result)
  }

  /**
   * Check for registered handlers.
   * Execute in sequence before, on, after, beforeCommit, commit, onCommit.
   * @param {string} event
   * @param {Object} context
   * @private
   */
  async _actionsFunctionsHandlers (event, context) {
    await this._handlers.initial.executeHandlerIfListed(event, context)
    await this._handlers.before.executeHandlerIfListed(event, context)
    const result =
      'results' in context ? context.results : await this._handlers.on.executeHandlerIfListed(event, context)
    return this._handlers.after.executeHandlerIfListed(event, context, result)
  }

  async _commitRollback (command, context, result) {
    if (context._.shared.doNotFinishTransaction === undefined) {
      await this._executeFinishTransactionHandlers(command, context)
    }

    return result
  }

  async _destroyConnections (context) {
    if (context._.shared.connections && global.cds.db) {
      // F.U.B.A.R. we need to destroy the client if one is left
      const destroys = []

      for (const outer of context._.shared.connections) {
        for (const inner of outer[1]) {
          const tx = inner[1]
          if (tx.client) {
            destroys.push(tx._service.destroy(tx.client))
          }
        }
      }

      if (destroys.length) {
        await Promise.all(destroys)
      }

      delete context._.shared.connections
      delete context.run
    }
  }

  async _executeFinishTransactionHandlers (command, context, dataOperations) {
    dataOperations = dataOperations || context._.shared.dataOperations || []
    delete context._.shared.dataOperations
    delete context.results
    delete context.rejected

    try {
      await this._beforeEndTransactionBlock(command, context, dataOperations)
      await this._handlers.on.executeHandlerIfListed(command, context)
    } catch (commandErr) {
      if (command === 'ROLLBACK') {
        this._destroyConnections(context)
      } else if (command === 'COMMIT') {
        await this._executeFinishTransactionHandlers('ROLLBACK', context, dataOperations)
      }

      throw commandErr
    }

    await this._afterEndTransactionBlock(command, true, context._, dataOperations)

    // Remove, as the next batch group will have its own context
    delete context._.shared.dataOperations
  }

  _addLogger (context) {
    context.log = this.logger
  }

  _addError (context) {
    /**
     * Errors are not thrown. Instead they are collected in the array context.errors.
     * @param {number} [code] - HTTP status code. If unknown to @sap/odata-server, will be overwritten with 500.
     * @param {string|object|Error} msg - Error given by the app developer.
     * @param {string} [target] - Property of entity to which the error relates (e. g. `name` or a navigation path).
     */
    context.error = (code, msg, target) => {
      context.errors = context.errors || []

      const error = getError(code, msg, target)
      context.errors.push(error)

      return error
    }
  }

  _addReject (context) {
    /**
     * Reject is not thrown. Instead the error is stored at context.rejected.
     * @param {number} [code] - HTTP status code. If unknown to @sap/odata-server, will be overwritten with 500.
     * @param {string|object|Error} msg - Error given by the app developer.
     * @param {string} [target] - Property of entity to which the error relates (e. g. `name` or a navigation path).
     */
    context.reject = (code, msg, target) => {
      context.rejected = getError(code, msg, target)
    }
  }

  _addReply (context) {
    context.reply = results => {
      context.results = results
    }
  }

  _createSelectColumnsForDelete (entity) {
    const columns = []
    for (const element of Object.values(entity.elements)) {
      if (element.type === 'cds.Composition') {
        if (element._target['@cds.persistence.skip'] === true) continue
        columns.push({
          ref: [element.name],
          expand: this._createSelectColumnsForDelete(element._target)
        })
      } else if (element.type !== 'cds.Association' && !DRAFT_COLUMNS.includes(element.name)) {
        columns.push({ ref: [element.name] })
      }
    }

    return columns
  }

  _createWhereCondition (entity, data) {
    // FIXME: need to support update on to-one association
    return Object.keys(entity.keys).reduce((prev, curr) => {
      if (!DRAFT_COLUMNS.includes(curr)) {
        prev[curr] = data[curr]
      }

      return prev
    }, {})
  }

  _diffDelete (context) {
    return context
      .run(
        context.statements.SELECT.from(context.target)
          .columns(this._createSelectColumnsForDelete(context.target))
          .where(this._createWhereCondition(context.target, context.data))
      )
      .then(dbState => {
        return compareJson(undefined, dbState, context.target)
      })
  }

  async _diffUpdate (context, providedData) {
    if (context.run) {
      try {
        await this._addPartialPersistentState(context)
      } catch (e) {}
    }
    const combinedData =
      providedData || Object.assign({}, context.query.UPDATE.data || {}, context.query.UPDATE.with || {})
    return compareJson(combinedData, context._.partialPersistentState, context.target)
  }

  async _diffPatch (context, providedData) {
    if (context.run) {
      // SELECT because req.query in custom handler does not have access to _drafts
      context._.partialPersistentState = await context.run(
        context.statements.SELECT.from(context.target.name)
          .where(this._createWhereCondition(context.target, context.data))
          .limit(1)
      )

      return compareJson(providedData || context.data, context._.partialPersistentState, context.target)
    }
  }

  _diffCreate (context, providedData) {
    return compareJson(providedData || context.data, undefined, context.target)
  }

  async _calculateDiff (context, providedData) {
    if (context.event === 'CREATE') {
      return this._diffCreate(context, providedData)
    }

    if (context.target['@cds.persistence.skip'] === true) {
      return
    }

    if (context.event === 'DELETE') {
      return this._diffDelete(context)
    }

    if (context.event === 'UPDATE') {
      return this._diffUpdate(context, providedData)
    }

    if (context.event === 'PATCH') {
      return this._diffPatch(context, providedData)
    }
  }

  async _addPartialPersistentState (context) {
    const deepUpdateData = await selectDeepUpdateData(this.model.definitions, context.query, context.run, context, true)
    context._.partialPersistentState = deepUpdateData
  }

  _addDiffIfNeeded (context) {
    if (MOD.includes(context.event) || context.event === 'DELETE') {
      const that = this
      /**
       * Function to retrieve the difference from db state.
       * Works for deep documents using compositions.
       *
       * Caches the difference after the first use.
       *
       * Output format is:
       * {
       *  type: 'update',
       *  entity: 'entityName',
       *  keys: { ID: 1 },
       *  values: {
       *    old: 'A',
       *    new: 'B'
       *   }
       * }
       */
      context.diff = function (data) {
        // no arrow function used on purpose
        // `this` will point to the new context of local client
        return that._calculateDiff(this, data)
      }
    }
  }

  /**
   * Track the general event as commit event.
   * @param event
   * @param context
   * @param result
   * @private
   */
  _storeDataOperations (event, context, result) {
    context._.shared.dataOperations = context._.shared.dataOperations || []

    // Dont add underscore yet
    const dataOperation = {
      get query () {
        return context.query
      },
      target: context.target,
      data: context.data,
      user: context.user,
      attr: context.attr,
      // Event is not required by handler, but is useful for the app developer
      event: event
    }

    if (event === 'READ') {
      dataOperation.result = result
    } else {
      // Might be undefined; TODO: an API to set it.
      dataOperation.oldData = context._oldData

      // Lazy constructing of the diff
      Object.defineProperty(dataOperation, 'diff', {
        configurable: true,
        get: function () {
          const diff = getDiff(event, this.oldData, this.data)
          Object.defineProperty(dataOperation, 'diff', { value: diff })

          return diff
        }
      })
    }

    context._.shared.dataOperations.push(dataOperation)

    return result
  }

  _beforeEndTransactionBlock (command, context, dataOperations) {
    const handlers = []

    for (const dataOperation of dataOperations) {
      // hack 1: from before commit if already present
      delete dataOperation.errors

      // hack 2: add error function using wrapper to not lose context info
      this._addError(dataOperation)

      // .reply && .reject might need to be added as well in the future
      const newContext = Object.assign(dataOperation, { _: context._, run: context.run })

      handlers.push(this._handlers.before.executeHandlerIfListed(command, newContext))
    }

    return all(handlers)
  }

  _afterEndTransactionBlock (command, success, _, dataOperations) {
    const handlers = []

    for (const dataOperation of dataOperations) {
      dataOperation.success = success

      handlers.push(this._handlers.after.executeHandlerIfListed(command, Object.assign(dataOperation, { _ })))
    }

    return all(handlers)
  }

  _addRunIfPrimarySessionExists (context) {
    // Add the function so that the connection can be released in case of errors in complex scenarios like OData batch
    if (context._.shared.doNotFinishTransaction && !context._.shared.endTransactionIfConnected) {
      // Wrap to easily maintain the scope of this
      context._.shared.endTransactionIfConnected = (cmd, ctx) => {
        return this._executeFinishTransactionHandlers(cmd, Object.assign(ctx, { run: context.run }))
      }
    }

    // cds.connect() has not been used yet
    if (!global.cds.db) {
      return
    }

    context.run = (...args) => {
      if (context._ && context._.streaming) {
        return global.cds.db.stream(args[0], args[1], context)
      }

      if (
        this._hasNoSideEffect(context) &&
        !(context._.shared && context._.shared.connections && context._.shared.connections.has(context._txId))
      ) {
        return global.cds.db.run(args[0], args[1], context)
      }

      const tx = global.cds.db.transaction(context)
      return tx.run(...args)
    }
  }

  _hasNoSideEffect (context) {
    // Known list of side effects
    if (CUD_DRAFT.includes(context.event)) {
      return false
    }

    // Shared context or OData atomicity
    if (context._.shared.doNotFinishTransaction) {
      return false
    }

    if (context.event === 'READ') {
      return true
    }

    // Unbound actions/functions
    if (!context.target && this.model.definitions[context.event]) {
      return this.model.definitions[context.event].kind === 'function'
    }

    // Bound actions/functions
    if (
      this.model.definitions[context.target.name] &&
      this.model.definitions[context.target.name].actions &&
      this.model.definitions[context.target.name].actions[context.event]
    ) {
      return this.model.definitions[context.target.name].actions[context.event].kind === 'function'
    }

    return false
  }
}

module.exports = Service
