// Handlers
const handlerArguments = require('./handlers/arguments')
const handlerPostProcess = require('./handlers/post-process')
const cqnToData = require('./handlers/cqn-to-data')
const getColumns = require('../utils/columns')
const { convertDateTime } = require('../utils/handlerUtils')
const { getNotInModelEntityError } = require('../../util/errors')

const EventEmitter = require('events')

const IS_BATCH = Symbol.for('sap.cds.IS_BATCH')
const OPEN_REQUESTS = Symbol.for('sap.cds.OPEN_REQUESTS')
const MODEL = Symbol.for('sap.cds.model')

const followProjection = require('../../util/followProjection')

/**
 * Local service client.
 */
class Client {
  /**
   * Lookup CSN for any kind of non standard actions and functions.
   * Add them as static functions to this instance.
   * @private
   */
  _addFunctions () {
    this._addBoundEvents()
    this._addUnboundEvents()
  }

  /**
   * Find all bound actions and functions.
   * Add them as static functions to this instance.
   * @private
   */
  _addBoundEvents () {
    const entities = this.model.all(element => {
      return element.kind === 'entity' && element.actions
    })

    if (entities.length) {
      this._boundEventsHelper = {}
    }

    for (const entity of entities) {
      for (const name of Object.keys(entity.actions)) {
        this._createBoundFunctionsAndActions(name, entity.actions[name], entity)
      }
    }
  }

  /**
   * Create handlers for bound functions and actions and add them to the instance of the client.
   * @param name {string}
   * @param element {Object}
   * @param [entity] {Object}
   * @private
   */
  _createBoundFunctionsAndActions (name, element, entity) {
    const helperKey = this._getHelperKey(name, entity)

    // 1+ entities might have the same bound function/action
    this._boundEventsHelper[helperKey] = {
      argsParser: handlerArguments(element, entity),
      postProcess: handlerPostProcess(element),
      target: entity
    }

    if (this[name]) {
      return
    }

    this[name] = (entity, ...args) => {
      let _request

      const helperKey = this._getHelperKey(name, entity)
      const thenable = {
        withRequest: req => {
          _request = this._startTransactionProperty(req)
          return thenable
        },
        then: (resolve, reject) => {
          return this._eventToService(
            name,
            this._boundEventsHelper[helperKey].target,
            undefined,
            this._boundEventsHelper[helperKey].argsParser(args),
            _request
          )
            .then(this._boundEventsHelper[helperKey].postProcess)
            .then(resolve)
            .catch(reject)
        },
        catch: reject => {
          return this._eventToService(
            name,
            this._boundEventsHelper[helperKey].target,
            undefined,
            this._boundEventsHelper[helperKey].argsParser(args),
            _request
          ).catch(reject)
        }
      }

      return thenable
    }
  }

  _getHelperKey (name, entity) {
    return `${(entity.name || entity).replace(/^.+\./, '')}:${name}`
  }

  /**
   * Find all unbound actions and functions.
   * Add them as static functions to this instance.
   * @private
   */
  _addUnboundEvents () {
    const elements = this.model.all(element => {
      return element.kind === 'action' || element.kind === 'function'
    })

    for (const element of elements) {
      const [, name] = element.name.match(/^(?:.*\.)?([^.]+)$/)
      this._createUnboundFunctionsAndActions(name, element)
    }
  }

  /**
   * Create handlers for unbound functions and actions and add them to the instance of the client.
   * @param name {string}
   * @param element {Object}
   * @private
   */
  _createUnboundFunctionsAndActions (name, element) {
    const fqn = element.name
    const argsParser = handlerArguments(element)
    const postProcess = handlerPostProcess(element)

    this[name] = (...args) => {
      let _request
      const thenable = {
        withRequest: req => {
          _request = this._startTransactionProperty(req)
          return thenable
        },
        then: (resolve, reject) => {
          return this._eventToService(fqn, undefined, undefined, argsParser(args), _request)
            .then(postProcess)
            .then(resolve)
            .catch(reject)
        },
        catch: reject => {
          return this._eventToService(fqn, undefined, undefined, argsParser(args), _request).catch(reject)
        }
      }

      return thenable
    }
  }

  /**
   * Create an entity and use any prototype function the INSERT API offers.
   * @param entity {Object}
   * @returns {Promise}
   */
  create (entity) {
    return this._promised('CREATE', entity)
  }

  /**
   * Read an entity and use any prototype function the SELECT API offers.
   * @param entity {Object}
   * @param [key] {Array|Object}
   * @returns {Promise}
   */
  read (entity, key) {
    return this._promised('READ', entity, key)
  }

  /**
   * Update an entity and use any prototype function the UPDATE API offers.
   * @param entity {Object}
   * @param [key] {Object}
   * @returns {Promise}
   */
  update (entity, key) {
    return this._promised('UPDATE', entity, key)
  }

  /**
   * Delete an entity and use any prototype function the DELETE API offers.
   * @param entity {Object}
   * @param [key] {Object}
   * @returns {Promise}
   */
  delete (entity, key) {
    return this._promised('DELETE', entity, key)
  }

  /**
   * Insert an entity and use any prototype function the INSERT API offers.
   * @param data {Object}
   * @returns {Promise}
   */
  insert (data) {
    let _entity

    const insert = {
      into: entity => {
        _entity = entity

        return insert
      },
      then: (resolve, reject) => {
        return this._create(_entity, data)
          .then(resolve, reject)
          .catch(reject)
      },
      catch: reject => {
        return this._create(_entity, data).catch(reject)
      }
    }

    return insert
  }

  _promisedCqnForTransaction (clientFn, context, ...args) {
    const promisedCqn = this[clientFn](...args)

    const thenFn = promisedCqn.then
    promisedCqn.then = (resolve, reject) => {
      if (context) {
        promisedCqn.withRequest(context)
      }

      return thenFn(resolve, reject)
    }

    return promisedCqn
  }

  /**
   * Transaction wrapper to provide same API for local client, rest client and db facade
   * Eventually, queries are executed using `client.create`, etc..
   *
   * Caution: Even though transaction keyword is used, the queries are executed independently and NOT in a transaction fashion
   *
   * @param {*} [context] - request context
   */
  transaction (context) {
    const tx = {
      create: entity => {
        return this._promisedCqnForTransaction('create', context, entity)
      },
      delete: (entity, key) => {
        return this._promisedCqnForTransaction('delete', context, entity, key)
      },
      read: (entity, key) => {
        if (entity.SELECT) return tx.run(entity)
        return this._promisedCqnForTransaction('read', context, entity, key)
      },
      update: (entity, key) => {
        return this._promisedCqnForTransaction('update', context, entity, key)
      },
      insert: data => {
        return {
          into: entity => {
            return this._promisedCqnForTransaction('create', context, entity).entries(data)
          }
        }
      },
      run: query => {
        const newQuery = followProjection(query, this)
        return this._promisedCqnForTransaction('run', context, newQuery)
      }
    }
    return tx
  }

  _create (entity, data, reject) {
    if (!entity) {
      return Promise.reject(getNotInModelEntityError(this.options.service, 'CREATE', entity, this.model))
    }

    return this._promised('CREATE', entity).entries(data)
  }

  /**
   * Run any type of query against the service
   * @param query
   * @returns {Promise} which rejects in case no valid data provided
   */
  run (query) {
    if (typeof query === 'string') {
      query = global.cds.parse.cql(query)
    }

    return this._runCqnByService(query)
  }

  _runCqnByService (query) {
    if (!query) {
      return Promise.reject(new Error('Cannot run query. No query provided.'))
    }

    if (query.SELECT) {
      return this._cqnToService('READ', this._getEntity(query.SELECT.from), query)
    }

    if (query.INSERT) {
      return this._cqnToService('CREATE', query.INSERT.into, query)
    }

    if (query.UPDATE) {
      return this._cqnToService('UPDATE', query.UPDATE.entity, query)
    }

    if (query.DELETE) {
      return this._cqnToService('DELETE', query.DELETE.from, query)
    }

    return Promise.reject(new Error('Cannot run query. Invalid query provided.'))
  }

  _getEntity (from) {
    if (from.join) {
      from = from.args[0].ref ? from.args[0] : from.args[from.args.length - 1]
    }

    return from.ref[from.ref.length - 1]
  }

  _runCqnAtService (event, entity, query, context) {
    const normalizedEntity = this._validateEntity(entity)

    if (!normalizedEntity) {
      return Promise.reject(getNotInModelEntityError(this.options.service, event, entity, this.model))
    }

    // FIX for srv.read('Authors') vs srv.run(SELECT.from('Authors')) -> latter fails
    if (query.SELECT && query.SELECT.from.ref && query.SELECT.from.ref[0] !== normalizedEntity.name) {
      entity = query.SELECT.from.ref[0] = normalizedEntity.name
    }

    return this._eventToService(event, normalizedEntity, query, undefined, context)
  }

  _cqnToService (event, entity, query) {
    let _request

    const thenable = {
      withRequest: req => {
        _request = this._startTransactionProperty(req)
        return thenable
      },
      then: (resolve, reject) => {
        return this._runCqnAtService(event, entity, query, _request)
          .then(resolve)
          .catch(reject)
      },
      catch: reject => this._runCqnAtService(event, entity, query, _request).catch(reject)
    }

    return thenable
  }

  /**
   * Lazy loading and decoration of QL API.
   * @returns {Object}
   * @private
   */
  get _statements () {
    const { SELECT, INSERT, UPDATE, DELETE } = global.cds.ql
    const statements = {
      SELECT: {
        from: (entity, columns) => {
          return SELECT.from(entity, columns, this.model)
        },
        one: (entity, columns) => {
          return SELECT.one(entity, columns, this.model)
        }
      },
      INSERT: INSERT,
      UPDATE: UPDATE,
      DELETE: DELETE
    }

    Object.defineProperty(this, '_statements', { value: statements })

    return statements
  }

  _startTransactionProperty (context) {
    if (!context._) {
      context._ = { shared: {} }
    }

    if (!context._.shared) {
      context._.shared = {}
    }

    // Batch request request
    if (context._.shared.doNotFinishTransaction) {
      if (!context._.shared[OPEN_REQUESTS]) {
        context._.shared[IS_BATCH] = true
      } else {
        context._.shared[OPEN_REQUESTS]++
      }
    } else {
      context._.shared.doNotFinishTransaction = true
      context._.shared[OPEN_REQUESTS] = 1
    }

    return context
  }

  _fillColumnsForSelect (cqn, csnEntity) {
    if (cqn.SELECT && !cqn.SELECT.columns) {
      cqn.columns(getColumns(csnEntity, true, true))
    }
  }

  /**
   * Extend an QL API object instance to be a promise.
   * If then or catch are used, the query is run against the data source.
   * @param event {String}
   * @param entity {Object}
   * @param [key] {Array|Object}
   * @returns {Promise}
   * @private
   */
  _promised (event, entity, key) {
    const normalizedEntity = this._validateEntity(entity)

    if (!normalizedEntity) {
      return this._errorReturn(event, entity)
    }

    const cqn = this._createCQN(event, normalizedEntity, key)

    if (typeof key === 'object' && !Array.isArray(key) && cqn.where) {
      cqn.where(key)
    }

    let _context

    cqn.withRequest = req => {
      _context = this._startTransactionProperty(req)

      return cqn
    }
    cqn.then = (resolve, reject) => {
      this._fillColumnsForSelect(cqn, normalizedEntity)
      return this._eventToService(event, normalizedEntity, cqn, undefined, _context)
        .then(resolve)
        .catch(reject)
    }
    cqn.catch = reject => {
      this._fillColumnsForSelect(cqn, normalizedEntity)
      return this._eventToService(event, normalizedEntity, cqn, undefined, _context).catch(reject)
    }

    return cqn
  }

  /**
   * Simulate a rejected promise with a thenable in cases the entity is unknown.
   * @param event {String}
   * @param entity {Object}
   * @returns {Object}
   * @private
   */
  _errorReturn (event, entity) {
    const rejected = Promise.reject(
      getNotInModelEntityError(
        this.options.service,
        event,
        typeof entity === 'object' ? entity.name : entity,
        this.model
      )
    )

    const cqn = this._createCQN(event, 'dummy')
    cqn.withRequest = () => cqn
    cqn.then = (resolve, reject) => {
      return rejected.catch(reject)
    }
    cqn.catch = reject => {
      return rejected.catch(reject)
    }

    return cqn
  }

  /**
   * Try to find the entity or identify the entity given as string.
   * @param entity {Object}
   * @returns {Object|Boolean}
   * @private
   */
  _validateEntity (entity) {
    if (!entity) {
      return false
    }

    const name = typeof entity === 'object' ? entity.name : entity
    const definitions = this.model.definitions
    const service = this.options.service

    if (definitions[name]) {
      return definitions[name]
    }

    if (definitions[`${service}.${name}`]) {
      return definitions[`${service}.${name}`]
    }

    const parts = name.split('_')

    return parts.length === 1 ? false : this._validateEntity(parts.pop())
  }

  /**
   * The default events for actions and functions are well known.
   * Translate them into constructing calls against the QL API.
   * @param event {String}
   * @param entity {Object}
   * @param [columns] {Array}
   * @returns {Object}
   * @private
   */
  _createCQN (event, entity, columns) {
    switch (event) {
      case 'READ':
        return this._statements.SELECT.from(entity, columns, this.model)
      case 'CREATE':
        return this._statements.INSERT.into(entity)
      case 'UPDATE':
        return this._statements.UPDATE(entity)
      case 'DELETE':
        return this._statements.DELETE.from(entity)
    }
  }

  /**
   * Adds properties of sharedContext to context if available
   * @param {*} context - to be enhanced
   * @param {*} sharedContext - source context
   */
  _enhanceContextWithSharedContext (context, sharedContext) {
    context._ = sharedContext._
    context.user = sharedContext.user || { id: 'anonymous' }
    context.attr = sharedContext.attr

    if (sharedContext.run) {
      context.run = sharedContext.run
    }

    if (sharedContext.draftMetadata) {
      context.draftMetadata = sharedContext.draftMetadata
    }

    if (sharedContext.user) {
      context.user = sharedContext.user
    }

    if (sharedContext.attr) {
      context.attr = sharedContext.attr
    }

    if (sharedContext.info) {
      context.info = sharedContext.info
    }

    if (sharedContext._txId) {
      context._txId = sharedContext._txId
    }
  }

  /**
   * Create a context object for the service call.
   * @param event {String}
   * @param [entity] {Object}
   * @param [cqn] {Object}
   * @param [data] {Object}
   * @param [sharedContext] {Object}
   * @returns {*}
   * @private
   */
  _createContextObject (event, entity, cqn, data, sharedContext) {
    const context = {
      event: event,
      get data () {
        const parsed = data || cqnToData(cqn)
        Object.defineProperty(context, 'data', { value: parsed })
        return parsed
      },
      statements: this._statements
    }

    if (entity) {
      context.target = entity
    }

    if (cqn) {
      context.query = cqn
    }

    if (sharedContext) {
      this._enhanceContextWithSharedContext(context, sharedContext)
    } else {
      context._ = { shared: {} }
      context.user = {
        id: 'anonymous'
      }
      context.attr = {
        scopes: []
      }
    }

    // Supporting legacy data services, where the connect does not include a model definition.
    Object.defineProperty(context, MODEL, { value: this.model })

    if (context.target) {
      convertDateTime(context.data, context.target.elements)
    }

    Reflect.setPrototypeOf(context, EventEmitter.prototype)
    return context
  }

  _endTransactionProperty (_) {
    if (_.shared[IS_BATCH]) {
      return
    }

    _.shared[OPEN_REQUESTS]--

    if (_.shared[OPEN_REQUESTS] === 0) {
      delete _.shared.doNotFinishTransaction
    }
  }

  /**
   * Dispatch the API call to the underlying service.
   * @param event {String}
   * @param entity {Object}
   * @param cqn {Object}
   * @param [data] {Object}
   * @param [sharedContext] {Object}
   * @returns {Promise<Array>}
   * @private
   */
  _eventToService (event, entity, cqn, data, sharedContext) {
    const context = this._createContextObject(event, entity, cqn, data, sharedContext)

    return this.processEvent(context)
      .then(result => {
        // REVISIT: the transaction id should be in the original context already
        // add the newly created tx id to the outer context
        if (sharedContext && !sharedContext._txId) {
          sharedContext._txId = context._txId
        }

        this._endTransactionProperty(context._)

        context.emit('succeeded')
        context.emit('done')

        if (context.event === 'READ' && context.query.SELECT.one) {
          return result[0]
        }

        return result
      })
      .catch(err => {
        this._endTransactionProperty(context._)

        context.emit('failed', err)
        context.emit('done')

        throw err
      })
  }
}

module.exports = Client
