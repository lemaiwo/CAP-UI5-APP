/**
 * Complex cases have brackets and conditions.
 * @param value {string}
 * @return {boolean}
 * @private
 */
const _bracketOrOperator = value => {
  switch (value) {
    case '(':
    case ')':
    case 'and':
    case 'or':
      return true
    default:
      return false
  }
}

/**
 * Only limited combinations are supported.
 * @param data {Object}
 * @param left {Object}
 * @param right {Object}
 * @private
 */
const _equalsToData = (data, left, right) => {
  if (left.ref && right.val) {
    data[left.ref[left.ref.length - 1]] = right.val
  } else if (left.val && right.ref) {
    data[right.ref[right.ref.length - 1]] = left.val
  }
}

/**
 * Translate simple cases of where to data object.
 * @param where {Array}
 * @returns {Object}
 * @private
 */
const _whereToData = (where = []) => {
  const data = {}
  const length = where.length
  let i = 0

  while (i < length) {
    // Element is indicator for complex and/or nested
    if (_bracketOrOperator(where[i])) {
      i++
    } else if (where[i + 1] === 'between') {
      i += 5
    } else {
      if (where[i + 1] === '=') {
        _equalsToData(data, where[i], where[i + 2])
      }

      i += 3
    }
  }

  return data
}

/**
 * Parse update column to value into a data object.
 * @param update {Object}
 * @returns {Object}
 * @private
 */
const _updateToData = (update = {}) => {
  const data = {}

  for (const column of Object.keys(update)) {
    if (update[column] != null && update[column].val !== undefined) {
      data[column] = update[column].val
    } else if (update[column] === null || !(update[column].xpr || update[column].func || update[column].ref)) {
      data[column] = update[column]
    }
  }

  return data
}

/**
 * Rows + values to data.
 * @param insert {Object}
 * @return {Object}
 * @private
 */
const _rowsToData = insert => {
  const data = []

  for (const row of insert.rows) {
    const dataRow = {}

    for (let i = 0, length = row.length; i < length; i++) {
      dataRow[insert.columns[i]] = row[i]
    }

    data.push(dataRow)
  }

  return data
}

/**
 * Insert to data, where rows only is not supported.
 * @param insert {Object}
 * @return {Object|Array}
 * @private
 */
const _insertToData = insert => {
  let data = {}

  if (insert.entries) {
    data = insert.entries
  }

  if (insert.columns && insert.rows) {
    data = _rowsToData(insert)
  }

  return data.length === 1 ? data[0] : data
}

/**
 * Translate a CQN object into a data object.
 * @param cqn {Object}
 * @return {Object|Array}
 */
module.exports = (cqn = {}) => {
  if (cqn.SELECT) {
    return _whereToData(cqn.SELECT.where)
  }

  if (cqn.UPDATE) {
    return Object.assign(_updateToData(cqn.UPDATE.set), _updateToData(cqn.UPDATE.data), _whereToData(cqn.UPDATE.where))
  }

  if (cqn.DELETE) {
    return _whereToData(cqn.DELETE.where)
  }

  if (cqn.INSERT) {
    return _insertToData(cqn.INSERT)
  }

  return {}
}
