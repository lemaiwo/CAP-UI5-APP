const {
  activeVersionExists,
  ensureNoDraftsSuffix,
  proxifyToNoDraftsName,
  ensureDraftsSuffix
} = require('../utils/draftUtils')
const { readAndDeleteKeywords, isActiveEntityRequested } = require('../utils/draftWhereUtils')
const { readDraftCompositionTree } = require('../utils/readDraftCompositionTree')
const {
  messages: { DB_CONNECTION_MISSING }
} = require('../utils/constants')
const { isDraftRootEntity } = require('../utils/compositionTree')
const _isLocked = (InProcessByUser, id) => InProcessByUser && InProcessByUser !== id

const _getDeleteDraftAdminCqn = (draftUUID, DELETE) =>
  DELETE.from('DRAFT.DraftAdministrativeData').where([{ ref: ['DraftUUID'] }, '=', { val: draftUUID }])

const _getDeleteRootDraftCqn = (targetName, rootWhere, DELETE) => DELETE.from(targetName).where(rootWhere)

/**
 * Generic Handler for draftActivate requests.
 * In case of success it triggers an 'UPDATE' or 'CREATE' event.
 *
 * @param context - operation object, that provides error, continuation and other functions as well as information
 * regarding the current operation.
 * @alias module:handlers.onDraftActivate
 */
const onDraftActivateEvent = service => async context => {
  // TODO: Write admin data to context. Beware: context.draft should not be used
  //       since active date needs to be modified (context.draft will be used as
  //       an indicator that only draft data is modified)
  if (!context.run) {
    context.log.warn(DB_CONNECTION_MISSING)
    context.reject(404)
    return
  }

  if (
    isActiveEntityRequested(context.query.SELECT.where || []) ||
    context._.odataReq.getUriInfo().getPathSegments().length > 2 ||
    !isDraftRootEntity(service.model.definitions, ensureNoDraftsSuffix(context.target.name))
  ) {
    context.reject(400)
    return
  }

  const draftCompositionTree = await readDraftCompositionTree(service, context)

  if (context.rejected) {
    return
  }

  if (draftCompositionTree.data.length === 0) {
    context.reject(404)
    return
  }

  if (_isLocked(draftCompositionTree.administrativeData.InProcessByUser, context.user.id)) {
    context.reject(403)
    return
  }

  context.draftMetadata = draftCompositionTree.administrativeData

  // new object to have 'real' object
  const data = Object.assign({}, draftCompositionTree.data[0])

  // REVISIT: no copies, if possible
  const newContext = Object.create(context, { target: { value: proxifyToNoDraftsName(context.target) } })

  const deleteDraftAdminCqn = _getDeleteDraftAdminCqn(context.draftMetadata.DraftUUID, context.statements.DELETE)
  const deleteRootDraftCqn = _getDeleteRootDraftCqn(
    ensureDraftsSuffix(context.target.name),
    context.query.SELECT.where,
    context.statements.DELETE
  )

  await Promise.all([context.run(deleteDraftAdminCqn), context.run(deleteRootDraftCqn)])

  if (await activeVersionExists(context)) {
    readAndDeleteKeywords(['IsActiveEntity'], context.query.SELECT.where)

    const result = await service
      .update(newContext.target)
      .data(data)
      .where(newContext.query.SELECT.where)
      .withRequest(newContext)

    // REVISIT: the transaction id should be in the original context already
    // add the newly created tx id to the original context
    if (!context._txId) {
      context._txId = newContext._txId
    }

    return result
  }

  const result = await service
    .create(newContext.target)
    .entries(data)
    .withRequest(newContext)

  // REVISIT: the transaction id should be in the original context already
  // add the newly created tx id to the original context
  if (!context._txId) {
    context._txId = newContext._txId
  }

  return result
}

module.exports = onDraftActivateEvent
