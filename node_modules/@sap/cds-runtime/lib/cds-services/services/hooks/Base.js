const { isDraftEnabled } = require('../../../common/utils/draft')

const {
  getNotInModelAssociationError,
  getNotInModelEntityError,
  getNotInModelEventError,
  getInvalidEntityPathError,
  getMissingTargetAssociationError
} = require('../../util/errors')
const { ensureDraftsSuffix } = require('../utils/draftUtils')
const { resolve, reject } = require('../../util/thenable')
const { combineErrors } = require('../../util/errors')
const {
  events: { DEFAULT, TRANSACTION, DRAFT }
} = require('../utils/constants')

/**
 * Base class for hooks middleware.
 */
class Base {
  /**
   * Constructs a middleware handler.
   * @param {object} reflected - the reflected CSN model.
   * @param {string} service - Service name as specified in CSN.
   */
  constructor (reflected, service) {
    this._handlers = []
    this._model = reflected
    this._service = service

    this._isWithMode = false
  }

  startAddingWithHandlers () {
    this._isWithMode = true
    this._withHandlers = []
  }

  finishAddingWithHandlers () {
    this._isWithMode = false
    this._handlers.unshift(...this._withHandlers)
    delete this._withHandlers
  }

  /**
   * Add a handler for a specific event type and entity. N handlers per type and entity can be registered.
   * @param {string|Array} [event] - Name of event like 'CREATE', 'UPDATE', 'DELETE', or an array of events
   * @param {string|Object} [entity] - Name of the entity or CSN entity, or an array of entities.
   * @param {function|Object} handler - To be executed event handler. It could be function or CQN object.
   * @throws Error - If invalid input data provided.
   */
  use (event, entity, handler) {
    if (!event && !entity && !handler) {
      throw new Error('Cannot register event handler. No input data provided.')
    }

    if (!entity && !handler) {
      this.use(undefined, undefined, event)
    } else if (!handler) {
      this._normalizeNoEntity(event, entity)
    } else if (Array.isArray(event)) {
      for (const entry of event) {
        this.use(entry, entity, handler)
      }
    } else if (Array.isArray(entity)) {
      for (const entry of entity) {
        this.use(event, entry, handler)
      }
    } else if (typeof entity === 'string' && entity.includes('/')) {
      this.use(event, this._getPathEntity(entity, event), handler)
    } else {
      this._add(this._normalizeEvent(event), this._objectEntityToString(entity), this._generateHandlerIfCQN(handler))
    }
  }

  _getPathEntity (entityPath, event) {
    const path = entityPath.split('/')
    if (path[0] === '') {
      throw getInvalidEntityPathError(this._service, event, entityPath, this._model)
    }
    let entity = this._model.definitions[`${this._service}.${path[0]}`]
    if (!entity) {
      throw getNotInModelEntityError(this._service, event, `${this._service}.${path[0]}`, this._model)
    }

    for (let i = 1, len = path.length; i < len; i++) {
      let assoc = entity.elements[path[i]]
      if (!assoc) {
        throw getNotInModelAssociationError(this._service, this._model, event, entityPath, path[i], entity.name)
      }
      const entityName = entity.name
      entity = assoc._target
      if (!entity) {
        throw getMissingTargetAssociationError(this._service, this._model, event, path[i], entityName)
      }
    }

    return entity
  }

  _normalizeNoEntity (event, handler) {
    if (this._isModeledEntity(this._objectEntityToString(Array.isArray(event) ? event[0] : event))) {
      this.use(undefined, event, handler)
    } else {
      this.use(event, undefined, handler)
    }
  }

  _add (event, entity, handler) {
    if (typeof handler !== 'function') {
      throw new Error(
        'Cannot register event handler. Invalid handler provided, should be of type function or a CQN object.'
      )
    }

    this._entityParamValid(entity, event)
    if (this._eventParamIsCommand(event, entity)) {
      if (entity && DRAFT.includes(event) && event !== 'EDIT' && event !== 'SAVE') {
        entity = ensureDraftsSuffix(entity)
      }
      this._addHandler(event, entity, handler)
    } else if (!entity && this._messagingService) {
      this._messagingService.on(event, handler)
    } else {
      throw getNotInModelEventError(this._service, event, this._model)
    }
  }

  _getIdForPerfMeasure (context, handler) {
    let id = `${context.performanceMeasurement.uuid} 1 ${this.constructor.name} ${handler.event || context.event}`

    if (handler.entity) {
      id += ` ${handler.entity}`
    }

    id += ` ${handler.handler.name || 'anonymous'}`
    id += handler.handler.isDefault ? ' default' : ' custom'

    return id
  }

  _getStartMark (id) {
    return `${id} Start`
  }

  _getEndMark (id) {
    return `${id} End`
  }

  _measureStartTime (context, handler) {
    const performanceMeasurement = context.performanceMeasurement

    if (performanceMeasurement) {
      performanceMeasurement.performance.mark(this._getStartMark(this._getIdForPerfMeasure(context, handler)))
    }
  }

  _measureEndTime (context, handler) {
    const performanceMeasurement = context.performanceMeasurement

    if (performanceMeasurement) {
      const id = this._getIdForPerfMeasure(context, handler)
      const startMark = this._getStartMark(id)
      const endMark = this._getEndMark(id)

      performanceMeasurement.performance.mark(endMark)
      performanceMeasurement.performance.measure(id, startMark, endMark)
    }
  }

  _normalizeEvent (event) {
    const eventToFullyQualified = this._eventToFullyQualified(event)

    if (this._isUnboundCustomOperation(eventToFullyQualified)) {
      return eventToFullyQualified
    }

    return event
  }

  _generateHandlerIfCQN (handler) {
    if (this._isCQN(handler)) {
      return context => {
        return context.run(handler)
      }
    }

    return handler
  }

  _eventToFullyQualified (event) {
    if (!this._isDefaultEvent(event) && typeof event === 'string') {
      return event.startsWith(this._service) ? event : `${this._service}.${event}`
    }

    return event
  }

  _objectEntityToString (entity) {
    if (typeof entity === 'object') {
      return entity.kind === 'entity' && entity.name ? entity.name : false
    }

    if (typeof entity === 'string' && !entity.startsWith(this._service)) {
      return `${this._service}.${entity}`
    }

    return entity
  }

  _isCQN (object) {
    if (!object || typeof object !== 'object') {
      return false
    }

    if (object.SELECT) {
      return true
    }

    if (object.INSERT) {
      return true
    }

    if (object.UPDATE) {
      return true
    }

    return Boolean(object.DELETE)
  }

  /**
   * Basic check if the specified entity is a valid parameter for the event handler.
   * @param {string} entity - Entity parameter
   * @throw Error - if invalid entity provided
   * @private
   */
  _entityParamValid (entity, event) {
    if (!entity && entity !== false) {
      return
    }

    // Check if provided entity is defined in the reflection model
    if (typeof entity !== 'string' || !this._isModeledEntity(entity)) {
      throw getNotInModelEntityError(this._service, event, entity, this._model)
    }
  }

  _isDefaultEvent (event) {
    return DEFAULT.includes(event)
  }

  _isTransactionEvent (event) {
    return TRANSACTION.includes(event)
  }

  /**
   * Basic check if the specified event is a valid parameter for the event handler.
   * @param {string} event - Event parameter
   * @param {string} [entity] - Entity parameter
   * @private
   */
  _eventParamIsCommand (event, entity) {
    // No check for validity of custom operations required
    if (!event || event === '*' || this._isDefaultEvent(event)) {
      return true
    }

    // Check if provided unbound custom operation is contained in the reflection model
    if (entity === undefined && this._isUnboundCustomOperation(event)) {
      return true
    }

    // Check if provided bound custom operation is defined within the provided entity in the reflection model
    if (entity !== undefined && this._isBoundCustomOperation(entity, event)) {
      return true
    }
    return false
  }

  /**
   * Checks whether or not an entity exists in the reflection model.
   * @param entity
   * @returns {boolean}
   * @private
   */
  _isModeledEntity (entity) {
    if (!entity) {
      return false
    }

    const serviceEntity = entity.startsWith(this._service) ? entity : `${this._service}.${entity}`
    return this._model.find(d => d.kind === 'entity' && d.name === serviceEntity) !== undefined
  }

  /**
   * Checks whether or not a provided event exists as unbound custom operation in the reflection model.
   * @param {string} event
   * @returns {boolean}
   * @private
   */
  _isUnboundCustomOperation (event) {
    return this._model.find(d => ['action', 'function'].includes(d.kind) && d.name === event) !== undefined
  }

  /**
   * Checks whether or not a provided event exists as bound custom operation in the reflection model.
   * @param {string} entity
   * @param {string} event
   * @returns {boolean}
   * @private
   */
  _isBoundCustomOperation (entity, event) {
    return (
      this._model.find(
        d =>
          d.kind === 'entity' &&
          d.name === entity &&
          ((d.actions && d.actions[event]) || this._isDraftAction(event, entity))
      ) !== undefined
    )
  }

  _isDraftAction (event, entity) {
    return isDraftEnabled(this._model.definitions[entity]) && DRAFT.includes(event)
  }

  /**
   * Adds a middleware handler to the set.
   * @param event
   * @param entity
   * @param handler
   * @private
   */
  _addHandler (event, entity, handler) {
    if (this._isWithMode) {
      this._withHandlers.push({ event, entity, handler })
    } else {
      this._handlers.push({ event, entity, handler })
    }
  }

  /**
   * Check if the handler should handle this event.
   * @return {boolean}
   * @private
   */
  _match (event, context, entry) {
    return (
      (entry.event === event ||
        ((!entry.event || entry.event === '*') && !this._isTransactionEvent(event)) ||
        (entry.event === 'SAVE' && (event === 'CREATE' || event === 'UPDATE'))) &&
      (!entry.entity || entry.entity === '*' || (context.target && entry.entity === context.target.name))
    )
  }

  _handleErrors (context, result) {
    if (!context.errors || context.errors.length === 0) {
      return result
    }

    throw combineErrors(context.errors)
  }

  _endPhase (context) {
    if ('rejected' in context) {
      return reject(context.rejected)
    }

    if ('results' in context) {
      return resolve(context.results)
    }
  }
}

module.exports = Base
