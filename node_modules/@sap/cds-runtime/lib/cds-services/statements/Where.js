const BaseStatement = require('./BaseStatement')
const { ensureNoDraftsSuffix } = require('../services/utils/draftUtils')
const { unexpectedFunctionCallError, invalidFunctionArgumentError } = require('../util/errors')

const MODEL = Symbol.for('sap.cds.model')
const fnChain = Symbol.for('sap.cds.fnChain')

class Where extends BaseStatement {
  get cqn () {
    return this.SELECT || this.UPDATE || this.DELETE
  }

  /**
   * Build 'where' cqn object. Can be chained and will always connect the chained where with an 'and'.
   *
   * Possible uses:
   * where('ID', <value>)
   * where('ID', '<operator>', <value>)
   * where('ID', 'between', <value>, <value>)
   * where('ID', '<operator>', <query>)
   * where('Association.name', '<operator>', <value>)
   * where('lower(column)', '<operator>', <value>)
   * where(<object>)
   * Fluid usage with alternating string value arguments
   * where(arg1, arg2, arg3, ...)
   *
   * @example
   * where('ID', 7411)
   * where('ID', '>', 7411)
   * where({ ID: 7411})
   * where({ or: [{ ID: 7411}, { ID: 2511}]})
   * Fluid usage:
   * where(`name like`, 'foo', `and ( ratio between`, 0.1, `and`, 0.3, `or ratio >`, 0.9, ')')
   *
   * @returns {Object} this object instance for chaining.
   * @throws Error - If .having() called before .where() or if no valid first argument provided
   */
  where (...args) {
    if (!args[0]) return this
    const { cqn } = this
    if (cqn.having) throw unexpectedFunctionCallError('.having()', '.where()')
    if (cqn.where) return this._andWhere(...args)
    cqn.where = []
    this[fnChain] = this[fnChain].concat('.where()')
    return this._where(...args)
  }

  /**
   * .and can only be used after .join has been called.
   * @param {string|Object} arg1 Can be object if argument is passed as an object or can be a string when an identifier is directly passed.
   * @param {*} [arg2] Can be a value or an operator if the 3rd argument is the value.
   * @param [arg3] Value or CQN if second argument is operator.
   * @param [arg4] Value in case the second argument is the 'between' operator; Otherwise ignored.
   * @returns {Object} this object instance for chaining.
   * @throws Error - If called without calling join or where before.
   */
  and (...args) {
    if (args.length === 0) return this
    this[fnChain] = this[fnChain].concat('.and()')
    return this._logicOperation('and', ...args)
  }

  /**
   * .byId filters on the column 'id'. It can only be used if .where has not been called yet.
   * @param {string} arg1 is the value on which the filtering should be performed.
   * @returns {Object} this object instance for chaining
   */
  byId (arg1) {
    this[fnChain] = this[fnChain].concat('.byId()')
    return this.where('id', arg1)
  }

  /**
   * @param {string|Object} arg1 Can be object if argument is passed as an object or can be a string when an identifier is directly passed.
   * @param {*} [arg2] Can be a value or an operator if the 3rd argument is the value.
   * @param [arg3] Value or CQN if second argument is operator.
   * @param [arg4] Value in case the second argument is the 'between' operator; Otherwise ignored.
   * @returns {Object} this object instance for chaining.
   * @throws Error - If called without calling join or where before.
   */
  or (...args) {
    this[fnChain] = this[fnChain].concat('.or()')
    return this._logicOperation('or', ...args)
  }

  _andWhere () {
    return this._setAndOrBracket('and', 'where', ...arguments)
  }

  _setFirstAndOrBracket (clause) {
    if (
      this.cqn[clause] &&
      this.cqn[clause].lastIndexOf('and') === this.cqn[clause].lastIndexOf('or') &&
      this.cqn[clause][0] !== '('
    ) {
      this.cqn[clause].unshift('(')
    }
  }

  _setAndOrBracket (operator, clause, ...args) {
    const cqn = this.cqn
    // set brackets if .or, .where or .having are chained
    const lastSame = cqn[clause] && cqn[clause].lastIndexOf(operator)
    const lastDif =
      operator === 'or' ? cqn[clause] && cqn[clause].lastIndexOf('and') : cqn[clause] && cqn[clause].lastIndexOf('or')

    // no brackets in case of fluid usage
    if (args.length > 4 || this._hasExpressionIndicator(args[0])) {
      cqn[clause].push(operator)
      return clause === 'where' ? this._where(...args) : this._having(...args)
    }

    this._setFirstAndOrBracket(clause)
    cqn[clause].push(operator)

    if (lastSame > lastDif && cqn[clause][cqn[clause].length - 2] === ')') {
      cqn[clause].splice(cqn[clause].length - 2, 1)
    } else if (lastDif > lastSame && cqn[clause][cqn[clause].length - 2] === ')') {
      cqn[clause].push('(')
    }

    clause === 'where' ? this._where(...args) : this._having(...args)
    const needLastBracket = cqn[clause].filter(i => i === '(').length > cqn[clause].filter(i => i === ')').length
    if (needLastBracket) {
      cqn[clause].push(')')
    }
    return this
  }

  _logicOperation (operator, ...args) {
    const cqn = this.cqn
    const isJoin = cqn.from && cqn.from.hasOwnProperty('join')
    const isWhere = cqn.where && cqn.where.length > 0
    const isHaving = cqn.having && cqn.having.length > 0

    if (operator === 'or' && (isHaving || isWhere)) {
      const clause = isHaving ? 'having' : 'where'
      return this._setAndOrBracket(operator, clause, ...args)
    }

    if (!isJoin && operator === 'or') {
      // or called without where before
      return this.where(...args)
    }

    if (!isJoin && operator === 'and') {
      return isHaving ? this.having(...args) : this.where(...args)
    }

    if (isJoin) {
      cqn.from.on.push(operator)
      cqn.from.on.push(...this._parseArguments(...args))

      return this
    }

    throw unexpectedFunctionCallError(operator, this[fnChain])
  }

  _replacePlaceholders (expr, placeholderMap) {
    for (const placeholder of placeholderMap.keys()) {
      const index = expr.xpr.findIndex(
        obj =>
          obj.SELECT && obj.SELECT.from && Array.isArray(obj.SELECT.from.ref) && obj.SELECT.from.ref[0] === placeholder
      )
      expr.xpr[index] = placeholderMap.get(placeholder)
    }
  }

  // fluid usage uses cds-compiler
  _fluidUsage (...args) {
    const tobeJoined = []
    let isPreviousExpr = false

    const placeholderStr = 'PARTIAL_CQN_PLACEHOLDER'
    const placeholderMap = new Map()
    let placeholderNum = 0

    for (let arg of args) {
      if (this._isCqn(arg)) {
        placeholderNum++

        const placeholder = `(SELECT FROM ${placeholderStr}_${placeholderNum})`
        placeholderMap.set(`${placeholderStr}_${placeholderNum}`, arg)

        tobeJoined.push(`${placeholder}`)
        isPreviousExpr = false
      } else if (isPreviousExpr && arg !== '') {
        tobeJoined.push(this._getArgAsString(arg))
        isPreviousExpr = false
      } else {
        isPreviousExpr =
          !isPreviousExpr && typeof arg === 'string' && this._hasExpressionIndicator(arg) ? true : isPreviousExpr
        tobeJoined.push(arg)
      }
    }

    const expr = global.cds.parse.expr(tobeJoined.join(' '))

    this._replacePlaceholders(expr, placeholderMap)

    return expr.xpr
  }

  _getArgAsString (arg) {
    if (Array.isArray(arg)) {
      return `(${arg})`
    } else if (typeof arg === 'number' || (typeof arg === 'string' && arg.match(/'.*?'/g))) {
      return arg
    } else {
      return `'${arg}'`
    }
  }

  _hasExpressionIndicator (s) {
    if (typeof s === 'string') {
      return /[<>=!]|.+?\s+(?:between|like|in)|^\s*(?:not\s+)?exists.*\s*|^\s*\(.*\)|^\s*(?:and|or)\s+.*$/i.test(s)
    }

    return false
  }

  _where (...args) {
    if (args.length === 0) return this // ignore attempts to add nothing
    // currently we support fluid usage with 4+ args
    // or with a first arg containing expression indicator
    if (args.length > 4 || this._hasExpressionIndicator(args[0])) {
      this.cqn.where.push(...this._fluidUsage(...args))
      return this
    }
    const needBrackets = typeof args[0] === 'object' && (args[0].or || args[0].and)
    needBrackets
      ? this.cqn.where.push('(', ...this._parseArguments(...args), ')')
      : this.cqn.where.push(...this._parseArguments(...args))
    return this
  }

  _isFunction (element) {
    if (element === null) {
      return false
    }

    if (typeof element === 'string') {
      return element.includes('(')
    }

    return false
  }

  _isOneArgFunction (arg1, arg2, arg3) {
    return this._isFunction(arg1) || this._isFunction(arg3) || this._isFunction(arg2)
  }

  _parseFunction (func) {
    if (typeof func === 'string') {
      return this._parseFunctionFromString(func)
    }
  }

  _splitArgs (argsString) {
    let bracketCounter = 0

    const commaIndex = []

    for (let i = 0; i < argsString.length; i++) {
      if (argsString.charAt(i) === '(') {
        bracketCounter++
      } else if (argsString.charAt(i) === ')') {
        bracketCounter--
      } else if (argsString.charAt(i) === ',' && bracketCounter === 0) {
        commaIndex.push(i)
      }
    }

    if (commaIndex.length > 0) {
      const args = []
      let lastIndex = 0

      for (const index of commaIndex) {
        args.push(argsString.substring(lastIndex, index))
        lastIndex = index + 1
      }
      args.push(argsString.substring(lastIndex, argsString.length))
      return args
    }

    return []
  }

  _parseValOrRef (str) {
    if (str === '*' || this._isNumber(str)) {
      return { val: str }
    }

    const valString = str.match(/^'(.*)'$/)
    if (valString) {
      return { val: valString[1] }
    }

    return this._buildRef(str.trim())
  }

  _fnArgs (str) {
    if (str.match(/^([^(]*)\((.*)\)$/)) {
      return this._parseFunctionFromString(str)
    } else {
      return this._parseValOrRef(str)
    }
  }

  _parseFunctionArgs (argsString, fnArgs = []) {
    if (argsString === '') {
      return []
    }

    const parts = this._splitArgs(argsString)
    if (parts.length > 0) {
      for (const part of parts) {
        fnArgs.push(this._fnArgs(part))
      }
    } else {
      fnArgs.push(this._fnArgs(argsString))
    }
    return fnArgs
  }

  _parseFunctionFromString (aggregation, cqnPartial = {}) {
    const fnArray = aggregation.match(/^([^(]*)\((.*)\)$/)
    cqnPartial.func = fnArray[1].toLowerCase()
    cqnPartial.args = fnArray[2] === '*' ? ['*'] : this._parseFunctionArgs(fnArray[2]) // * should not be wrapped as val here
    return cqnPartial
  }

  _isNumber (obj) {
    return !isNaN(obj)
  }

  _handleFunction (arg1, arg2, arg3) {
    if (!arg2) {
      throw invalidFunctionArgumentError(this[fnChain])
    }

    const comparison = arg3 === undefined ? '=' : arg2
    const value = arg3 === undefined ? arg2 : arg3

    const firstElement = this._isFunction(arg1) ? this._parseFunction(arg1) : this._valOrCqn(arg1)
    const secondElement = this._isFunction(value) ? this._parseFunction(value) : this._valOrCqn(value)

    return [firstElement, comparison.toLowerCase(), secondElement]
  }

  _valOrCqn (arg) {
    if (this._isCqn(arg)) {
      return arg
    }

    return { val: arg }
  }

  _parseArguments (...args) {
    if (Array.isArray(args[0]) && !args[1] && args[0].length > 0) {
      return args[0]
    }

    // currently between is not supported for functions
    if (this._isOneArgFunction(...args)) {
      return this._handleFunction(...args)
    }

    // TODO revisit this logic is completely wrong
    if (typeof args[0] === 'object') {
      if (args[0].func) {
        return [args[0]]
      }
      if (!this._isCqn(args[0])) {
        return this._parseObjectArgument(args[0])
      }
    }

    return this._parseNonSingleObjectArguments(...args)
  }

  _isCqn (arg) {
    return arg && (arg.xpr || arg.hasOwnProperty('val') || arg.ref || arg.SELECT)
  }

  _getTableNamesFrom (fromObj) {
    if (typeof fromObj === 'string') {
      // delete with string in from
      return [fromObj]
    }

    if (fromObj.name) {
      // delete with entity in from
      return [fromObj.name]
    }

    // select
    return this._extractRefs(fromObj)
  }

  _extractRefs (from) {
    if (from.hasOwnProperty('join')) {
      // cqn with join in from
      return this._refs(from.args)
    }

    if (from.hasOwnProperty('SET')) {
      // cqn UNION
      return from.as ? [from.as] : []
    }

    return from.as ? [from.ref[0], from.as] : [from.ref[0]]
  }

  _refs (refs) {
    const arr = []

    for (const element of refs) {
      if (element.hasOwnProperty('join')) {
        // multiple join are nested, se we need to find all the table names in there as well
        arr.push(...this._extractRefs(element))
      } else {
        arr.push(element.ref[0])

        if (element.as) {
          arr.push(element.as)
        }
      }
    }

    return arr
  }

  _getTableNamesEntity (entityObj) {
    if (typeof entityObj === 'string') {
      // update with string in entity
      return entityObj
    }

    if (entityObj.name) {
      // update with entity in entity
      return ensureNoDraftsSuffix(entityObj.name)
    }
  }

  _getTableNames () {
    const tableNames = []
    const cqn = this.cqn

    if (cqn.from) {
      // select and delete
      tableNames.push(...this._getTableNamesFrom(cqn.from))
    } else if (cqn.entity) {
      // update
      tableNames.push(this._getTableNamesEntity(cqn.entity))
    }

    return tableNames
  }

  _matchTableColumn (name = '') {
    const matches = name.match(/^(?:"(\w+(?:\.\w+)*)"|(\w+))\.(?:"(\w+(?:\.\w+)*)"|(\w+))$/)

    if (matches) {
      return matches.filter(this._filterForTableAndColumn)
    }
  }

  _matchInline (name) {
    return name
      .replace(/{/g, '')
      .replace(/}/g, '')
      .split(/\./)
  }

  _filterForTableAndColumn (element, index) {
    return index && element != null
  }

  _parseInlineAssociation (element, tableNames) {
    if (element.includes('.{')) {
      return { ref: this._matchInline(element) }
    }

    const parts = element.split(/\./)
    if (parts && this[MODEL]) {
      for (const table of tableNames) {
        // inline or column name  with dot
        if (this._isAssociation(table, parts[0])) {
          return { ref: parts }
        }
      }
    }
  }

  _buildWithTableName (element) {
    const tableNames = this._getTableNames()
    const matched = this._matchTableColumn(element)

    if (matched && tableNames.indexOf(matched[0]) !== -1) {
      return { ref: [matched[0], matched[1]] }
    }

    if (element.includes('.')) {
      return this._parseInlineAssociation(element, tableNames)
    }
  }

  _buildRef (element) {
    const ref = this._buildWithTableName(element)

    if (ref) {
      return ref
    }

    return { ref: [element] }
  }

  _buildValOrRef (element) {
    if (typeof element === 'string') {
      const ref = this._buildWithTableName(element)
      if (ref) {
        return ref
      }
    }

    return this._valOrCqn(element)
  }

  _refOrCqn (arg) {
    if (!this._isCqn(arg)) {
      return this._buildRef(arg)
    }

    return arg
  }

  _comparison (...args) {
    if (args.length > 2) {
      return args[1]
    }

    return '='
  }

  _value (...args) {
    if (args.length > 2) {
      return args[2]
    }

    return args[1]
  }

  _parseNonSingleObjectArguments (...args) {
    const ref = this._isFunction(args[0]) ? this._parseFunction(args[0]) : this._refOrCqn(args[0])
    const comparison = this._comparison(...args)
    const value = this._value(...args)

    if (args.length === 1) {
      // where({ref: [...]})
      return [ref]
    }

    if (value != null) {
      // skip null / undefined
      if (value instanceof RegExp) {
        return [ref, 'regexp', { val: String(value) }]
      }

      if (value.SELECT) {
        return [ref, comparison, value]
      }
    }

    if (args.length === 4) {
      return [ref, comparison, { val: value }, 'and', { val: args[3] }]
    }

    return [ref, comparison, this._buildValOrRef(value)]
  }

  _isNonNestedObject (object) {
    return object && typeof object === 'object' && !Array.isArray(object) && !(object instanceof RegExp)
  }

  _isAndOr (key) {
    return key === 'or' || key === 'and'
  }

  _validateObjectArgument (object) {
    if (!object || Object.keys(object).length === 0) {
      throw invalidFunctionArgumentError(this[fnChain], object)
    }
  }

  _parseObjectArgument (object) {
    this._validateObjectArgument(object)
    const arrayReturn = []

    for (const key of Object.keys(object)) {
      if (this._isAndOr(key)) {
        Array.isArray(object[key])
          ? this._andOrAsArray(key, object[key], arrayReturn)
          : arrayReturn.push(key, ...this._parseObjectArgument(object[key]))
      } else if (/^(:?not )?exists$/.test(key)) {
        arrayReturn.push(key, object[key])
      } else if (this._isNonNestedObject(object[key])) {
        this._addLogicOperatorIfNeeded(arrayReturn)
        arrayReturn.push(...this._parseNonNestedObject(key, object[key]))
      } else {
        this._addLogicOperatorIfNeeded(arrayReturn)
        const comparison = Array.isArray(object[key]) ? 'in' : '='
        arrayReturn.push(...this._parseNonSingleObjectArguments(key, comparison, object[key]))
      }
    }

    return arrayReturn
  }

  _andOrAsArray (key, array, arrayReturn) {
    this._addLogicOperatorIfNeeded(arrayReturn)
    arrayReturn.push(...this._parseObjectArgument(array[0]))
    for (let i = 1, length = array.length; i < length; i++) {
      if (this._isAndOr(Object.keys(array[i])[0])) {
        arrayReturn.push(key, '(', ...this._parseObjectArgument(array[i]), ')')
      } else {
        arrayReturn.push(key, ...this._parseObjectArgument(array[i]))
      }
    }
  }

  _addLogicOperatorIfNeeded (array) {
    const length = array.length

    if (length === 0) {
      return
    }

    const lastEntry = array[length - 1]

    if (lastEntry !== 'and' && lastEntry !== 'or') {
      array.push('and')
    }
  }

  _parseNonNestedObject (parentKey, object) {
    const keys = Object.keys(object)

    if (this._isCqn(object)) {
      if (object.SELECT) {
        return this._parseNonSingleObjectArguments(parentKey, 'in', object)
      }

      return this._parseNonSingleObjectArguments(parentKey, object)
    }

    switch (keys.length) {
      case 1:
        return this._parseNonSingleObjectArguments(parentKey, keys[0], object[keys[0]])
      case 2:
        return this._parseNonSingleObjectArguments(parentKey, keys[0], object[keys[0]], object[keys[1]])
      default:
        throw invalidFunctionArgumentError(this[fnChain], object)
    }
  }

  _isAssociation (entityName, associationName) {
    const name = typeof entityName === 'object' ? ensureNoDraftsSuffix(entityName.name) : entityName
    const entity = this[MODEL].definitions[name]
    if (entity) {
      return entity.elements[associationName] && entity.elements[associationName].type === 'cds.Association'
    }
    throw invalidFunctionArgumentError(this[fnChain], entity)
  }
}

module.exports = Where
