const { all } = require('./thenable')
const generateUUID = require('@sap/cds-foss')('uuid/v4')
const getColumns = require('../services/utils/columns')

const { getCompositionTree, propagateKeys } = require('../services/utils/compositionTree')

const _diffEntryFitsToEntry = (entity, diffEntry, entry) => {
  for (const elementName in entity.elements) {
    const element = entity.elements[elementName]
    if (
      !element.is2one &&
      !element.is2many &&
      diffEntry[elementName] &&
      entry[elementName] !== diffEntry[elementName]
    ) {
      return false
    }
  }
  return true
}

const processDeep = (callbackFn, data, entity, skipRoot, isRoot) => {
  if (!Array.isArray(data)) {
    processDeep(callbackFn, [data], entity, skipRoot, isRoot)
    return
  }

  data.forEach(entry => {
    if (!(skipRoot && isRoot)) {
      callbackFn(entry, entity, isRoot, skipRoot)
    }

    Object.keys(entity.elements || {}).forEach(key => {
      const element = entity.elements[key]

      if (element.type === 'cds.Composition' && entry[element.name]) {
        const subData = Array.isArray(entry[element.name]) ? entry[element.name] : [entry[element.name]]
        const subEntity = element._target
        processDeep(callbackFn, subData, subEntity, false, false)
      }
    })
  })
}

const _deepProcessWithDiffComposition = ({ entry, element, compositionTree, diffForData, callbackFn }) => {
  const subData = Array.isArray(entry[element.name]) ? entry[element.name] : [entry[element.name]]
  const subEntity = element._target
  const compositionElement = compositionTree.compositionElements.find(({ name }) => name === element.name)

  // propagate missing keys based on on conditions
  propagateKeys(subEntity, compositionElement, entry, subData)

  const diffForSubData = diffForData && diffForData[element.name]
  if (diffForSubData) {
    processDeepWithDiff({
      callbackFn,
      data: subData,
      entity: subEntity,
      isRoot: false,
      skipRoot: false,
      diff: diffForSubData,
      compositionTree: compositionElement
    })
  }
}

const processDeepWithDiff = ({ callbackFn, data, entity, skipRoot, isRoot, diff, compositionTree }) => {
  if (!Array.isArray(data)) {
    processDeepWithDiff({ callbackFn, data: [data], entity, skipRoot, isRoot, diff, compositionTree })
    return
  }

  data.forEach(entry => {
    const diffForData =
      diff && Array.isArray(diff) ? diff.find(diffEntry => _diffEntryFitsToEntry(entity, diffEntry, entry)) : diff
    if (!(skipRoot && isRoot)) {
      callbackFn(entry, entity, isRoot, skipRoot, diffForData, compositionTree)
    }

    Object.keys(entity.elements || {}).forEach(key => {
      const element = entity.elements[key]

      if (element.type === 'cds.Composition' && entry[element.name]) {
        _deepProcessWithDiffComposition({ entry, element, compositionTree, diffForData, callbackFn })
      }
    })
  })
}

const _deeperElements = (callbackFn, entry, elements = {}) => {
  return Object.keys(elements).map(async key => {
    const element = elements[key]

    if (element.type === 'cds.Composition' && entry[element.name]) {
      const subData = Array.isArray(entry[element.name]) ? entry[element.name] : [entry[element.name]]

      return processDeepAsync(callbackFn, subData, element._target, false, false)
    }
  })
}

const processDeepAsync = async (callbackFn, data, entity, skipRoot, isRoot) => {
  if (!Array.isArray(data)) {
    return processDeepAsync(callbackFn, [data], entity, skipRoot, isRoot)
  }

  const deep = data.map(async entry => {
    if (!(skipRoot && isRoot)) {
      await callbackFn(entry, entity, isRoot)
    }

    return all(_deeperElements(callbackFn, entry, entity.elements))
  })

  return all(deep)
}

const _generateUUIDsAndAddDefaults = (elements, data, diff, compositionTree) => {
  const customBackLinks = compositionTree && compositionTree.customBackLinks
  const entityKeys = (customBackLinks || []).map(customBackLink => customBackLink.entityKey)
  for (const column of Object.keys(elements)) {
    const col = elements[column]
    if (col.key && col.type === 'cds.UUID' && data[column] === undefined && !entityKeys.includes(column)) {
      data[column] = generateUUID()
      if (diff) {
        diff[column] = data[column]
      }
    }
  }
}

/**
 * delete input for properties annotated with @cds.on.insert/update
 */
const _deleteManaged = (entry, entity) => {
  const columns = getColumns(entity).filter(column => column['@cds.on.insert'] || column['@cds.on.update'])
  for (const column of columns) {
    delete entry[column.name]
  }
}

/**
 * This method adds default values and annotated values to data for elements not having default values, also adds UUID keys if not given.
 * @private
 */
const _fillData = (data, entity, diff, compositionTree, event, user, date) => {
  // PATCH:
  // This will only work for top-level PATCH requests.
  // In case we want to support deep-PATCH requests, we need to
  // include `PATCH` to execute `_addPartialPersistentState`.
  if ((diff && diff._op === 'update') || (!diff && event === 'PATCH')) {
    _deleteManaged(data, entity)
  } else if (!diff || diff._op === 'create') {
    _deleteManaged(data, entity)
    const elements = entity.elements
    _generateUUIDsAndAddDefaults(elements, data, diff, compositionTree)
  }
}

const ensureNoDraftsSuffix = name => (name.endsWith('_drafts') ? name.slice(0, -7) : name)

const fillDataDeep = (definitions, data, entity, diff, event, user, date = new Date()) => {
  const compositionTree = getCompositionTree(definitions, ensureNoDraftsSuffix(entity.name), false, false)
  processDeepWithDiff({
    callbackFn: (data, entity, _isRoot, _skipRoot, diff, compositionTree) => {
      _fillData(data, entity, diff, compositionTree, event, user, date)
    },
    data,
    entity,
    isRoot: true,
    skipRoot: false,
    diff,
    compositionTree
  })
}

module.exports = {
  processDeep,
  processDeepAsync,
  fillDataDeep
}
