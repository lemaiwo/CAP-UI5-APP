const _newData = (data, transition) => {
  const newData = { ...data }
  Object.keys(newData)
    .filter(key => transition.has(key))
    .forEach(key => {
      const value = data[key]
      newData[transition.get(key)] = value
      delete newData[key]
    })
  return newData
}

const _newColumns = (columns, transition, withAlias = false) => {
  const newColumns = []
  ;(columns || []).forEach(column => {
    const transitioned = column.ref && transition.get(column.ref[0])
    if (transitioned) {
      const newColumn = { ...column }
      if (withAlias) {
        newColumn.as = column.ref[0]
      }
      newColumn.ref = [transition.get(column.ref[0])]
      newColumns.push(newColumn)
    } else {
      newColumns.push(column)
    }
  })
  return newColumns
}

const _newEntries = (entries, transition) => {
  const newEntries = []
  ;(entries || []).forEach(entry => {
    newEntries.push(_newData(entry, transition))
  })
  return newEntries
}

const _newWhere = (where, transition) => {
  const newWhere = []
  ;(where || []).forEach(whereElement => {
    const transitioned = whereElement.ref && transition.get(whereElement.ref[0])
    if (transitioned) {
      const newWhereElement = { ...whereElement }
      newWhereElement.ref = [transitioned]
      newWhere.push(newWhereElement)
    } else {
      newWhere.push(whereElement)
    }
  })
  return newWhere
}

const _isProjectionToRemotService = (query, service) => {
  const target = query._target
  if (!target || (!target['@mashup'] && target.name && target.name.startsWith(service.name))) return false
  // we only support one level of projections currently...
  const source = target.query && target.query._target
  if (!source || (source.name && !source.name.startsWith(service.name))) return false
  // we only support restricted projections
  if (target.$syntax !== 'projection') return false
  // console.trace('only as projection on supported') // eslint-disable-line
  else return true
}

const _newUpdate = (query, transition) => {
  const newUpdate = { ...query.UPDATE }
  newUpdate.entity = query._target.query._target.name
  newUpdate.with = _newData({ ...(newUpdate.data || {}), ...(newUpdate.with || {}) }, transition)
  delete newUpdate.data
  if (newUpdate.where) newUpdate.where = _newWhere(newUpdate.where, transition)
  return newUpdate
}

const _newSelect = (query, transition) => {
  const newSelect = { ...query.SELECT }
  newSelect.from = { ...newSelect.from }
  newSelect.from.ref = [query._target.query._target.name]
  if (!newSelect.columns) {
    newSelect.columns = query._target.query.SELECT.columns.map(column => ({
      ref: [column.as || column.ref[0]]
    }))
  }
  newSelect.columns = _newColumns(newSelect.columns, transition, true)
  if (newSelect.having) newSelect.having = _newColumns(newSelect.having, transition)
  if (newSelect.groupBy) newSelect.groupBy = _newColumns(newSelect.groupBy, transition)
  if (newSelect.orderBy) newSelect.orderBy = _newColumns(newSelect.orderBy, transition)
  if (newSelect.where) newSelect.where = _newWhere(newSelect.where, transition)
  return newSelect
}

const _newInsert = (query, transition) => {
  const newInsert = { ...query.INSERT }
  newInsert.into = query._target.query._target.name
  newInsert.entries = _newEntries(newInsert.entries, transition)
  return newInsert
}

const _newDelete = (query, transition) => {
  const newDelete = { ...query.DELETE }
  newDelete.from = query._target.query._target.name
  if (newDelete.where) newDelete.where = _newWhere(newDelete.where, transition)
  return newDelete
}

module.exports = (query, service) => {
  // If the query is a projection, one must follow it
  // to let the underlying service know its true entity.

  if (_isProjectionToRemotService(query, service)) {
    const transitionColumns = query._target.query.SELECT.columns || []
    const transition = new Map()
    for (const transitionColumn of transitionColumns) {
      if (transitionColumn.as) {
        transition.set(transitionColumn.as, transitionColumn.ref[0])
      }
    }
    const newQuery = {}
    Object.setPrototypeOf(newQuery, query)
    for (const prop in newQuery) {
      if (prop === 'UPDATE') {
        newQuery.UPDATE = _newUpdate(newQuery, transition)
      } else if (prop === 'SELECT') {
        newQuery.SELECT = _newSelect(newQuery, transition)
      } else if (prop === 'INSERT') {
        newQuery.INSERT = _newInsert(newQuery, transition)
      } else if (prop === 'DELETE') {
        newQuery.DELETE = _newDelete(newQuery, transition)
      }
    }
    newQuery.target = newQuery._target.query.target
    return newQuery
  }
  return query
}
