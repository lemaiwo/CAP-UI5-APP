const { typeConversionMap } = require('../utils/dataTypes')
const { ensureNoDraftsSuffix } = require('../utils/draftUtils')

/**
 * BaseClient is to be extended by any SQL client. It allows to convert db results according to the CSN.
 */
class BaseClient {
  /**
   * Creates a basic SQL Client
   * @param {Array|Map} toService - Definition of how to convert a value according to cds.DataType
   */
  constructor (toService = []) {
    this._toService = toService instanceof Map ? toService : new Map(toService)
    this._initializeDefaultDataTypeMap()
    this._perfMeasurementNumber = 0
  }

  _dynatraceRun (fn, ...args) {
    if (this._context && this._context.dynatrace && this._getDynatraceDbInfo) {
      const { api } = this._context.dynatrace
      const tracer = api.traceSQLDatabaseRequest(this._getDynatraceDbInfo(), {
        statement: args.length > 1 ? args[0] : args[0].name
      })

      const argsForTracer = [...args]
      argsForTracer[argsForTracer.length - 1] = this._dynatraceCb(tracer, args[args.length - 1])
      return tracer.startWithContext(fn, this._dbc, ...argsForTracer)
    } else {
      return fn.call(this._dbc, ...args)
    }
  }

  _dynatraceCb (tracer, clientCb) {
    return (err, results, fields) => {
      if (err) {
        tracer.error(err)
      } else {
        tracer.setResultData({
          rowsReturned: (results && results.length) || results
        })
      }
      tracer.end(clientCb, err, results, fields)
    }
  }

  _traced (fn, ...args) {
    const number = this._measureStartTime()
    if (number) {
      const that = this
      const enhancedWithEndMeasurement = [...args]
      enhancedWithEndMeasurement[enhancedWithEndMeasurement.length - 1] = function (error, result) {
        if (!error) {
          that._measureEndTime(number)
        }
        args[args.length - 1].call(this, error, result)
      }
      return this._dynatraceRun(fn, ...enhancedWithEndMeasurement)
    } else {
      return this._dynatraceRun(fn, ...args)
    }
  }

  /**
   * Set the entities in reflected CSN format, relevant for the service the queries are run for.
   * @param csn
   */
  setCSN (csn) {
    this._csn = csn
  }

  /**
   * Set the timestamp that should be used for transactions
   * @param timestamp date as a string value in ISO format
   */
  setTransactionTimestamp (timestamp) {
    this._transactionTimestamp = timestamp
  }

  /**
   * Set the context relevant for the service the queries are run for.
   * @param csn
   */
  setContext (context) {
    this._context = context
  }

  /**
   * Default sql type conversion. Database specific data types need to be overwritten in db client impl.
   * @private
   */
  _initializeDefaultDataTypeMap () {
    this._typeConversionMap = typeConversionMap
  }

  /**
   * Returns validity of the client.
   *
   * @returns {boolean} true if client is still valid, false if not
   */
  isValid () {
    return !this._toBeDestroyed && this.isConnected()
  }

  _getStartMark (id) {
    return `${id} Start`
  }

  _getEndMark (id) {
    return `${id} End`
  }

  _getIdForPerfMeasure (number) {
    return `${this._context.performanceMeasurement.uuid} 2 ${this._context.event} ${this._context.target &&
      this._context.target.name} SQL ${number}`
  }

  _measureStartTime () {
    const performanceMeasurement = this._context && this._context.performanceMeasurement
    if (performanceMeasurement) {
      this._context.performanceMeasurement.sqlId++
      const number = this._context.performanceMeasurement.sqlId
      const id = this._getIdForPerfMeasure(number)
      performanceMeasurement.performance.mark(this._getStartMark(id))
      return number
    }
  }

  _measureEndTime (number) {
    const performanceMeasurement = this._context && this._context.performanceMeasurement
    if (performanceMeasurement) {
      const id = this._getIdForPerfMeasure(number)
      const startMark = this._getStartMark(id)
      const endMark = this._getEndMark(id)
      performanceMeasurement.performance.mark(endMark)
      performanceMeasurement.performance.measure(id, startMark, endMark)
    }
  }

  _createCountQuery (query) {
    const _query = JSON.parse(JSON.stringify(query))
    _query.SELECT.columns = [{ func: 'count', args: [{ ref: ['1'] }], as: 'counted' }]
    delete _query.SELECT.limit
    delete _query.SELECT.orderBy // not necessary to keep that
    // Also change columns in sub queries
    if (_query.SELECT.from.SET) {
      _query.SELECT.from.SET.args.forEach(subCountQuery => {
        subCountQuery.SELECT.columns = [{ ref: ['1'] }]
      })
    }
    return _query
  }

  async _executeWithCount (query, values) {
    if (query.SELECT.limit) {
      const countQuery = this._createCountQuery(query)
      const [result, countResult] = await Promise.all([this.execute(query, values), this.execute(countQuery, values)])
      return _arrayWithCount(result, countResult[0].counted)
    } else {
      const result = await this.execute(query, values)
      return _arrayWithCount(result, result.length)
    }
  }

  /**
   * Runs simple SQL statements.
   * In contrast to .execute, it also takes care of executing the statement in a transactional block.
   *
   * @param {String|Object} query - SQL query as string or CQN object.
   * @param {Array} [values] - values for prepared stmt in case of SQL query string.
   * @returns {Promise} - resolves with result or rejects with error if client is in inconsistent state.
   */
  run (query, values) {
    // Support for bulk-running arrays of queries
    if (Array.isArray(query)) {
      return Promise.all(query.map(q => this.run(q)))
    }

    // Client broke in a not reparable way before
    if (this._toBeDestroyed) {
      return Promise.reject(new Error('Client is in an inconsistent state'))
    }

    // In case of run block the transaction mode is provided by the block pragmas.
    if (typeof query === 'function' && this._runBlock) {
      return this._runBlock(query)
    }

    // Execute in case of statements
    if (query.SELECT && query.SELECT.count) {
      return this._executeWithCount(query, values)
    }
    return this.execute(query, values)
  }

  /**
   * Processes a nested (two-level deep) array of CQN statements.
   * First array level is processed sequentially, second array level is processed in parallel
   * @param {Array.<Array>} cqns - Nested array of CQNs processed in the above described order
   * @param {Function} processFn - Process callback function for each CQN statement
   */
  processNestedCQNs (cqns, processFn) {
    return cqns.reduce((promise, cqns) => {
      return promise.then(changes => {
        return Promise.all(
          cqns.map(cqn => {
            return Promise.resolve(processFn(cqn)).then(result => {
              changes += isNaN(parseInt(result, 10)) ? 0 : result
            })
          })
        ).then(() => {
          return changes
        })
      })
    }, Promise.resolve(0))
  }

  /**
   * Sets a session context on the database
   *
   * Does nothing on sqlite yet.
   *
   * @param contextName name of the session context
   * @param value value of the session context
   */
  setSessionContext (contextName, value) {}

  /**
   * Executes the statement and processes the result set one by one.
   * Should be used if huge result sets are expected to process it in a streaming-like fashion instead of
   * materializing the full set in memory before.
   *
   * @param {String|Object} query - SQL query as string or CQN object or entity name as specified in csn
   * (entity name is treated as: SELECT * FROM <entity name>).
   * @param {Array} [values] - values for prepared stmt in case of SQL query string.
   * @param {Function} callback - synchronous function to process each row of the result set.
   * @returns {Promise} - resolves to undefined if successful, rejects with error if not
   */
  foreach (query, values, callback) {
    const cb = callback || values

    return this.run(this._queryForForeach(query), this._valuesForForeach(values)).then(res => {
      if (Array.isArray(res)) {
        res.forEach(row => {
          cb(row)
        })
      }
    })
  }

  /**
   * Drops all tables/views and creates them again
   * @param {Object|Promise} csn - the unreflected CSN or promise that will resolve into csn.
   * @param {String} [dialect] - dialect, defaults to 'sqlite'
   * @returns {Promise} Promise, that resolves with undefined if successful or rejects with error if not.
   */
  deploy (csn, dialect = 'sqlite') {
    if (csn.then) {
      return csn.then(csn => {
        return this._deploy(csn, dialect)
      })
    }

    return this._deploy(csn, dialect)
  }

  _deploy (csn, dialect) {
    const creates = global.cds.compile.to.sql(csn, {
      sqlMapping: global.cds.config.data.sql_mapping,
      sqlDialect: dialect
    })
    const sqls = this._prepareSqls(creates)

    let execChain = Promise.resolve()

    for (const drop of sqls.drops) {
      execChain = this._addDropsToChain(execChain, drop)
    }

    for (const create of sqls.creates) {
      execChain = this._addCreateToChain(execChain, create)
    }

    return execChain
  }

  _prepareSqls (creates) {
    const res = {}
    res.creates = []
    res.drops = []
    for (const create of creates) {
      const [, type, name] = create.match(/^\s*\w+\s+(table|view)\s+"?([^\s(]+?)"?[\s(]/im) || []

      if (type.toLowerCase() === 'view') {
        res.drops.unshift({ DROP: { view: name } })
        res.creates.push(create)
      } else if (type.toLowerCase() === 'table') {
        res.drops.push({ DROP: { entity: name } })
        res.creates.unshift(create)
      }
    }

    return res
  }

  /**
   * Hana does not support drop if exists so we need to handle this differently in hana.
   * The hana client needs to overwrite this to handle error in case the table does not exist.
   * @private
   */
  _addDropsToChain (chain, drop) {
    return chain.then(() => {
      return this.run(drop)
    })
  }

  _addCreateToChain (chain, drop) {
    return chain.then(() => {
      return this.run(drop)
    })
  }

  _valuesForForeach (values) {
    if (typeof values === 'function') {
      return
    }

    return values
  }

  _queryForForeach (query) {
    if (this._csn && this._csn.definitions[query]) {
      const entityName =
        (this._csn.definitions[query].query &&
          this._csn.definitions[query].query._target &&
          ensureNoDraftsSuffix(this._csn.definitions[query].query._target.name)) ||
        ensureNoDraftsSuffix(this._csn.definitions[query].name)

      return {
        SELECT: {
          from: { ref: [entityName] }
        }
      }
    }

    return query
  }

  _copyCqnInsert (cqn) {
    const cqnCopy = {
      INSERT: {
        into: cqn.INSERT.into
      }
    }

    if (cqn.INSERT.columns) {
      cqnCopy.INSERT.columns = [...cqn.INSERT.columns]
    }

    if (cqn.INSERT.values) {
      cqnCopy.INSERT.rows = [[...cqn.INSERT.values]]
    }

    if (cqn.INSERT.rows) {
      cqnCopy.INSERT.rows = []
      for (const row of cqn.INSERT.rows) {
        cqnCopy.INSERT.rows.push([...row])
      }
    }

    if (cqn.INSERT.entries) {
      cqnCopy.INSERT.entries = []
      for (const entry of cqn.INSERT.entries) {
        cqnCopy.INSERT.entries.push({ ...entry })
      }
    }

    return cqnCopy
  }

  _addDefaultValues (cqn, isNullable, isNotNullable) {
    if (!this._csn) {
      return cqn
    }

    if (cqn.INSERT) {
      return this._addDefaultValuesInsert(cqn, isNullable, isNotNullable)
    }

    return cqn
  }

  _addDefaultValuesInsert (cqn, isNullable, isNotNullable) {
    const entity = this._csn.definitions[ensureNoDraftsSuffix(cqn.INSERT.into.name || cqn.INSERT.into)]
    if (!entity) {
      return cqn
    }
    if (cqn.INSERT.entries) {
      return this._addDefaultValuesEntries(cqn, entity, isNullable, isNotNullable)
    }
    if (cqn.INSERT.columns && (cqn.INSERT.values || cqn.INSERT.rows)) {
      return this._addDefaultValuesRows(cqn, entity, isNullable, isNotNullable)
    }

    return cqn
  }

  _hasDefaultValuesEntries (cqn, entity, isNullable, isNotNullable) {
    for (const entry of cqn.INSERT.entries) {
      for (const elementKey in entity.elements) {
        const element = entity.elements[elementKey]
        if (element.default === undefined) {
          continue
        }
        if (element.notNull && isNotNullable && entry[element.name] === undefined) {
          return true
        }
        if (!element.notNull && isNullable && entry[element.name] === undefined) {
          return true
        }
      }
    }

    return false
  }

  _addDefaultValuesEntries (cqn, entity, isNullable, isNotNullable) {
    const hasDefaultEntries = this._hasDefaultValuesEntries(cqn, entity, isNullable, isNotNullable)

    if (hasDefaultEntries) {
      const cqnCopy = this._copyCqnInsert(cqn)

      for (const entry of cqnCopy.INSERT.entries) {
        this._addDefaultValuesEntry(entity, entry, isNotNullable, isNullable)
      }

      return cqnCopy
    }

    return cqn
  }

  _addDefaultValuesEntry (entity, entry, isNotNullable, isNullable) {
    for (const elementKey in entity.elements) {
      const element = entity.elements[elementKey]
      if (element.default === undefined) {
        continue
      }
      if (element.notNull && isNotNullable && entry[element.name] === undefined) {
        entry[element.name] = element.default.val || element.default // OLD CSN
      }
      if (!element.notNull && isNullable && entry[element.name] === undefined) {
        entry[element.name] = element.default.val || element.default // OLD CSN
      }
    }
  }

  _hasDefaultValuesRows (cqn, entity, isNullable, isNotNullable) {
    for (const elementKey in entity.elements) {
      const element = entity.elements[elementKey]
      if (cqn.INSERT.columns.includes(element.name) || element.default === undefined) {
        continue
      }

      if ((element.notNull && isNotNullable) || (!element.notNull && isNullable)) {
        return true
      }
    }

    return false
  }

  _addDefaultValuesRow (entity, elementKey, cqnCopy, isNotNullable, isNullable) {
    const element = entity.elements[elementKey]
    if (cqnCopy.INSERT.columns.includes(element.name) || element.default === undefined) {
      return
    }

    if ((element.notNull && isNotNullable) || (!element.notNull && isNullable)) {
      cqnCopy.INSERT.columns.push(element.name)
      for (const row of cqnCopy.INSERT.rows) {
        row.push(element.default.val || element.default) // OLD CSN
      }
    }
  }

  _addDefaultValuesRows (cqn, entity, isNullable, isNotNullable) {
    const hasDefaultValues = this._hasDefaultValuesRows(cqn, entity, isNullable, isNotNullable)

    if (hasDefaultValues) {
      const cqnCopy = this._copyCqnInsert(cqn)

      for (const elementKey in entity.elements) {
        this._addDefaultValuesRow(entity, elementKey, cqnCopy, isNotNullable, isNullable)
      }

      return cqnCopy
    }

    return cqn
  }
}

function _arrayWithCount (a, count) {
  const _map = a.map

  const map = (..._) => _arrayWithCount(_map.call(a, ..._), count)
  return Object.defineProperties(a, {
    $count: { value: count, enumerable: false, configurable: true, writable: true },
    map: { value: map, enumerable: false, configurable: true, writable: true }
  })
}

module.exports = BaseClient
