const DEBUG = /\b(y|all|compile|skip)\b/.test (process.env.DEBUG) && console.warn // eslint-disable-line
const cds = require ('../cds')

/** Skip unused entities marked with @cds.persistence.skip:'if-unused' */
function _skip_unused (csn) { // NOSONAR

  const m = cds.linked (csn)
  const services = m.all('service').map (({name}) => name+'\\.').join('|')
  const services_ = RegExp (`^(${services || '^--- none ---'})`)
  const localized_ = /^localized\./
  const entities = m.all ('any')
  const _deferred={}, _pass2={}, _keep={}, _skipped=[]

  // for each entity e1 marked with @cds.persistence.skip:'if-unused'...
  m.foreach (e => !e.abstract && e['@cds.persistence.skip']=='if-unused', e1 => { // NOSONAR

    if (services_.test(e1.name))  return keep(e1,'exposed',{name:RegExp.$1}) // do not remove entities exposed from services
    if (localized_.test(e1.name))  return

    // fetch other entities e2 that contain references to e1 ...
    for (let e2 of entities) {

      if (localized_.test(e2.name))  continue  // ignore ref from derived entities
      if (e2 === e1)  continue

      // does e2 derive from e1?
      if (e2.includes && e2.includes.includes(e1.name) && keep (e1, `includes`, e2))  return

      // is e2 a view on e1?
      if (e2.query && e2.query._target === e1 && keep (e1, `projection`, e2))  return

      // does e2 refer to e1?
      // if (e1.type === e2.name && keep (e1, `type`, e2))  return
      // if (e1._target === e2 && keep (e1, `target`, e2))  return

      // does e2 contain Associations to e1?
      for (let e in e2.elements) {
        if (e2.elements[e]._target === e1 && keep (e1, `association '${e}'`, e2))  return
      }

    }

    // skip e1 if no references have been found
    (e1.name in _deferred) || skip (e1.name)

  })

  // Pass 2 ...
  for (let each in _pass2) {
    for (let e of _pass2[each])  if (!_keep[e[0].name])  skip (e[0].name)
  }

  function keep (e1, reason, e2, force) {
    // if (e1.name === 'sap.common.Countries')  console.log ('> keep', e1.name ,'due to:', e2.name)
    if (!force && !_keep[e2.name] && !services_.test(e2.name) && e2['@cds.persistence.skip']=='if-unused') {
      (_pass2[e2.name] || (_pass2[e2.name] = [])) .push ([e1,reason,e2])
      _deferred[e1.name] = true
      return false
    }
    _keep [e1.name] = true
    if (e1.name in _pass2) {
      const p2 = _pass2 [e1.name]
      delete _pass2 [e1.name]
      for (let e of p2)  keep (...e, true)
    }
    DEBUG && reason !== 'exposed' && DEBUG (`NOT skipping ${e1.name} due to ${reason} in ${e2.name}`)
    return true
  }

  function skip (entry) {
    if (csn.definitions [entry]) {
      DEBUG && DEBUG (`Skipping ${entry}`)
      delete csn.definitions [entry]
      if (csn._xsn)  delete csn._xsn.definitions [entry]
      if (!localized_.test(entry))  skip ('localized.'+entry)
      if (!/_texts$/.test(entry))  skip (entry+'_texts')
    }
    _skipped.push (entry)
  }

  // Pass 3 -- remove all custom types referring to _skipped entries ...
  m.foreach (d => {
    if (!_keep[d.name] && (_skipped.includes(d.type) || _skipped.includes(d.target)))  skip (d.name)
  })

  return csn
}

// feature-toggled exports
module.exports = cds.env.features.skip_unused ? _skip_unused : (csn) => csn
