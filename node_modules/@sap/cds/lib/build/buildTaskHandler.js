const fs = require('@sap/cds-foss')('fs-extra')
const path = require('path')

const { BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_DEFAULT, OUTPUT_MODE_RESULT_ONLY } = require('./constants')

class BuildTaskHandler {
    constructor(name, task, buildOptions) {
        if (!task.src || !task.for) {
            throw new Error(`Invalid parameter build task - ${JSON.stringify(task)}`)
        }

        task.options = task.options || {}
        task.dest = task.dest || task.src

        this._name = name
        this._task = task
        this._buildOptions = buildOptions || {}
        this._written = []
        this._messages = []
        this._buildOptions.for = this._buildOptions.for || {}
        this._buildOptions.for[task.for] = this._buildOptions.for[task.for] || {}
        this._buildOptions.outputMode = this._buildOptions.outputMode || OUTPUT_MODE_DEFAULT
    }

    get name() {
        return this._name;
    }
    get logger() {
        return this._logger;
    }
    set logger(logger) {
        this._logger = logger;
    }
    set cds(cds) {
        this._cds = cds;
    }
    get cds() {
        return this._cds
    }
    get env() {
        return this._cds.env
    }
    get task() {
        return this._task
    }
    get buildOptions() {
        return this._buildOptions
    }
    get messages() {
        return this._messages
    }
    get files() {
        return this._written
    }
    /**
     * Returns the task type specific build option with the given name
     * @param {string} name
     */
    getBuildOption(name) {
        const taskBuildOptions = this.buildOptions.for[this.task.for]
        return taskBuildOptions && taskBuildOptions[name] ? taskBuildOptions[name] : this.buildOptions[name]
    }
    /**
     * Returns whether a task type specific build option with the given property name has the specified value.
     * If the value is omitted the existence of the given property name is checked.
     * @param {string} name
     * @param {any=} value
     */
    hasBuildOption(name, value) {
        return BuildTaskHandler._hasOptionValue(this.getBuildOption(name), value)
    }

    /**
     * Returns whether cds env has a property with the specified value.
     * If the value is omitted the existence of the given property name is checked.
     * @param {string} qualifiedName
     * @param {any=} value
     */
    hasCdsEnvOption(qualifiedName, value) {
        return BuildTaskHandler._hasOptionValue(this.env.get(qualifiedName), value)
    }

    /**
     * Called by the framework immediately after this instance has been created.
     * The instance has already been fully initialized.
     */
    init() { }

    /**
     * Called by the framework after {@link #init()}. Handlers may want to perform more elaborate preparation.
     * E.g. caching some pre-calculated data that can be used across multiple build tasks. This kind of data
     * has to be stored in the handler type specific buildOptions section.
     * @returns {Promise<boolean>} A value 'false' indicates that {@link #prepare()} will not be called for other instances
     * of this handler type.
     * True indicates that {@link #prepare()} will be called for other instances of this of this handler type.
     */
    async prepare() {
        // cancel subsequent prepare calls for other handlers of the same type by default
        return false
    }

    async build() { }

    async clean() {
        // the build results have already been deleted by the BuildTaskEngine if the build.target !== '.'
        // make sure that src is not a subfolder of dest
        if (this.buildOptions.root === this.buildOptions.target && this.task.src !== this.task.dest && !this._isSubDirectory(this.task.dest, this.task.src)) {
            await fs.remove(this.task.dest)
        }
    }

    write(data) {
        return {
            to: async (dest) => {
                if (!this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
                    this.pushFile(dest)
                    if (this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_DEFAULT)) {
                        await fs.outputFile(dest, typeof data === "object" ? JSON.stringify(data, null, 2) : data)
                    }
                }
            }
        }
    }

    copy(source) {
        return {
            to: async (dest) => {
                if (!this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
                    this.pushFile(dest)
                    if (this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_DEFAULT)) {
                        // symlinks are not dereferenced
                        await fs.copy(source, dest)
                    }
                    return dest
                }
            }
        }
    }

    /**
     * Returns whether the build results of this build plugin are created inplace
     * or in a separate staging folder which is not part of the build tasks src folder.
     */
    isStagingBuild() {
        return this.task.src !== this.task.dest
    }

    resolveModel() {
        let model

        if (Array.isArray(this.task.options.model)) {
            if (this.task.options.model.length > 0) {
                model = this.task.options.model
            } else {
                model = this.task.src
            }
        } else {
            model = this.task.options.model || this.task.src
        }
        return this.cds.resolve(model, this.buildOptions)
    }

    async copyNativeContent(srcDir, destDir, customFilter) {
        if (!this.isStagingBuild()) {
            return Promise.resolve()
        }
        const files = BuildTaskHandler._find(srcDir, (src) => {
            // do not copy files that:
            // - are contained in the 'buildOptions.target' folder
            // - are contained in this modules 'dest' folder
            // - are contained in some generation folder
            // - do NOT fullfill additional specific filter criteria
            // NOTE: there is no specific handling for content that is part of the 'node_modules' folder as it might be required later on, e.g. reuse model content
            return this._commonStagingBuildFilter(src, destDir) && (!customFilter || customFilter.call(this, src))
        })
        return Promise.all(
            files.map((srcFile) => {
                let relFile = path.relative(srcDir, srcFile)
                let destFile = path.join(destDir, relFile)
                return this.copy(srcFile).to(destFile)
            })
        )
    }

    // Returning the project relative path representation of the given path(s),
    stripProjectPaths(qualifiedPaths) {
        qualifiedPaths = typeof qualifiedPaths === "string" ? [qualifiedPaths] : qualifiedPaths
        if (Array.isArray(qualifiedPaths)) {
            return qualifiedPaths.map(qualifiedPath => {
                const relPath = path.relative(this.buildOptions.root, qualifiedPath)
                return relPath || "."
            })
        }
        return qualifiedPaths
    }

    /**
     * Appends the given fully qualified file path to the list of files that have been written by this build task.
     * @param {string} filePath
     */
    pushFile(filePath) {
        this._written.push(filePath)
    }

    /**
     * Appends the given messages to the list of messages that will be logged after all build tasks have finished.
     * @param {*} messages
     */
    pushMessages(messages) {
        this._messages = this._messages.concat(messages)
    }

    options() {
        return this.env.features.snapi ? { messages: [] } : { _messages: [] }
    }

    _isSubDirectory(parent, child) {
        return !path.relative(parent, child).startsWith('..')
    }

    _commonStagingBuildFilter(src, destDir) {
        if (typeof src !== "string" || typeof destDir !== "string") {
            return false
        }
        if (!fs.statSync(src).isDirectory()) {
            return true //file
        }
        if (src === destDir) {
            return false
        }
        const regex = /gen/
        if (src === this.buildOptions.target) {
            return false
        }
        const match = path.basename(src).match(regex)
        return !match || (Array.isArray(match) && match.length === 0)
    }

    static _find(srcDir, filter) {
        const files = []
        BuildTaskHandler._traverseFileSystem(srcDir, files, filter)
        return files;
    }

    static _traverseFileSystem(srcDir, files, filter) {
        let entries = []
        try {
            entries = fs.readdirSync(srcDir)
        } catch (e) {
            // ignore if not existing
        }
        entries.map(subDirEntry => path.join(srcDir, subDirEntry)).forEach((entry) => {
            BuildTaskHandler._handleResource(entry, files, filter)
        })
    }

    static _handleResource(entry, files, filter) {
        if (!filter || filter.call(this, entry)) {
            var stats = BuildTaskHandler._getResourceStatus(entry)
            if (stats.isDirectory()) {
                BuildTaskHandler._traverseFileSystem(entry, files, filter)
            } else if (stats.isFile() || stats.isSymbolicLink()) {
                files.push(entry)
            }
        }
    }

    // for testing purposes
    static _getResourceStatus(entry) {
        return fs.lstatSync(entry)
    }

    static _hasOptionValue(actual, expected) {
        if (typeof expected === 'undefined') {
            return actual !== undefined
        }
        if (typeof actual === 'undefined') {
            return false
        }
        try {
            return JSON.parse(actual) === JSON.parse(expected)
        } catch (e) {
            // skip
        }
        return actual === expected
    }
}

module.exports = BuildTaskHandler
