const fs = require('@sap/cds-foss')('fs-extra')
const path = require('path')
const BuildTaskHandlerOData = require('../buildTaskHandlerOData')
const term = require('../../../bin/utils/term')
const { getApplicationName, getHdiService, getDefaultHdiServiceName } = require('../../utils/mtaUtil')
const { OUTPUT_MODE_RESULT_ONLY, BUILD_OPTION_OUTPUT_MODE, FOLDER_GEN, FILE_EXT_CDS } = require('../constants')

const DEBUG = process.env.DEBUG
const DEFAULT_COMPILE_DEST_FOLDER = path.normalize("src/gen")

const FILE_EXT_CSV = ".csv"
const FILE_EXT_HDBTABLEDATA = ".hdbtabledata"

const FILE_NAME_HDICONFIG = ".hdiconfig"
const FILE_NAME_HDINAMESPACE = ".hdinamespace"
const FILE_NAME_PACKAGE_JSON = "package.json"
const FILE_NAME_MANIFEST_YAML = "manifest.yaml"
const REQUIRED_PLUGINS = [FILE_EXT_CSV, FILE_EXT_HDBTABLEDATA]
class HanaModuleBuilder extends BuildTaskHandlerOData {
    constructor(task, buildOptions) {
        super("Hana DB Module Builder", task, buildOptions)
        this._result = {
            dest: this.task.dest,
            hana: []
        }
    }

    init() {
        this.task.options.compileDest = path.resolve(this.task.dest, this.task.options.compileDest || DEFAULT_COMPILE_DEST_FOLDER)
    }

    async build() {
        const { src, dest } = this.task

        const modelPaths = this.resolveModel()

        this.logger.log(`\n[cds] - building module [${this.stripProjectPaths(src)}] using [${this.name}]`)

        if (!modelPaths || modelPaths.length === 0) {
            this.logger.log("[cds] - no model found, skip build")
            return this._result
        }
        if (DEBUG) {
            this.logger.log(`[cds] - model: ${this.stripProjectPaths(modelPaths).join(", ")}`)
        }
        // compile to csn
        const options = this.options()
        const model = await this.cds.load(modelPaths, options)
        this.pushMessages(options.messages || options._messages)

        const plugins = await this._compileToHana(model)

        if (!this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
            // TODO: option 'mtxOriginalSrc' is only a workaround as native hana content part of reuse modules is still an open issue!
            // The option is set by mtx build_helper - the path refers to the base model: 'node_modules/_base/<dbDir>'
            // All files except *.cds files will be copied from base model folder to '#this.task.dest/src/**'.
            // Note:
            // Native hana artefacts are currently not supported by extensions - thus content copied from the base model cannot overwrite
            // content defined by the extension.
            if (this.task.options.build && this.task.options.build.mtxOriginalSrc) {
                const baseModelDbSrcPath = path.join(this.buildOptions.root, this.task.options.build.mtxOriginalSrc)
                if (await fs.pathExists(baseModelDbSrcPath)) {
                    await this._copyNativeContent(baseModelDbSrcPath, dest)
                }
            }

            await this._copyNativeContent(src, dest)
            await this._writeHdiConfig(plugins)
            await this._writeHdiNamespace()

            if (!this.hasBuildOption("skipHdbtabledataGeneration", true)) {
                await this._compileToHdbtabledata(model, dest)
            }
            if (!this.hasBuildOption("skipPackageJsonGeneration", true)) {
                await this._writePackageJson()
            }
            if (!this.hasBuildOption("skipManifestGeneration", true)) {
                await this._writeManifestYaml()
                await this._writeCfIgnore()
            }
        }
        return this._result
    }

    /**
     * Deletes any content that has been created in folder '#this.task.dest/src/gen' by some inplace mode.
     * <br>
     * Note: Content created in staging build will be deleted by the #BuildTaskEngine itself.
     */
    async clean() {
        if (this.isStagingBuild()) {
            return super.clean()
        }
        return fs.remove(this.task.options.compileDest)
    }

    /**
     * Copies the entire content of the db module located in the given <src> folder to the folder <dest>.
     * '*.csv' and '*.hdbtabledata' files NOT located in a subfolder 'src' will be copied to '<dest>/src/gen**'
     *
     * @param {string} src
     * @param {string} dest
     */
    async _copyNativeContent(src, dest) {
        const dbSrcDir = path.join(src, "src")
        await super.copyNativeContent(src, dest, (entry) => {
            if (fs.statSync(entry).isDirectory()) {
                return true // using common filter for folders
            }
            const extname = path.extname(entry)
            return (extname !== FILE_EXT_CSV && extname !== FILE_EXT_HDBTABLEDATA && extname !== FILE_EXT_CDS && entry !== this.env.build.outputfile) ||
                ((extname === FILE_EXT_CSV || extname === FILE_EXT_HDBTABLEDATA) && entry.startsWith(dbSrcDir))
        }) || []

        // handle *.csv and *.hdbtabledata NOT located in '<dbSrc>/src/**' folder
        const files = BuildTaskHandlerOData._find(src, (entry) => {
            if (fs.statSync(entry).isDirectory()) {
                const folderName = path.basename(entry)
                return folderName !== FOLDER_GEN && entry !== dest
            }
            const extname = path.extname(entry)
            return (extname === FILE_EXT_CSV || extname === FILE_EXT_HDBTABLEDATA) && !entry.startsWith(dbSrcDir)
        })
        return Promise.all(files.map((file) => {
            return this.copy(file).to(path.join(this.task.options.compileDest, path.relative(src, file)))
        }))
    }

    /**
     * Generates *.hdbtabledata files in folder '#this.task.dest/src/gen' from *.csv files located in '#this.task.dest/src/**' folder.
     * The generated *.hdbtabledata files will link to their *.csv counterparts using relative links. The *.csv files have either
     * already been defined in the 'src' folder or they have been copied to '#this.task.dest/src/gen/**' folder if they have been
     * created outside 'src' folder. If custom *.hdbtabledata files are found nothing is generated for this particular folder.
     * <br>
     * Note: *.csv and *.hdbtabledata need to be copied to '#this.task.dest/src/gen**' if required before this method is called.
     * In inplace mode dest folder is refering to src folder.
     *
     * @param {object} model compiled csn
     */
    async _compileToHdbtabledata(model, dest) {
        const tabledataDirs = new Set()
        const destSrcDir = path.join(dest, "src")
        const csvFiles = BuildTaskHandlerOData._find(destSrcDir, (entry) => {
            if (fs.statSync(entry).isDirectory()) {
                return true
            }
            const extname = path.extname(entry)
            if (extname === FILE_EXT_HDBTABLEDATA) {
                tabledataDirs.add(path.dirname(entry))
            }
            return extname === FILE_EXT_CSV
        })
        if (csvFiles.length > 0) {
            const csvDirs = csvFiles.map(path.dirname).reduce((dirs, dir) => {
                if (!tabledataDirs.has(dir) && !dirs.includes(dir)) { // exclude any dir where a tabledata is present
                    dirs.push(dir)
                }
                return dirs
            }, [])

            const promises = []
            let tableDatas = await this.cds.compile.to.hdbtabledata(model, { dirs: csvDirs, baseDir: this.task.options.compileDest })
            for (let [tableData, { file, csvFolder }] of tableDatas) {
                // create .hdbtabledata side-by-side if .csv is contained in 'src/gen/**' subfolder
                // otherwise create in 'src/gen'
                let tableDataPath = csvFolder.startsWith(this.task.options.compileDest) ? csvFolder : this.task.options.compileDest
                tableDataPath = path.join(tableDataPath, file)
                this.logger.log(`[cds] - Creating ${this.stripProjectPaths(tableDataPath)}`)
                promises.push(this.write(tableData).to(tableDataPath))
            }
            await Promise.all(promises)
        }
    }

    /**
     * Creates the hana artefacts from the given csn model and writes the files to the folder '<dest>/src/gen'.
     *
     * @param {object} model The compiled csn model
     */
    async _compileToHana(model) {
        const promises = []
        const plugins = new Set(REQUIRED_PLUGINS)
        const options = this._options4odata()
        const relDest = path.relative(this.task.dest, this.task.options.compileDest)

        // compile to old format (.hdbcds) or new format (.hdbtable / .hdbview)
        const format = this.env.hana['deploy-format']
        if (!this.cds.compile.to[format]){
            return Promise.reject(new Error(`Invalid deploy-format defined: ${format}`))
        }
        const result = this.cds.compile.to[format](model, options)

        this.pushMessages(options.messages || options._messages)

        for (let [content, key] of result) {
            plugins.add(key.suffix || path.extname(key.file))
            const file = key.file ? key.file : key.name + key.suffix
            this._result.hana.push(path.join(relDest, file))
            if (!this.hasBuildOption(BUILD_OPTION_OUTPUT_MODE, OUTPUT_MODE_RESULT_ONLY)) {
                promises.push(this.write(content).to(path.join(this.task.options.compileDest, file)))
            }
        }
        await Promise.all(promises)


        return plugins
    }

    async _writePackageJson() {
        const packageJson = path.join(this.task.src, "package.json")
        const exists = await fs.pathExists(packageJson)

        if (DEBUG && exists) {
            this.logger.log(`[cds] - skip create [${this.stripProjectPaths(packageJson)}], already existing`)
        }
        if (this.isStagingBuild() && !exists) {
            const content = await this._readTemplateAsJson(FILE_NAME_PACKAGE_JSON)
            await this.write(content).to(path.join(this.task.dest, FILE_NAME_PACKAGE_JSON))
        }
    }

    /**
     * Create .hdiconfig file in <dest>src/gen folder of db module.
     */
    async _writeHdiConfig(plugins) {
        const hdiConfig = path.join(this.task.options.compileDest, FILE_NAME_HDICONFIG)
        const template = await this._readTemplateAsJson(FILE_NAME_HDICONFIG)
        let content = {
            'file_suffixes': {}
        }
        for (const key in template['file_suffixes']) {
            if (plugins.has('.' + key)) {
                content['file_suffixes'][key] = template['file_suffixes'][key]
            }
        }
        if (Object.keys(content['file_suffixes']).length !== plugins.size) {
            this.logger.error(`'HANA plugin not found for file suffix [${Array.from(plugins).join(',')}]`)
        }
        // TODO - Be on the save side for now - go for the content use case later on if this works as expected.
        if (this.env.hana['deploy-format'] === 'hdbtable') {
            await this.write(content).to(hdiConfig)
        } else {
            await this.write(template).to(hdiConfig)
        }
    }

    /**
     * Create .hdinamespace file in <dest>src/gen folder of db module.
     */
    async _writeHdiNamespace() {
        // see issue #64 - add .hdinamespace file to prevent HDI from adding gen/ folder to the namespace.
        const hdiNamespace = path.join(this.task.options.compileDest, FILE_NAME_HDINAMESPACE)
        const content = await this._readTemplateAsJson(FILE_NAME_HDINAMESPACE)
        return await this.write(content).to(hdiNamespace)
    }

    /**
     * Create .cfignore file only for staging build.
     * This is to have a fast-turnaround at development
     */
    async _writeCfIgnore() {
        if (this.isStagingBuild()) {
            const content = `node_modules/\n`
            await this.write(content).to(path.join(this.task.dest, '.cfignore'))
        }
    }

    async _writeManifestYaml() {
        if (!this.isStagingBuild()) {
            return
        }
        if (await fs.pathExists(path.join(this.task.src, FILE_NAME_MANIFEST_YAML)) || await fs.pathExists(path.join(this.task.src, 'manifest.yml'))) {
            if (DEBUG) {
                this.logger.log('[cds] - skip cf manifest generation, already existing')
            }
            return
        }

        try {
            const [hdiService, applicationName] = await Promise.all([
                getHdiService(this.buildOptions.root, this.task.src, this.logger),
                getApplicationName(this.buildOptions.root, this.task.src, "hdb", this.logger)
            ])

            const hdiServiceName = hdiService ? hdiService.name : getDefaultHdiServiceName(this.buildOptions.root, this.task.src);
            const MANIFEST_YAML_CONTENT = `---
applications:
- name: ${applicationName}
  path: .
  no-route: true
  health-check-type: process
  memory: 128M
  services:
  - ${hdiServiceName}`

            this.logger.log("Cloud Foundry service binding required for HDI container.")
            this.logger.log("To create a service use CF command")
            this.logger.log("")
            this.logger.log(term.info(`  cf cs hana hdi-shared ${hdiServiceName}`))
            this.logger.log("")

            await this.write(MANIFEST_YAML_CONTENT).to(path.join(this.task.dest, FILE_NAME_MANIFEST_YAML))
        } catch (e) {
            if (e.name === 'YAMLSyntaxError') {
                this.logger.error("Failed to parse [mta.yaml] - skip manifest.yaml generation")
            }
            this.logger.error(e)
        }
    }

    async _readTemplateAsJson(template) {
        const templatePath = path.join(__dirname, 'template', template)
        return fs.readJSON(templatePath).catch((error) => {
            this.logger.error(`Failed to read template [${templatePath}]`)
            return Promise.reject(error)
        })
    }
}
module.exports = HanaModuleBuilder
