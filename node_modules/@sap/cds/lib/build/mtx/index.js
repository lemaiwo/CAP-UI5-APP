/* eslint-disable no-empty */
const fs = require('@sap/cds-foss')('fs-extra')
const path = require('path')
const BuildTaskHandlerOData = require('../buildTaskHandlerOData')
const BuildTaskFactory = require('../buildTaskFactory')
const { setProperty, BuildMessage, BuildError } = require('../util')
const { BUILD_TASK_HANA, BUILD_TASK_MTX, FOLDER_GEN, SEVERITY_WARNING } = require('../constants')
const DEBUG = process.env.DEBUG

const FOLDER_SDC = "sdc"
const FOLDER_NODE_MODULES = "node_modules"
const FOLDER_TEMPLATES = "tpl"

class MtxModuleBuilder extends BuildTaskHandlerOData {
    constructor(task, buildOptions) {
        super("Multitenant Application Builder", task, buildOptions)
    }

    init() {
        if (this.buildOptions.root === this.buildOptions.target) {
            this.task.dest = path.join(this.task.dest, FOLDER_GEN, FOLDER_SDC)
        } else {
            this.task.dest = path.join(this.task.dest, FOLDER_SDC)
        }
    }

    async build() {
        this.logger.log(`\n[cds] - building multitenant application`)

        // custom build tasks for srv and db modules might be defined
        let tasks = await this._getTasks()
        if (tasks.length === 0) {
            this.logger.log("[cds] - no modules containing cds model files found, skipping build")
            return
        }
        const hanaTask = tasks.find(task => task.for === BUILD_TASK_HANA)
        if (!hanaTask) {
            this.logger.warn('[cds] - no db module found, skip copying corresponding artefacts')
        }

        const models = tasks.reduce((acc, task) => {
            if (task.options) {
                if (Array.isArray(task.options.model)) {
                    task.options.model.forEach(model => acc.add(model))
                } else if (task.options.model) {
                    acc.add(task.options.model)
                }
            }
            return acc
        }, new Set())

        const modelPaths = this.cds.resolve(Array.from(models), this.buildOptions)
        if (!modelPaths || modelPaths.length === 0) {
            this.logger.log("[cds] - no model found, skipping build")
            return
        }
        if (DEBUG) {
            this.logger.log(`[cds] - model: ${this.stripProjectPaths(modelPaths).join(", ")}`)
        }

        const csn = await this._compileCsn(modelPaths)

        // validate extension whitlists defined for this SaaS application
        this._validateExtensionWhitelists(csn, hanaTask)

        // copy base model sources
        await Promise.all(csn._sources.map(src => {
            if (src.includes(FOLDER_NODE_MODULES)) {
                return this.copy(src).to(path.join(this.task.dest, src.substr(src.indexOf(FOLDER_NODE_MODULES))))
            } else {
                return this.copy(src).to(path.join(this.task.dest, path.relative(this.buildOptions.root, src)))
            }
        }))

        // copy language bundles
        const bundles = this.collectBundles(csn._sources)
        const writeBundles = []
        const { folders = ['i18n'], file = 'i18n' } = this.env.i18n
        if (Object.keys(bundles).length > 0) {
            writeBundles.push(this.write(bundles).to(path.join(this.task.dest, folders[0], file + '.json')))
        }
        await Promise.all(writeBundles)

        // copy native hana content and templates
        await this._copyNativeContent(this.task.src, this.task.dest, hanaTask)
    }

    async clean() {
        // staging build content is deleted by BuildTaskEngine
        if (this.buildOptions.root === this.buildOptions.target) {
            // delete entire folder 'gen'
            const genDest = path.dirname(this.task.dest)
            if (path.basename(genDest) === FOLDER_GEN) {
                if (DEBUG) {
                    this.logger.log(`Deleting build target folder ${genDest}`)
                }
                await fs.remove(genDest)
            }
        }
    }

    async _copyNativeContent(src, dest, hanaTask) {
        // copying tmplates
        const tplSrc = path.join(src, FOLDER_TEMPLATES)
        if (fs.existsSync(tplSrc)) {
            const tplDest = path.join(path.dirname(dest), FOLDER_TEMPLATES)
            await this._copyTemplates(tplSrc, tplDest)
        }

        if (hanaTask) {
            // copy hana related content from db module
            const dbSrc = path.resolve(src, hanaTask.src)
            const dbDest = path.resolve(dest, path.relative(this.buildOptions.root, dbSrc))
            await this._copyNativeHanaContent(dbSrc, dbDest)
        } else {
            this.logger.warn('[cds] - no db module found, skip copying corresponding artefacts')
        }
    }

    async _copyNativeHanaContent(src, dest) {
        return super.copyNativeContent(src, dest, (entry) => {
            if (fs.statSync(entry).isDirectory()) {
                const folderName = path.basename(entry)
                return folderName !== FOLDER_NODE_MODULES
            }
            return /\.csv$|\.cds$|\.hdb.*$|^\.hdi.*|^undeploy\.json/.test(path.basename(entry))
        })
    }

    async _copyTemplates(src, dest) {
        return super.copyNativeContent(src, dest, (entry) => {
            if (fs.statSync(entry).isFile()) {
                return /\.cds$/.test(path.basename(entry))
            }
            return true
        })
    }

    async _compileCsn(modelPaths) {
        return require('../../models/cdsv').compile(modelPaths, path.relative(process.cwd(), this.buildOptions.root))
    }

    /**
     * Extensions shall be restricted to relevant entities, by default all entities and services can be extended.
     * Empty whitelists indicate that all services or entities can be extended.
     * <br>
     * A warning is logged in case neither a 'entity-whitelist' nor a o service-whitelist has been defined.
     * An error is thrown in case a invalid entry is found.
     *
     * @param {Object} csn - the compiled csn for this SaaS application
     */
    _validateExtensionWhitelists(csn, hanaTask) {
        let entityWhitelist = this.env.get("mtx.entity-whitelist")
        let serviceWhitelist = this.env.get("mtx.service-whitelist")

        // for java projects mtx configuration is part of sidecar config
        if (!entityWhitelist && !serviceWhitelist) {
            const dbPath = path.resolve(this.buildOptions.root, hanaTask ? hanaTask.src : this.env.folders.db)
            const dbEnv = this.env.for("cds", dbPath)
            if (dbEnv && dbEnv.get("mtx")) {
                entityWhitelist = dbEnv.get("mtx.entity-whitelist")
                serviceWhitelist = dbEnv.get("mtx.service-whitelist")
            }
        }

        if (!Array.isArray(entityWhitelist) || !Array.isArray(serviceWhitelist)) {
            this.pushMessages(new BuildMessage("No 'entity-whitelist' or 'service-whitelist' defined for SaaS application. By default all entities and services can be extended.", SEVERITY_WARNING)) //NOSONAR
        }

        if (Array.isArray(entityWhitelist) || Array.isArray(serviceWhitelist)) {
            // validate whitelist entries
            const reflectedCsn = this.cds.reflect(csn)
            const errornousEntries = new Set()
            if (Array.isArray(entityWhitelist)) {
                entityWhitelist.forEach(entityName => {
                    if (!reflectedCsn.find(entity => entity.name === entityName && entity.kind === 'entity')) {
                        errornousEntries.add(entityName)
                    }
                })
            }
            if (Array.isArray(serviceWhitelist)) {
                serviceWhitelist.forEach(serviceName => {
                    if (!reflectedCsn.find(service => service.name === serviceName && service.kind === 'service')) {
                        errornousEntries.add(serviceName)
                    }
                })
            }
            if (errornousEntries.size > 0) {
                throw new BuildError(`Entries in 'entity-whitelist' or 'service-whitelist' of the SaaS application do not exist in cds model - [${[...errornousEntries].join(", ")}]`) //NOSONAR
            }
        }
    }

    /**
     * Returns the build tasks of this project - either user defined or calculated by BuildTaskFactory.
     * A build task of type 'hana' is enforced in order to copy existing native hana artefacts later on.
     *
     * @returns {Array<Object>} the array of build tasks.
     */
    async _getTasks() {
        let tasks = this.buildOptions.tasks || []
        tasks = tasks.filter(task => task.for !== BUILD_TASK_MTX)
        if (tasks.length === 0 || !tasks.find(task => task.for === BUILD_TASK_HANA)) {
            const dbKind = this.env.get("requires.db.kind")
            const buildTaskFactory = new BuildTaskFactory(this.logger, this.cds)
            let derivedTasks = []

            try {
                if (dbKind !== "hana") {
                    // temporarily switch db.kind to 'hana' to make sure a hana build task
                    // is created as mtx is only supporting hana
                    setProperty(this.env, "requires.db.kind", "hana")
                }
                derivedTasks = await buildTaskFactory._createTasksFromConfig(this.buildOptions)
            }
            finally {
                if (dbKind !== "hana") {
                    setProperty(this.env, "requires.db.kind", dbKind)
                }
            }
            if (tasks.length === 0) {
                // no custom tasks, use derived tasks
                tasks = derivedTasks
            }
            else {
                // merge hana task into custom tasks
                // assuming that custom tasks have been defined for service modules
                tasks = tasks.concat(derivedTasks.find(task => task.for === BUILD_TASK_HANA))
            }
        }
        return tasks
    }
}
module.exports = MtxModuleBuilder
