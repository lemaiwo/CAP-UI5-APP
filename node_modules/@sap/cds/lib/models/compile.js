const cds = require('../cds')
const cdsv = require('./cdsv')
const YAML = { stringify: (...args) => (YAML.stringify = require('./2yaml'))(...args) }
// alpha fixes for gaps
const _skip_unused = require ('../alpha/_skip_unused')

const compile = (csn) => ({
  for: Object.assign ((x,o) => _fluent (compile_for,x, csn,o), {
    odata: (o)=> compile_for.odata (csn,o),
    hana: (o)=> compile_for.hana (csn,o),
    sql: (o)=> compile_for.sql (csn,o),
  }),
  to: Object.assign ((x,o) => _fluent (compile_to,x, csn,o), {
    'edmx-v2': (o)=> compile_to['edmx-v2'] (csn,o),
    'edmx-v4': (o)=> compile_to['edmx-v4'] (csn,o),
    edmx: (o)=> compile_to.edmx (csn,o),
    edm: (o)=> compile_to.edm (csn,o),
    yaml: (o)=> compile_to.yaml (csn,o),
    json: (o)=> compile_to.json (csn,o),
    sql: (o)=> compile_to.sql (csn,o),
    cdl: (o)=> compile_to.cdl (csn,o),
    hdi: (o)=> compile_to.hdi (csn,o),
    hana: (o)=> compile_to.hana (csn,o),
    hdbcds: (o)=> compile_to.hdbcds (csn,o),
    hdbtable: (o)=> compile_to.hdbtable (csn,o),
  }),
})

// Fluent API, i.e. compile(csn).to('yml') --> see also: https://bit.ly/capire/APIs#cds-compile)
function _fluent (compile_, to_or_for, csn, o) {
    let fn = compile_[to_or_for];  if (!fn)  throw new TypeError (`cds.compile.for.${to_or_for} is not defined`)
    if (typeof csn === 'string')  csn = cds.parse (csn)
    return fn (csn,o)
}

// Dedicated API, i.e. compile.for.odata(csn)
const compile_for = {
  odata: (csn,o) => { // we cache because cds-services calls us for every single service in a model
    const cached = csn._4odata; if (cached) return cached
    const csn4 = cdsv.forOData (csn,o);  /* cache it: */ Object.defineProperty (csn, '_4odata', {value: csn4})
    csn4 ['@sql_mapping'] = o && o.sql_mapping || cds.env.sql_mapping
    return csn4
  },
  sql: (csn,o) => cdsv.forSql (csn,o),
}

// Dedicated API, i.e. compile.to.yml('csn')
const compile_to = {
  yaml: YAML.stringify, yml: YAML.stringify,
  json: x => JSON.stringify (x, _2json, 2),
  edmx: (csn,o) => _2edm (csn,o, {off: 'metadata', only: 'annotations'}[o && o.annos]),
  'edmx-v2': (csn,o) => compile_to.edmx(csn,{...o,version:'v2'}),
  'edmx-v4': (csn,o) => compile_to.edmx(csn,{...o,version:'v4'}),
  edm: (csn,o) => _2edm (csn,o, 'metadata_json'),
  annos: (csn,o) => _2edm (csn,o, 'annotations'),
  swgr: (csn,o) => _2many  (cdsv.toSwagger(csn,o).services, '.swgr.json'),
  cdl: (csn,o) => _2many (cdsv.toCdl(csn,o),'.cds'),
  sql: _2sql,
  hana: _2hana,
  hdbcds: (csn,o) => compile_to.hana (csn,o),
  hdbtable: (csn,o) => compile_to.hdi (csn,o),
  hdi: (csn,o) => { _skip_unused (csn); return _2manyMap (cdsv.toHdi (csn, o))},
  hdbtabledata: (csn,o) => require('./2tabledata').create (csn,o),
  serviceinfo: (csn,o) => require('./2srvinfo') (csn,o),
  xsuaa: (csn,o) => require('./2xsuaa').xsuaaConfig (csn,o)
}



function _2json (key,v) {
  if (!v) return v

  else if (v.grant && v.where) try {
    // Add a parsed _where clause for @restrict.{grant,where} annotations
    return {...v, _where: JSON.stringify (cds.parse.xpr(v.where)) }
  } catch(e){/* ignored */}

  else if (v.kind === "service" && !v['@source'] && v.$location && v.$location.file) {
    // Preserve original sources for services so we can use them for finding
    // sibling implementation filed when reloaded from csn.json.
    return { '@source': v.$location.file.replace(/\\/g,'/'), ...v }
  }

  return v
}

/** Return output of 2hana as an iterable */
function* _2many (content, suffix='.hdbcds') {
  for (let each in content) yield [content[each], // content
    { name: each.replace(/[.:/\\]/g, '_'), suffix }
  ]
}

/** Return output of e.g. 2hdi for hdbtable/hdbview as an iterable */
function* _2manyMap(content) {
  for (const suffix of Object.keys(content)) {
    if (suffix !== 'messages') {
      const ext = '.' + suffix
      const artifacts = content[suffix]
      for (const name of Object.keys(artifacts)) {
        yield [artifacts[name], { name, suffix: ext }]
      }
    }
  }
}

function _2sql (csn,o) {
  if (cds.env.features.skip_unused)  _skip_unused (csn)
  const all=[], {sql} = cdsv.toSql (csn,o)
  for (let e in sql)  all.push (sql[e].replace(/-- generated by.*\n/,'').replace(/;$/, ''))
  if (cds.env.features.localized) {
    (_2sql.unfold_ddl || (_2sql.unfold_ddl = require ('../alpha/_localized').unfold_ddl)) (all, csn, o)
  }
  // return output as array of ddl statements or a concatenated string of which:
  if (o && o.as === 'str') return '\n'+ all.join(';\n\n') +';\n'
  else return all
}

function _2hana (csn,o) {
  _skip_unused (csn)
  return _2many (cdsv.toHana(csn,o).hdbcds, '.hdbcds')
}

/** Returns output of 2edm/x as a single json object or edmx string or as an iterable for all of which */
function _2edm (csn, o={}, what='combined') { // NOSONAR

  if (what === 'combined')  o.combined = true;  else o.separate = true
  if (what === 'metadata_json')  o.json = true;  else o.xml = true
  if (!o.version)  o.version = o.json ? 'v4' : cds.env.odata.version

  const {services} = cdsv.toOdata(csn,o) || {}
  const chosen = o.service

  if (chosen === 'all') { //> all services
    const all = function*(){ for (let s in services)  yield [ _result(s), {name:s} ] }
    return all()
  } else if (chosen) { //> a specific service
    const one = Object.keys(services).find (n => n.indexOf(chosen) >= 0)
    return one ? _result(one) : _not_found (chosen)
  } else { //> a single service
    const [one,many] = Object.keys(services)
    return many ? _choose_one_of(services) : _result(one)
  }

  function _result (name) {
    if (Object.keys(services).length === 0)  throw new Error('No service definitions found')
    const x = services[name][what]
    return o.as === 'str' && typeof x !== 'string' ? JSON.stringify(x) : x
  }
  function _choose_one_of (all) {
    throw new Error (`[cds] - multiple service definitions found in model; add one of...\n
    -s all ${Object.keys(all).map (each => `\n    -s ${each}`).join('')} \n`)
  }
  function _not_found (name) {
    if (Object.keys(services).length === 0)  throw new Error('No service definitions found')
    throw new Error (`[cds] - no service definition matching '${name}' found among...
    ${Object.keys(services).map (each => `\n   ${each}`).join('')} \n`)
  }

}


module.exports = Object.assign (compile, {
  // NOTE: this is the former cds.parse.cdl
  cdl: (src,o) => cdsv.parse (src,o),
  for: compile_for,
  to: compile_to,
})
