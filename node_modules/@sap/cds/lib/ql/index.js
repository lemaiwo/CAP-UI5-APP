/* eslint-disable no-inner-declarations */
const lib = require('../srv/@sap/cds-runtime')
if (/\b(y|ql)\b/.test(process.env.cdr)) {
    const ql = require('@sap/cds-reflect/lib/ql')
    ql.connect = (...args) => new lib.Service(...args) // FIXME: for compatibility to double-services messaging implementation only
    module.exports = ql
} else {

const cds = require('../cds')
const { inspect } = require('util')
const { extend } = cds

const { BaseStatement } = lib.statements

const Query = extend(BaseStatement).with(
  class Query extends BaseStatement {
    /** Turns all queries into Thenables which execute with primary db by default */
    async then(r, e) {
      if ('_promised' in this) return this._promised.then(r, e)
      const pd = Reflect.getOwnPropertyDescriptor(this._target, '_service')
      const srv = pd ? await cds.connect.to(pd.value.name) : cds.db
      const tx = !this._context ? srv : srv.transaction(this._context)
      const p = tx.run(this).then(r, e)
      Object.defineProperty(this, '_promised', { value: p })
      return p
    }

    /** Beautifies output in REPL */
    [inspect.custom]() {
      const colors = process.env.CDS_TERM_COLORS !== false
      const cmd = this.constructor.name.toUpperCase()
      return (
        `{ ${cmd}: ` +
        inspect(this[cmd], { colors, depth: 22 })
          .replace(/^\w*\s/, '')
          .replace(
            /{ ref: \[([^\]]*)\] }/g,
            (_, ref) => '{ref:[' + ref.slice(1, -1) + ']}'
          )
          .replace(/{ val: ([^ ]*) }/g, '{val:$1}')
          .replace(/{ (xpr|ref|val): /g, '{$1:') +
        '}'
      )
    }

    byKey(ID) {
      if (this.SELECT) this.SELECT.one = true
      if (typeof ID !== 'object') ID = { ID }
      return this.where(ID)
    }

    /** @type <S>(s:S) => ( typeof Query & S ) */
    static subclass(subclass) {
      return subclass
    }

    static factory(fn, _context) { // NOSONAR
      const factory = (e, ...etc) => {
        const _target = !e
          ? cds.error(`Expected a query target but received ${e}`)
          : typeof e === 'string'
          ? { name: e }
          : e.name
          ? e //> a linked csn definition
          : e.ref
          ? { name: e.ref[0] }
          : e._entityName
          ? { __proto__: e, name: e._entityName }
          : e._target || { name: undefined }
        // cds.error (`Expected a string, a query, {ref}, {name} or {_entityName} but received ${e}`)
        // NOTE: DO NOT add || entity.name, as ql.BaseStatement impl does something special for views
        const q = fn(e._entityName || e, ...etc)
        return Object.defineProperty(q, '_target', { value: _target })
      }
      return !_context
        ? factory
        : (..._) => {
            return Object.defineProperty(factory(..._), '_context', { value: _context })
          }
    }
  }
)

const Select = Query.subclass(lib.statements.SELECT.from('x').constructor)
const Insert = Query.subclass(lib.statements.INSERT.into('x').constructor)
const Update = Query.subclass(lib.statements.UPDATE('x').constructor)
const Delete = Query.subclass(lib.statements.DELETE.from('x').constructor)

// REVISIT should be:
// const Select = Query.subclass (lib.statements.Select)
// const Insert = Query.subclass (lib.statements.Insert)
// const Update = Query.subclass (lib.statements.Update)
// const Delete = Query.subclass (lib.statements.Delete)

const Select_from = Select.from
const Insert_into = Insert.into
const Update_entity = Update.entity
const Delete_from = Delete.from
const select_columns = Select.prototype.columns
const update_set = Update.prototype.set

class SELECT extends Select {
  static in(_context) {
    const SELECT_from = this.factory(this.from, _context)
    const SELECT_columns_from = (..._) => ({ from: (e) => SELECT_from(e).columns(..._) })
    return extend(SELECT_columns_from).with({
      from: SELECT_from,
      get distinct() {
        return SELECT._('distinct', this)
      },
      get one() {
        return SELECT._('one', this)
      },
    })
  }

  static _(one_or_distinct, SELECT = this) {
    const SELECT_ood_from = (..._) => {
      if (is_array(_[0])) return { from: (e) => SELECT_ood_from(e).columns(..._) }
      const q = SELECT.from(..._)
      q.SELECT = { [one_or_distinct]: true, ...q.SELECT }
      return q
    }
    const SELECT_ood = Object.assign(
      (..._) =>
        Object.assign(SELECT_ood_from(..._), {
          from: (e) => SELECT_ood_from(e).columns(..._),
        }),
      { from: SELECT_ood_from }
    )
    Object.defineProperty(SELECT, one_or_distinct, { value: SELECT_ood })
    return SELECT_ood
  }

  static from(e, _key, ..._projection) {
    if (_key === undefined) return Select_from(e)
    if (is_columns(_key)) return Select_from(e).columns(_key)
    if (is_object(_key)) return Select_from(e).byKey(_key)
    else
      return Select_from(e)
        .byKey({
          [e.keys ? Object.keys(e.keys)[0] : 'ID']: _key,
        })
        .columns(..._projection)
  }

  /** Allows to redirect queries
   * @example
   * req.query.redirectTo ('OtherEntity')
   */
  redirectTo(entity) {
    const q = SELECT.from(entity),
      { from } = q.SELECT
    Object.assign(q.SELECT, this.SELECT, { from })
    return q
  }

  /** @example
   * SELECT.from('Foo') .columns ((foo)=>{...})
   */
  columns(cols, ...more) {
    if (!cols) return this
    if (is_function(cols)) cols = _projection4(cols, this.entity)
    if (is_array(cols)) return select_columns.call(this, ...cols)
    else return select_columns.call(this, cols, ...more)
  }

  /** @example
   * SELECT.from(...).expand(...)
   */
  expand(ref, cols, exp = 'expand') {
    const { SELECT } = this,
      columns = SELECT.columns || (SELECT.columns = [])
    const col = { ref: ref.split('.'), [exp]: cols ? _projection4(cols) : ['*'] }
    columns.push(col)
    return this
  }

  /** @example
   * SELECT.from(...).inline(...)
   */
  inline(ref, cols) {
    return this.expand(ref, cols, 'inline')
  }

  /** @example
   * SELECT.from(...).foreach(...)
   */
  foreach(callback) {
    return this.then((rows) => rows.map(callback))
  }
}

class INSERT extends Insert {
  static in(_context) {
    const INSERT_into = this.factory(this.into, _context)
    const INSERT_entries_into = (..._) => ({ into: (e) => INSERT_into(e).entries(..._) })
    return extend(INSERT_entries_into).with({ into: INSERT_into })
  }

  static into(e, ...entries) {
    const q = Insert_into(e)
    if (entries.length) q.entries(...entries)
    return q
  }
}

class UPDATE extends Update {
  static in(_context) {
    const UPDATE_entity = this.factory(this.entity, _context)
    return extend(UPDATE_entity).with({ entity: UPDATE_entity })
  }

  static entity(e, _key) {
    const q = Update_entity(e)
    if (_key) {
      if (typeof _key !== 'object') _key = { ID: _key }
      return q.byKey(_key)
    }
    return q
  }

  /** Add support for UPDATE('Foo').set ( expr | fragments | feather ) */
  with(...args) {
    return this.set(...args)
  }
  set(...args) { // NOSONAR
    if (typeof args[0] === 'object') return update_set.call(this, ...args)
    const cqn = (this.UPDATE.with = {})
    if (args.length === 1)
      for (let each of _data(args[0])) {
        const {
          xpr: [lhs, op, ...rhs],
        } = cds.parse.expr(each)
        cqn[lhs.ref.join('.')] = _rhs(lhs, op, ...rhs)
      }
    else
      for (let i = 0; i < args.length; ++i) {
        const [, col, op] = /\s*([\w.]+)\s*([%*+-]?=)/.exec(args[i])
        cqn[col] = _rhs(col, op, { val: args[++i] })
      }
    function _rhs(lhs, op, ...rhs) {
      if (op === '=') return rhs.length === 1 ? rhs[0] : { xpr: rhs }
      if (op.length === 2 && op[1] === '=')
        return { xpr: [lhs.ref ? lhs : { ref: [lhs] }, op[0], ...rhs] }
      else throw new Error('Invalid operator in UPDATE(...).set() expression: ' + op)
    }
    return this
  }
}

class DELETE extends Delete {
  static in(_context) {
    const DELETE_from = this.factory(this.from, _context)
    return extend(DELETE_from).with({ from: DELETE_from })
  }

  static from(e, _key) {
    const q = Delete_from(e)
    if (_key) {
      if (typeof _key !== 'object') _key = { ID: _key }
      return q.byKey(_key)
    }
    return q
  }
}

extend(Select).with(SELECT)
extend(Insert).with(INSERT)
extend(Update).with(UPDATE)
extend(Delete).with(DELETE)

function _data(s) { // NOSONAR
  let all = [],
    start = 0,
    scope = 0,
    close = 0,
    stack = [close]
  for (let i = 0; i < s.length; ++i) {
    const c = s[i]
    if (c === ',' && !scope) {
      all.push(s.slice(start, i))
      start = i + 1
    } else if (c === "'") {
      while (i < s.length) {
        if (s[++i] === "'") {
          if (s[i + 1] === "'") ++i // NOSONAR
          else break
        }
      }
    } else if (c === '(') {
      scope++
      stack.unshift((close = ')'))
    } else if (c === '[') {
      scope++
      stack.unshift((close = ']'))
    } else if (c === '{') {
      scope++
      stack.unshift((close = '}'))
    } else if (c === close) {
      scope--
      stack.shift()
      close = stack[0]
    }
  }
  all.push(s.slice(start))
  return all
}

  /* eslint no-unused-vars: off */
  function _projection4(x, entity) { // NOSONAR
  if (x === '*') return ['*']
  if (is_array(x)) return x.map((c) => (c.ref ? c : { ref: c.split('.') }))
  if (typeof x === 'function') {
    const columns = []
    x(
      new Proxy(noop, {
        apply: (_, __, [x]) => {
          columns.push(x)
          return {
            as(alias) {
              x.as = alias
            },
          }
        },
        get: (_, p) => {
          let col = { ref: [p] }
          columns.push(col)
          return new Proxy(noop, {
            // handle getters like (foo)=>{ foo.bar.car }
            get: (_, p, me) => {
              if (p === 'where')
                return (pred) => {
                  col.where = _predicate4(pred)
                  return me
                }
              if (p === 'as')
                return (alias) => {
                  col.as = alias
                  return me
                }
              else {
                col.ref.push(p)
                return me
              }
            },
            // handle nested projections e.g. (foo)=>{ foo.bar (b=>{ ... }) }
            apply: (_, __, [fn, { levels = 1 } = {}]) => {
              if (fn === '.*') return (col.inline = ['*'])
              if (fn === '*') return (col.expand = ['*'])
              if (/^\(?_\b/.test(fn)) {
                col.inline = _projection4(fn)
              } else {
                col.expand = _projection4(fn)
                while (--levels) {
                  // add n-level deep hierarchy expands
                  col.expand.push((col = { ...col, expand: [...col.expand] }))
                }
              }
            },
          })
        },
      })
    )
    return columns
  } else throw new Error('SELECT w/ invalid projection argument: ' + JSON.stringify(x))
}

/**
 * Helper to create a predicate from a feather object
 */
function _predicate4(o) {
  const predicates = []
  for (let each in o) {
    predicates.push('and', { ref: each.split('.') }, '=', { val: o[each] })
  }
  return predicates.slice(1)
}

function disable_cds_run() {
  if (disable_cds_run.once || cds.env.singletenant) return
  else disable_cds_run.once = true
  const disabled = () => {
    throw new Error(`
    Shortcut srv.run() is only available in plain node programs and disabled
    when running services. Always run queries like that in event handlers:
     srv.on('READ','Foo', (req)=>{
        const tx = cds.transaction(req)
        tx.run (SELECT.from('Foo'))
     }
    `)
  }
  Object.defineProperty(lib.Service.prototype, 'run', { value: disabled })
}
disable_cds_run.once = true //> REVISIT: switching that off for the time being

const noop = () => {}
const is_array = Array.isArray
const is_object = (x) => typeof x === 'object' && !is_array(x)
const is_columns = (x) => typeof x === 'function' || is_array(x)
const is_function = (x) => typeof x === 'function'

const cds_ql = (_context) => ({
  get SELECT() {
    return SELECT.in(_context)
  },
  get INSERT() {
    return INSERT.in(_context)
  },
  get UPDATE() {
    return UPDATE.in(_context)
  },
  get DELETE() {
    return DELETE.in(_context)
  },
})

module.exports = Object.assign(cds_ql, lib.statements, cds_ql(), {
  connect: (...args) => new lib.Service(...args), // FIXME: for compatibility to double-services messaging implementation only
  disable_cds_run,
  Query,
})

}
