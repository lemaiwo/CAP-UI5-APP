const cds = require ('../../cds'), {snapi} = cds.env.features, required = {db:cds.env.requires.db||{}}
const lib = require ('../@sap/cds-runtime')


class ProtocolAdapter {

    static at (p) {
        return registry[p] || cds.error `Service protocol ${p} is not supported`
    }


    /**
     * Constructs / returns a ProtocolAdapter for the given service and protocol.
     * The constructed adapters are cached per service, so subsequent calls
     * for same service and protocol returns the formerly constructed one.
     * @returns {ProtocolAdapter}
     */
    static serve (srv, protocol = _protocol4(srv)) {
        const cached = (srv._adapters || (srv._adapters={})) [protocol]; if (cached) return cached
        const Adapter = this.at (protocol)
        const adapter = new Adapter (srv)
        const {processEvent} = srv; srv.processEvent = (eve, ...etc) => {
            const req = eve._.shared && eve._.shared.req || eve._.req
            if (req) {
                Adapter.patch (eve)
                req.emit ('dispatch', eve)
            }
            return processEvent.call (srv, eve, ...etc)
        }
        cds.extend (adapter) .with (ProtocolAdapter.prototype, {service:srv})
        return srv._adapters [protocol] = adapter
    }

    /**
     * Service implementations in @sap/cds-service hold models in several redundant places:
     * 1. srv.model -> linked model, filled from `options.reflectedModel`
     * 2. srv._csn -> virgin csn, filled from `model` argument -> must not be unfolded for odata pre-snapi!
     * 3. srv.options.model = srv.model (-> in srv._getMessagingService)
     * 4. srv._messagingService.model = srv.model
     * 5. srv._handlers{...}._model = { initial, before, on, after, reject } -> horribly redundant
     */
    static prepare (model,o) {
        const protocol = _protocol4 ({ definition: model.definitions[o.service], options:o })
        const m = this.at(protocol)._prepare (model,o)
        if ((cds.db||required.db).kind === 'sqlite') {
            (cds._4sqlite || (cds._4sqlite = require ('../../alpha/_localized'))) (o.reflectedModel||m)
            // REVISIT: ^ should move to ApplicationService
        }
        return m
    }
    static _prepare (model,o) {
        o.reflectedModel = cds.linked (o.reflectedModel || model)
        return model
    }
    static patch(){}


    /**
     * Mounts the adapter to an express app.
     */
    in (app) {
        const srv = this.service
        lib.performanceMeasurement (app)
        // audit logger to be provided here, current workaround: take it from service
        lib.passport (srv, app, srv._auditLogger, srv.options)
        // catch Fiori's lookup requests for resources in webapp and ugly warnings
        app.use (srv.path+'/webapp/', (_,res)=> res.sendStatus(404))
        // finally mount the service's protocol adaptor
		app.use (srv.path, this)
		return srv
    }

    /**
     * Returns a proxy handler function with the specified service
     * as its prototype to allow usages like this:
     *
     *    const { CatalogService } = cds.serve(...)
     *    app.use ('/cats', CatalogService)
     */
    asRouter() {
        if (!this._as_service) {
			const router = this._as_service = (...args) => this (...args)
			Object.defineProperty (router, 'name', {value: this.service.name})
			Object.setPrototypeOf (router, this.service)
		}
        return this._as_service
    }

}


class ProtocolAdapter4REST extends ProtocolAdapter {

    constructor (srv) { return lib.to.rest(srv) } // NOSONAR

    static _prepare (csn,o) {
        // REVISIT: Eigentlich ist das bissl seltsam, dass wir das auch für Rest benötigen
        // Ohne das schlagen aber die integration tests in @sap/cds-services fehl
        const model = o.reflectedModel = cds.compile.for.odata (csn,{version:'v4'})
        return super._prepare (snapi ? model : csn, o)
    }
    static patch (req) {
        req._.path = req._.req.path
        req._.query = req._.req.query
    }
}


class ProtocolAdapter4OData extends ProtocolAdapter4REST {

    constructor (srv) { return lib.to.odata_v4(srv) } // NOSONAR

    static _prepare (csn,o) {
        const model = o.reflectedModel = cds.compile.for.odata (csn,{version:'v4'})
        return super._prepare (snapi ? model : csn, o)
    }

    static patch (req) {
        Object.defineProperty (req, 'params', get_params)
        req._.path = req._.odataReq._url.pathname
        req._.query = req._.odataReq._queryOptions
    }
}


const get_params = {
    get: function() {
        const params = this._.odataReq._uriInfo._pathSegments .map (seg => seg._keyPredicates[0] && seg._keyPredicates[0]._value)
        Object.defineProperty (this, 'params', { value: params })
        return params
    },
    configurable: true
}



const registry = {
    rest: ProtocolAdapter4REST,
    odata: ProtocolAdapter4OData,
    odata_v2: ProtocolAdapter4OData,
    odata_v4: ProtocolAdapter4OData,
    fiori: ProtocolAdapter4OData,
}


const _protocol4 = (srv) => {
    const def = srv.definition, o = srv.options
    return o.to || def['@protocol'] || 'odata_v4'
}

module.exports = ProtocolAdapter
