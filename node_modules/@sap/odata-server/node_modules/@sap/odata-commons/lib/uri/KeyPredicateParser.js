'use strict';

const UriSemanticError = require('../errors/UriSemanticError');
const KeyValueParser = require('./KeyValueParser');
const UriTokenizer = require('./UriTokenizer');
const TokenKind = UriTokenizer.TokenKind;
const UriParameter = require('./UriParameter');
const UriHelper = require('./UriHelper');
const EdmTypeKind = require('../edm/EdmType').TypeKind;
const EdmPrimitiveTypeKind = require('../edm/EdmPrimitiveTypeKind');

/**
 * Parser for URI key predicates.
 * @extends KeyValueParser
 */
class KeyPredicateParser extends KeyValueParser {
    /**
     * Parses the key predicates from the tokenizer.
     * @param {UriResource} currentResource The current resource
     * @param {EdmEntityType} edmEntityType the EDM type of the current resource
     * @param {UriTokenizer} tokenizer the current URI tokenizer
     * @returns {UriParameter[]} the found key predicates
     */
    parse(currentResource, edmEntityType, tokenizer) {
        const requiredKeyProperties = this._buildRequiredKeyProperties(currentResource, edmEntityType);
        return [].concat(
            requiredKeyProperties.size > 1 ?
                this._parseCompoundKey(requiredKeyProperties, edmEntityType, tokenizer) :
                this._parseSimpleKey(requiredKeyProperties, edmEntityType, tokenizer)
        );
    }

    /**
     * Parses the key predicates from URI segments following the key-as-segment convention.
     * @param {UriResource} currentResource the current resource
     * @param {string[]} uriPathSegments the URI path segments
     * @returns {?(UriParameter[])} the found key predicates or null if not all key predicates have been found
     */
    parseKeyPathSegments(currentResource, uriPathSegments) {
        const edmEntityType = currentResource.getEdmType();
        let keyPredicates = [];
        for (const propertyRef of this._buildRequiredKeyProperties(currentResource, edmEntityType).values()) {
            const value = uriPathSegments[keyPredicates.length];
            if (value === undefined) return null;
            let type = propertyRef.getProperty().getType();
            if (type.getKind() === EdmTypeKind.ENUM) {
                if (super.parseEnumValue(type, value) === null) return null;
            } else {
                if (type.getKind() === EdmTypeKind.DEFINITION) type = type.getUnderlyingType();
                if (type === EdmPrimitiveTypeKind.Duration) {
                    let tokenizer = new UriTokenizer(UriHelper.toUriLiteral(value, type));
                    if (!tokenizer.next(TokenKind.DurationValue)) return null;
                    if (!tokenizer.next(TokenKind.EOF)) return null;
                } else if (type !== EdmPrimitiveTypeKind.String) {
                    let tokenizer = new UriTokenizer(value);
                    if (!super.getTokenKindsForType(type).some(kind => tokenizer.next(kind))) return null;
                    if (!tokenizer.next(TokenKind.EOF)) return null;
                }
            }
            keyPredicates.push(new UriParameter().setText(value, type).setEdmRef(propertyRef));
        }
        return keyPredicates;
    }

    /**
     * Builds the required key properties map.
     * @param {UriResource} currentResource The current resource
     * @param {EdmEntityType} edmEntityType the EDM entity type of the current resource
     * @returns {Map.<string, EdmKeyPropertyRef>} the map of required key properties
     * @private
     */
    _buildRequiredKeyProperties(currentResource, edmEntityType) {
        let requiredKeyProperties = new Map(edmEntityType.getKeyPropertyRefs());

        const navigationProperty = currentResource.getNavigationProperty();
        if (navigationProperty) {
            const partner = navigationProperty.getPartner();
            if (partner) {
                // "If a navigation property leading to a related entity type has a
                // partner navigation property that specifies a referential constraint,
                // then those key properties of the related entity that take part in
                // the referential constraint MAY be omitted from URLs."
                for (const name of partner.getReferentialConstraints().keys()) {
                    requiredKeyProperties.delete(name);
                }
            }
        }

        return requiredKeyProperties;
    }

    /**
     * Parses a compound key.
     * @param {string[]} requiredKeyProperties The required key property names
     * @param {EdmEntityType} edmEntityType the current EDM entity type
     * @param {UriTokenizer} tokenizer the current URI tokenizer
     * @returns {UriParameter[]} the found key predicates
     * @private
     */
    _parseCompoundKey(requiredKeyProperties, edmEntityType, tokenizer) {
        const visitedKeyProperties = super.parse(tokenizer,
            propertyRefName => edmEntityType.getKeyPropertyRef(propertyRefName),
            propertyRefType => [propertyRefType.getProperty().getType()]
        );

        // Testing if at least all required key properties have been visited
        const missingKeyPredicateNames = Array.from(requiredKeyProperties.keys())
            .filter(name => !visitedKeyProperties.has(name));
        if (missingKeyPredicateNames.length > 0) {
            throw new UriSemanticError(UriSemanticError.Message.KEY_PREDICATES_MISSING,
                missingKeyPredicateNames.join(','));
        }

        let result = [];
        for (let [key, value] of visitedKeyProperties) {
            result.push(value.setEdmRef(edmEntityType.getKeyPropertyRef(key)));
        }
        return result;
    }

    /**
     * Parses a simple key.
     * @param {string[]} requiredKeyProperties The required key property names
     * @param {EdmEntityType} edmEntityType the current EDM entity type
     * @param {UriTokenizer} tokenizer The current tokenizer
     * @returns {UriParameter[]} the found key predicates
     * @private
     */
    _parseSimpleKey(requiredKeyProperties, edmEntityType, tokenizer) {
        const propertyRef = requiredKeyProperties.values().next().value;
        const propertyRefType = propertyRef.getProperty().getType();

        // First try to parse key when key is like ES(value)
        let parameter = this.parseUriParameter(propertyRefType, tokenizer);
        if (parameter) {
            return [parameter.setEdmRef(propertyRef)];
        }

        // Second try to parse key when key is like ES(ODataIdentifier=value)
        return this._parseCompoundKey(requiredKeyProperties, edmEntityType, tokenizer);
    }
}

module.exports = KeyPredicateParser;
